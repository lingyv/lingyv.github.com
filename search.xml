<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[自由世界的大门--OpenWrt上手]]></title>
      <url>%2F2017%2F04%2F17%2FOpenWrt%E4%B8%8A%E6%89%8B%2F</url>
      <content type="text"><![CDATA[自由世界的大门–DIR-505路由器刷OpenWrt有次闲逛论坛时，发现有个叫’OpenWrt’的Linux嵌入式发行版本，可以刷入路由器做’智能’路由器。这让我喜出望外，刷了它就可以’掌控’自己的路由器了嘛！作为一个行动派，废话少说，赶紧动起来。我的路由器是D-Link的DIR-505，8MB Flash，64MB RAM。 刷DIR-505国际版固件因为DIR-505是锁区的，而 OpenWRT.org 编译的 ROM 不是为中国版准备的，所以首先，要先给DIR-505刷国际版固件。去 D-Link 官方国际站可以下载原厂固件，用16进制编辑器把DEF改成CN，升级固件，然后再刷OpenWrt固件。中国版: 国际版： 改好后，去路由器管理页面，维护 –&gt; 固件,上传固件。 刷OpenWrt固件去OpenWrt官方网站下载 dir-505 的固件，要选择’factory.bin’结尾的固件。下载后，去路由器管理页面，维护 –&gt; 固件,上传固件。 OpenWrt基本设置修改root用户密码刚刚刷好 OpenWRT 的 DIR-505，默认没有开启 WiFi，所以只能用网线连接，连起来后，将电脑的网卡配置为 192.168.1.X，然后用ssh连接OpenWrt,首先修改root用户的密码：1passwd root 开启 WiFi开启wifi：123456uci set wireless.@wifi-device[0].disabled=0;uci set wireless.@wifi-iface[0].ssid=&apos;FreeWorld&apos;;uci set wireless.@wifi-iface[0].encryption=&apos;psk2+ccmp&apos;;uci set wireless.@wifi-iface[0].key=&apos;password&apos;;uci commit wireless;wifi 改时区系统默认是第零时区的时间，所以要先修改成第八时区：1234uci set system.@system[0].zonename=&apos;Asia/Shanghai&apos;;uci set system.@system[0].timezone=&apos;CST-8&apos;;uci commit system;echo CST-8 &gt; /etc/TZ; 有线中继我有两个路由器，这个刷了OpenWrt的路由器打算做二级路由，主路由的ip网段是192.168.1.XXX，OpenWrt路由器的ip网段为192.168.0.XXX：12345678910111213uci delete network.lan.ifnameuci delete network.lan.typeuci add network interfaceuci rename network.@interface[-1]=&apos;wan&apos;uci set network.@interface[-1].ifname=&apos;eth1&apos;uci set network.wan.proto=staticuci set network.wan.ipaddr=192.168.1.123uci set network.wan.netmask=255.255.255.0uci set network.wan.gateway=192.168.1.1uci set network.wan.dns=&apos;114.114.114.114 114.114.115.115&apos;uci set network.lan.ipaddr=192.168.0.1uci set network.lan.dns=&apos;114.114.114.114 114.114.115.115&apos;uci commit network 设置好以后，重启network服务：1/etc/init.d/network restart WEB管理界面LUCI安装安装LUCI可以访问互联网以后，接下来安装WEB管理界面LUCI，方便管理路由器：1234opkg updateopkg install luci/etc/init.d/uhttpd enable/etc/init.d/uhttpd start 配置中文1opkg install luci-i18n-base-zh-cn 安装shadowsocks由于经常要访问墙外的网站，所以，顺手装个shadowsocks方便在网络世界里傲游。访问192.168.0.1web管理界面，进入系统 --&gt; 软件包界面，根据shadowsocks关键字搜索软件包，需要安装3个软件包：shadowsocks-libev，luci-app-shadowsocks-libev，luci-i18n-shadowsocks-libev-zh-cn。 安装好后，设置shadowsocks: 根据dnsmasq-china-list项目获取国内域名加速列表和污染地址屏蔽列表： 12345678opkg updateopkg install wgetwget -4 --no-check-certificate -O /etc/dnsmasq.d/accelerated-domains.china.conf https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.confwget -4 --no-check-certificate -O /etc/dnsmasq.d/bogus-nxdomain.china.conf https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/bogus-nxdomain.china.confecho &quot;server=/#/127.0.0.1#1314&quot; &gt; gfwlist.conf 设置shadowsocks帐号 重启dnsmasq服务:1/etc/init.d/dnsmasq restart 自动更新DNS转发列表12345678910cd /usr/bintouch updatednsmasqchmod +x updatednsmasqvi updatednsmasqcnlist() &#123;wget -4 --no-check-certificate -O /etc/dnsmasq.d/accelerated-domains.china.conf https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.confwget -4 --no-check-certificate -O /etc/dnsmasq.d/bogus-nxdomain.china.conf https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/bogus-nxdomain.china.conf&#125;cnlist 然后新建一个计划任务，让它每天凌晨1点跑一次。在路由器管理web页面，找到“系统”→“计划任务”，输入如下内容：1* 1 * * * /usr/bin/updatednsmasq 检测shadowsocks状态，挂了自动重启12345678910111213141516171819cd /usr/bintouch checkss.shvi checkss.sh#!/bin/shLOGTIME=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)wget -4 --spider --quiet --tries=1 --timeout=3 www.google.comif [ &quot;$?&quot; == &quot;0&quot; ]; then echo &apos;[&apos;$LOGTIME&apos;] No Problem.&apos; exit 0else wget -4 --spider --quiet --tries=1 --timeout=3 www.baidu.com if [ &quot;$?&quot; == &quot;0&quot; ]; then echo &apos;[&apos;$LOGTIME&apos;] Problem decteted, restarting shadowsocks.&apos; /etc/init.d/shadowsocks restart else echo &apos;[&apos;$LOGTIME&apos;] Network Problem. Do nothing.&apos; fifi 然后加入计划任务，每三十分钟检测一次shadowsocks并且每天凌晨2点清空日志文件:12*/30 * * * * /usr/bin/checkss.sh &gt;&gt; /var/log/check_shadowsocks.log 2&gt;&amp;10 2 * * * echo &quot;&quot; &gt; /var/log/check_shadowsocks.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lisp的本质]]></title>
      <url>%2F2017%2F03%2F19%2FLisp%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
      <content type="text"><![CDATA[说明函数式编程和面向对象编程可以说是编程的两大宗教，犹如编辑器之争一样，之间口角不断。我虽然靠着OOP的主力语言Java上班挣钱养活自己，但受到《计算机程序的构造和解释》、《黑客与画家》的‘蛊惑’以后，对函数式编程的所谓完美世界很是心向往之。 最近发现一篇文章–《Lisp的本质》,非常棒，所以分成几篇文章，转过来。 以下为原文： 简介最初在web的某些角落偶然看到有人赞美Lisp时, 我那时已经是一个颇有经验的程序员。在我的履历上, 掌握的语言范围相当广泛, 象C++, Java, C#主流语言等等都不在话下, 我觉得我差不多知道所有的有关编程语言的事情。对待编程语言的问题上, 我觉得自己不太会遇到什么大问题。其实我大错特错了。 我试着学了一下Lisp, 结果马上就撞了墙。我被那些范例代码吓坏了。我想很多初次接触Lisp语言的人, 一定也有过类似的感受。Lisp的语法太次了。一个语言的发明人, 居然不肯用心弄出一套漂亮的语法, 那谁还会愿意学它。反正, 我是确确实实被那些难看的无数的括号搞蒙了。 回过神来之后, 我和Lisp社区的那伙人交谈, 诉说我的沮丧心情。结果, 立马就有一大套理论砸过来, 这套理论在Lisp社区处处可见, 几成惯例。比如说: Lisp的括号只是表面现象; Lisp的代码和数据的表达方式没有差别, 而且比XML语法高明许多, 所以有无穷的好处; Lisp有强大无比的元语言能力, 程序员可以写出自我维护的代码; Lisp可以创造出针对特定应用的语言子集; Lisp的运行时和编译时没有明确的分界; 等等, 等等, 等等。这么长的赞美词虽然看起来相当动人, 不过对我毫无意义。没人能给我演示这些东西是如何应用的, 因为这些东西一般来说只有在大型系统才会用到。我争辩说, 这些东西传统语言一样办得到。在和别人争论了数个小时之后, 我最终还是放弃了学Lisp的念头。为什么要花费几个月的时间学习语法这么难看的语言呢? 这种语言的概念这么晦涩, 又没什么好懂的例子。也许这语言不是该我这样的人学的。 几个月来, 我承受着这些Lisp辩护士对我心灵的重压。我一度陷入了困惑。我认识一些绝顶聪明的人, 我对他们相当尊敬, 我看到他们对Lisp的赞美达到了宗教般的高度。这就是说, Lisp中一定有某种神秘的东西存在, 我不能忍受自己对此的无知, 好奇心和求知欲最终不可遏制。我于是咬紧牙关埋头学习Lisp, 经过几个月的时间费劲心力的练习, 终于,我看到了那无穷无尽的泉水的源头。在经过脱胎换骨的磨练之后, 在经过七重地狱的煎熬之后, 终于, 我明白了。 顿悟在突然之间来临。曾经许多次, 我听到别人引用雷蒙德(译者注: 译文&lt;&lt;大教堂和市集&gt;&gt;的作者, 著名的黑客社区理论家)的话: “Lisp语言值得学习。当你学会Lisp之后, 你会拥有深刻的体验。就算你平常并不用Lisp编程, 它也会使你成为更加优秀的程序员”。过去, 我根本不懂这些话的含义, 我也不相信这是真的。可是现在我懂得了。这些话蕴含的真理远远超过我过去的想像。我内心体会到一种神圣的情感, 一瞬间的顿悟, 几乎使我对电脑科学的观念发生了根本的改变。 顿悟的那一刻, 我成了Lisp的崇拜者。我体验到了宗教大师的感受: 一定要把我的知识传布开来, 至少要让10个迷失的灵魂得到拯救。按照通常的办法, 我把这些道理(就是刚开始别人砸过来的那一套, 不过现在我明白了真实的含义)告诉旁人。结果太令人失望了, 只有少数几个人在我坚持之下, 发生了一点兴趣, 但是仅仅看了几眼Lisp代码, 他们就退却了。照这样的办法, 也许费数年功夫能造就了几个Lisp迷, 但我觉得这样的结果太差强人意了, 我得想一套有更好的办法。 我深入地思考了这个问题。是不是Lisp有什么很艰深的东西, 令得那么多老练的程序员都不能领会? 不是, 没有任何绝对艰深的东西。因为我能弄懂, 我相信其他人也一定能。那么问题出在那里? 后来我终于找到了答案。我的结论就是, 凡是教人学高级概念, 一定要从他已经懂得的东西开始。如果学习过程很有趣, 学习的内容表达得很恰当, 新概念就会变得相当直观。这就是我的答案。所谓元编程, 所谓数据和代码形式合一, 所谓自修改代码, 所谓特定应用的子语言, 所有这些概念根本就是同族概念, 彼此互为解释, 肯定越讲越不明白。还是从实际的例子出发最有用。 我把我的想法说给Lisp程序员听, 遭到了他们的反对。”这些东西本身当然不可能用熟悉的知识来解释, 这些概念完全与众不同, 你不可能在别人已有的经验里找到类似的东西”,可是我认为这些都是遁词。他们又反问我, “你自己为啥不试一下?” 好吧, 我来试一下。这篇文章就是我尝试的结果。我要用熟悉的直观的方法来解释Lisp, 我希望有勇气的人读完它, 拿杯饮料, 深呼吸一下, 准备被搞得晕头转向。来吧, 愿你获得大能。 重新审视XML千里之行始于足下。让我们的第一步从XML开始。可是XML已经说得更多的了, 还能有什么新意思可说呢? 有的。XML自身虽然谈谈不上有趣, 但是XML和Lisp的关系却相当有趣。XML和Lisp的概念有着惊人的相似之处。XML是我们通向理解Lisp的桥梁。好吧, 我们且把XML当作活马医。让我们拿好手杖, 对XML的无人涉及的荒原地带作一番探险。我们要从一个全新的视角来考察这个题目。 表面上看, XML是一种标准化语法, 它以适合人阅读的格式来表达任意的层次化数据(hirearchical data)。象任务表(to-do list), 网页, 病历, 汽车保险单, 配置文件等等, 都是XML用武的地方。比如我们拿任务表做例子:12345&lt;todo name=&quot;housework&quot;&gt; &lt;item priority=&quot;high&quot;&gt;Clean the house.&lt;/item&gt; &lt;item priority=&quot;medium&quot;&gt;Wash the dishes.&lt;/item&gt; &lt;item priority=&quot;medium&quot;&gt;Buy more soap.&lt;/item&gt;&lt;/todo&gt; 解析这段数据时会发生什么情况? 解析之后的数据在内存中怎样表示? 显然, 用树来表示这种层次化数据是很恰当的。说到底, XML这种比较容易阅读的数据格式, 就是树型结构数据经过序列化之后的结果。任何可以用树来表示的数据, 同样可以用XML来表示, 反之亦然。希望你能懂得这一点, 这对下面的内容极其重要。 再进一步。还有什么类型的数据也常用树来表示? 无疑列表(list)也是一种。上过编译课吧? 还模模糊糊记得一点吧? 源代码在解析之后也是用树结构来存放的, 任何编译程序都会把源代码解析成一棵抽象语法树, 这样的表示法很恰当, 因为源代码就是层次结构的：函数包含参数和代码块, 代码快包含表达式和语句, 语句包含变量和运算符等等。我们已经知道, 任何树结构都可以轻而易举的写成XML, 而任何代码都会解析成树, 因此,任何代码都可以转换成XML, 对不对? 我举个例子, 请看下面的函数:123int add(int arg1, int arg2) &#123; return arg1+arg2;&#125; 能把这个函数变成对等的XML格式吗? 当然可以。我们可以用很多种方式做到, 下面是其中的一种, 十分简单:1234567891011&lt;define-function return-type=&quot;int&quot; name=&quot;add&quot;&gt; &lt;arguments&gt; &lt;argument type=&quot;int&quot;&gt;arg1&lt;/argument&gt; &lt;argument type=&quot;int&quot;&gt;arg2&lt;/argument&gt; &lt;/arguments&gt; &lt;body&gt; &lt;return&gt; &lt;add value1=&quot;arg1&quot; value2=&quot;arg2&quot; /&gt; &lt;/return&gt; &lt;/body&gt;&lt;/define&gt; 这个例子非常简单, 用哪种语言来做都不会有太大问题。我们可以把任何程序码转成XML,也可以把XML转回到原来的程序码。我们可以写一个转换器, 把Java代码转成XML, 另一个转换器把XML转回到Java。一样的道理, 这种手段也可以用来对付C++(这样做跟发疯差不多么。可是的确有人在做, 看看GCC-XML(http://www.gccxml.org)就知道了)。进一步说,凡是有相同语言特性而语法不同的语言, 都可以把XML当作中介来互相转换代码。实际上几乎所有的主流语言都在一定程度上满足这个条件。我们可以把XML作为一种中间表示法,在两种语言之间互相译码。比方说, 我们可以用Java2XML把Java代码转换成XML, 然后用XML2CPP再把XML转换成C++代码, 运气好的话, 就是说, 如果我们小心避免使用那些C++不具备的Java特性的话, 我们可以得到完好的C++程序。这办法怎么样, 漂亮吧? 这一切充分说明, 我们可以把XML作为源代码的通用存储方式, 其实我们能够产生一整套使用统一语法的程序语言, 也能写出转换器, 把已有代码转换成XML格式。如果真的采纳这种办法, 各种语言的编译器就用不着自己写语法解析了, 它们可以直接用XML的语法解析来直接生成抽象语法树。 说到这里你该问了, 我们研究了这半天XML, 这和Lisp有什么关系呢? 毕竟XML出来之时,Lisp早已经问世三十年了。这里我可以保证, 你马上就会明白。不过在继续解释之前, 我们先做一个小小的思维练习。看一下上面这个XML版本的add函数例子, 你怎样给它分类,是代码还是数据? 不用太多考虑都能明白, 把它分到哪一类都讲得通。它是XML, 它是标准格式的数据。我们也知道, 它可以通过内存中的树结构来生成(GCC-XML做的就是这个事情)。它保存在不可执行的文件中。我们可以把它解析成树节点, 然后做任意的转换。显而易见, 它是数据。不过且慢, 虽然它语法有点陌生, 可它又确确实实是一个add函数,对吧? 一旦经过解析, 它就可以拿给编译器编译执行。我们可以轻而易举写出这个XML代码解释器, 并且直接运行它。或者我们也可以把它译成Java或C++代码, 然后再编译运行。所以说, 它也是代码。 我们说到那里了? 不错, 我们已经发现了一个有趣的关键之点。过去被认为很难解的概念已经非常直观非常简单的显现出来。代码也是数据, 并且从来都是如此。这听起来疯疯癫癫的, 实际上却是必然之事。我许诺过会以一种全新的方式来解释Lisp, 我要重申我的许诺。但是我们此刻还没有到预定的地方, 所以还是先继续上边的讨论。 刚才我说过, 我们可以非常简单地实现XML版的add函数解释器, 这听起来好像不过是说说而已。谁真的会动手做一下呢? 未必有多少人会认真对待这件事。随便说说, 并不打算真的去做, 这样的事情你在生活中恐怕也遇到吧。你明白我这样说的意思吧, 我说的有没有打动你? 有哇, 那好, 我们继续。 重新审视Ant我们现在已经来到了月亮背光的那一面, 先别忙着离开。再探索一下, 看看我们还能发现什么东西。闭上眼睛, 想一想2000年冬天的那个雨夜, 一个名叫James Duncan Davidson的杰出的程序员正在研究Tomcat的servlet容器。那时, 他正小心地保存好刚修改过的文件, 然后执行make。结果冒出了一大堆错误, 显然有什么东西搞错了。经过仔细检查, 他想, 难道是因为tab前面加了个空格而导致命令不能执行吗? 确实如此。老是这样, 他真的受够了。乌云背后的月亮给了他启示, 他创建了一个新的Java项目, 然后写了一个简单但是十分有用的工具, 这个工具巧妙地利用了Java属性文件中的信息来构造工程, 现在James可以写makefile的替代品, 它能起到相同的作用, 而形式更加优美, 也不用担心有makefile那样可恨的空格问题。这个工具能够自动解释属性文件, 然后采取正确的动作来编译工程。真是简单而优美。 (作者注: 我不认识James, James也不认识我, 这个故事是根据网上关于Ant历史的帖子虚构的) 使用Ant构造Tomcat之后几个月, 他越来越感到Java的属性文件不足以表达复杂的构造指令。文件需要检出, 拷贝, 编译, 发到另外一台机器, 进行单元测试。要是出错, 就发邮件给相关人员, 要是成功, 就继续在尽可能高层的卷(volumn)上执行构造。追踪到最后,卷要回复到最初的水平上。确实, Java的属性文件不够用了, James需要更有弹性的解决方案。他不想自己写解析器(因为他更希望有一个具有工业标准的方案)。XML看起来是个不错的选择。他花了几天工夫把Ant移植到XML，于是，一件伟大的工具诞生了。 Ant是怎样工作的？原理非常简单。Ant把包含有构造命令的XML文件(算代码还是算数据,你自己想吧)，交给一个Java程序来解析每一个元素，实际情况比我说的还要简单得多。一个简单的XML指令会导致具有相同名字的Java类装入，并执行其代码。123&lt;copy todir=&quot;../new/dir&quot;&gt; &lt;fileset dir=&quot;src_dir&quot; /&gt;&lt;/copy&gt; 这段文字的含义是把源目录复制到目标目录，Ant会找到一个”copy”任务(实际上就是一个Java类), 通过调用Java的方法来设置适当参数(todir和fileset)，然后执行这个任务。Ant带有一组核心类, 可以由用户任意扩展, 只要遵守若干约定就可以。Ant找到这些类,每当遇到XML元素有同样的名字, 就执行相应的代码。过程非常简单。Ant做到了我们前面所说的东西: 它是一个语言解释器, 以XML作为语法, 把XML元素转译为适当的Java指令。我们可以写一个”add”任务, 然后, 当发现XML中有add描述的时候, 就执行这个add任务。由于Ant是非常流行的项目, 前面展示的策略就显得更为明智。毕竟, 这个工具每天差不多有几千家公司在使用。 到目前为之, 我还没有说Ant在解析XML时所遇到困难。你也不用麻烦去它的网站上去找答案了, 不会找到有价值的东西。至少对我们这个论题来说是如此。我们还是继续下一步讨论吧。我们答案就在那里。 为什么是XML有时候正确的决策并非完全出于深思熟虑。我不知道James选择XML是否出于深思熟虑。也许仅仅是个下意识的决定。至少从James在Ant网站上发表的文章看起来, 他所说的理由完全是似是而非。他的主要理由是移植性和扩展性, 在Ant案例上, 我看不出这两条有什么帮助。使用XML而不是Java代码, 到底有什么好处? 为什么不写一组Java类, 提供api来满足基本任务(拷贝目录, 编译等等), 然后在Java里直接调用这些代码? 这样做仍然可以保证移植性, 扩展性也是毫无疑问的。而且语法也更为熟悉, 看着顺眼。那为什么要用 XML呢? 有什么更好的理由吗? 有的。虽然我不确定James是否确实意识到了。在语义的可构造性方面, XML的弹性是Java望尘莫及的。我不想用高深莫测的名词来吓唬你, 其中的道理相当简单, 解释起来并不费很多功夫。好, 做好预备动作, 我们马上就要朝向顿悟的时刻做奋力一跃。 上面的那个copy的例子, 用Java代码怎样实现呢? 我们可以这样做:1234567CopyTask copy = new CopyTask();Fileset fileset = new Fileset();fileset.setDir(&quot;src_dir&quot;);copy.setToDir(&quot;../new/dir&quot;);copy.setFileset(fileset);copy.excute(); 这个代码看起来和XML的那个很相似, 只是稍微长一点。差别在那里? 差别在于XML构造了一个特殊的copy动词, 如果我们硬要用Java来写的话, 应该是这个样子:1234copy(&quot;../new/dir&quot;);&#123; fileset(&quot;src_dir&quot;);&#125; 看到差别了吗? 以上代码(如果可以在Java中用的化), 是一个特殊的copy算符, 有点像for循环或者Java5中的foreach循环。如果我们有一个转换器, 可以把XML转换到Java, 大概就会得到上面这段事实上不可以执行的代码。因为Java的技术规范是定死的, 我们没有办法在程序里改变它。我们可以增加包, 增加类, 增加方法, 但是我们没办法增加算符,而对于XML, 我们显然可以任由自己增加这样的东西。对于XML的语法树来说, 只要原意,我们可以任意增加任何元素, 因此等于我们可以任意增加算符。如果你还不太明白的话,看下面这个例子, 加入我们要给Java引入一个unless算符:1234unless(someObject.canFly())&#123; someObject.transportByGround():&#125; 在上面的两个例子中, 我们打算给Java语法扩展两个算符, 成组拷贝文件算符和条件算符unless, 我们要想做到这一点, 就必须修改Java编译器能够接受的抽象语法树, 显然我们无法用Java标准的功能来实现它。但是在XML中我们可以轻而易举地做到。我们的解析器根据 XML元素, 生成抽象语法树, 由此生成算符, 所以, 我们可以任意引入任何算符。 对于复杂的算符来说, 这样做的好处显而易见。比如, 用特定的算符来做检出源码, 编译文件, 单元测试, 发送邮件等任务, 想想看有多么美妙。对于特定的题目, 比如说构造软件项目, 这些算符的使用可以大幅减低少代码的数量。增加代码的清晰程度和可重用性。解释性的XML可以很容易的达到这个目标。XML是存储层次化数据的简单数据文件, 而在Java中, 由于层次结构是定死的(你很快就会看到, Lisp的情况与此截然不同), 我们就没法达到上述目标。也许这正是Ant的成功之处呢。 你可以注意一下最近Java和C#的变化(尤其是C#3.0的技术规范), C#把常用的功能抽象出来, 作为算符增加到C#中。C#新增加的query算符就是一个例子。它用的还是传统的作法:C#的设计者修改抽象语法树, 然后增加对应的实现。如果程序员自己也能修改抽象语法树该有多好! 那样我们就可以构造用于特定问题的子语言(比如说就像Ant这种用于构造项目的语言), 你能想到别的例子吗? 再思考一下这个概念。不过也不必思考太甚, 我们待会还会回到这个题目。那时候就会更加清晰。 离Lisp越来越近我们先把算符的事情放一放, 考虑一下Ant设计局限之外的东西。我早先说过, Ant可以通过写Java类来扩展。Ant解析器会根据名字来匹配XML元素和Java类, 一旦找到匹配, 就执行相应任务。为什么不用Ant自己来扩展Ant呢? 毕竟核心任务要包含很多传统语言的结构(例如”if”), 如果Ant自身就能提供构造任务的能力(而不是依赖java类), 我们就可以得到更高的移植性。我们将会依赖一组核心任务(如果你原意, 也不妨把它称作标准库), 而不用管有没有Java 环境了。这组核心任务可以用任何方式来实现, 而其他任务建筑在这组核心任务之上, 那样的话, Ant就会成为通用的, 可扩展的, 基于XML的编程语言。考虑下面这种代码的可能性:1234&lt;task name=&quot;Test&quot;&gt; &lt;echo message=&quot;Hello World&quot; /&gt;&lt;/task&gt;&lt;Test /&gt; 如果XML支持”task”的创建, 上面这段代码就会输出”Hello World!”. 实际上, 我们可以用Java写个”task”任务, 然后用Ant-XML来扩展它。Ant可以在简单原语的基础上写出更复杂的原语, 就像其他编程语言常用的作法一样。这也就是我们一开始提到的基于XML的编程语言。这样做用处不大(你知道为甚么吗?), 但是真的很酷。 再看一回我们刚才说的Task任务。祝贺你呀, 你在看Lisp代码!!! 我说什么? 一点都不像Lisp吗? 没关系, 我们再给它收拾一下。 比XML更好前面一节说过, Ant自我扩展没什么大用, 原因在于XML很烦琐。对于数据来说, 这个问题还不太大, 但如果代码很烦琐的话, 光是打字上的麻烦就足以抵消它的好处。你写过Ant的脚本吗? 我写过, 当脚本达到一定复杂度的时候, XML非常让人厌烦。想想看吧, 为了写结束标签, 每个词都得打两遍, 不发疯算好的! 为了解决这个问题, 我们应当简化写法。须知, XML仅仅是一种表达层次化数据的方式。我们并不是一定要使用尖括号才能得到树的序列化结果。我们完全可以采用其他的格式。其中的一种(刚好就是Lisp所采用的)格式, 叫做s表达式。s表达式要做的和XML一样, 但它的好处是写法更简单, 简单的写法更适合代码输入。后面我会详细讲s表达式。这之前我要清理一下XML的东西。考虑一下关于拷贝文件的例子:123&lt;copy toDir=&quot;../new/dir&quot;&gt; &lt;fileset dir=&quot;src_dir&quot;&gt;&lt;/copy&gt; 想想看在内存里面, 这段代码的解析树在内存会是什么样子? 会有一个”copy”节点, 其下有一个 “fileset”节点, 但是属性在哪里呢? 它怎样表达呢? 如果你以前用过XML, 并且弄不清楚该用元素还是该用属性, 你不用感到孤单, 别人一样糊涂着呢。没人真的搞得清楚。这个选择与其说是基于技术的理由, 还不如说是闭着眼瞎摸。从概念上来讲, 属性也是一种元素, 任何属性能做的, 元素一样做得到。XML引入属性的理由, 其实就是为了让XML写法不那么冗长。比如我们看个例子:123456&lt;copy&gt; &lt;toDir&gt;../new/dir&lt;/toDir&gt; &lt;fileset&gt; &lt;dir&gt;src_dir&lt;/dir&gt; &lt;/fileset&gt;&lt;/copy&gt; 两下比较, 内容的信息量完全一样, 用属性可以减少打字数量。如果XML没有属性的话,光是打字就够把人搞疯掉。 说完了属性的问题, 我们再来看一看s表达式。之所以绕这么个弯, 是因为s表达式没有属性的概念。因为s表达式非常简练, 根本没有必要引入属性。我们在把XML转换成s表达式的时候, 心里应该记住这一点。看个例子, 上面的代码译成s表达式是这样的:123(copy (todir &quot;../new/dir&quot;) (fileset (dir &quot;src_dir&quot;))) 仔细看看这个例子, 差别在哪里? 尖括号改成了圆括号, 每个元素原来是有一对括号标记包围的, 现在取消了后一个(就是带斜杠的那个)括号标记。表示元素的结束只需要一个”)”就可以了。不错, 差别就是这些。这两种表达方式的转换, 非常自然, 也非常简单。s表达式打起字来, 也省事得多。第一次看s表达式(Lisp)时, 括号很烦人是吧? 现在我们明白了背后的道理, 一下子就变得容易多了。至少, 比XML要好的多。用s表达式写代码, 不单是实用, 而且也很让人愉快。s表达式具有XML的一切好处, 这些好处是我们刚刚探讨过的。现在我们看看更加Lisp风格的task例子:123(task (name &quot;Test&quot;) (echo (message &quot;Hellow World!&quot;)))(Test) 用Lisp的行话来讲, s表达式称为表(list)。对于上面的例子, 如果我们写的时候不加换行, 用逗号来代替空格, 那么这个表达式看起来就非常像一个元素列表, 其中又嵌套着其他标记。1(task, (name, &quot;test&quot;), (echo, (message, &quot;Hello World!&quot;))) XML自然也可以用这样的风格来写。当然上面这句并不是一般意义上的元素表。它实际上是一个树。这和XML的作用是一样的。称它为列表, 希望你不会感到迷惑, 因为嵌套表和树实际上是一码事。Lisp的字面意思就是表处理(list processing), 其实也可以称为树处理, 这和处理XML节点没有什么不同。 经受这一番折磨以后, 现在我们终于相当接近Lisp了, Lisp的括号的神秘本质(就像许多Lisp狂热分子认为的)逐渐显现出来。现在我们继续研究其他内容。 重新审视C语言的宏到了这里, 对XML的讨论你大概都听累了, 我都讲累了。我们先停一停, 把树, s表达式,Ant这些东西先放一放, 我们来说说C的预处理器。一定有人问了, 我们的话题和C有什么关系? 我们已经知道了很多关于元编程的事情, 也探讨过专门写代码的代码。理解这问题有一定难度, 因为相关讨论文章所使用的编程语言, 都是你们不熟悉的。但是如果只论概念的话, 就相对要简单一些。我相信, 如果以C语言做例子来讨论元编程, 理解起来一定会容易得多。好, 我们接着看。 一个问题是, 为什么要用代码来写代码呢? 在实际的编程中, 怎样做到这一点呢? 到底元编程是什么意思? 你大概已经听说过这些问题的答案, 但是并不懂得其中缘由。为了揭示背后的真理, 我们来看一下一个简单的数据库查询问题。这种题目我们都做过。比方说,直接在程序码里到处写SQL语句来修改表(table)里的数据, 写多了就非常烦人。即便用C#3.0的LINQ, 仍然不减其痛苦。写一个完整的SQL查询(尽管语法很优美)来修改某人的地址, 或者查找某人的名字, 绝对是件令程序员倍感乏味的事情, 那么我们该怎样来解决这个问题? 答案就是: 使用数据访问层。 概念挺简单, 其要点是把数据访问的内容(至少是那些比较琐碎的部分)抽象出来, 用类来映射数据库的表, 然后用访问对象属性访问器(accessor)的办法来间接实现查询。这样就极大地简化了开发工作量。我们用访问对象的方法(或者属性赋值, 这要视你选用的语言而定)来代替写SQL查询语句。凡是用过这种方法的人, 都知道这很节省时间。当然, 如果你要亲自写这样一个抽象层, 那可是要花非常多的时间的–你要写一组类来映射表, 把属性访问转换为SQL查询, 这个活相当耗费精力。用手工来做显然是很不明智的。但是一旦你有了方案和模板, 实际上就没有多少东西需要思考的。你只需要按照同样的模板一次又一次重复编写相似代码就可以了。事实上很多人已经发现了更好的方法, 有一些工具可以帮助你连接数据库, 抓取数据库结构定义(schema), 按照预定义的或者用户定制的模板来自动编写代码。 如果你用过这种工具, 你肯定会对它的神奇效果深为折服。往往只需要鼠标点击数次, 就可以连接到数据库, 产生数据访问源码, 然后把文件加入到你的工程里面, 十几分钟的工作, 按照往常手工方式来作的话, 也许需要数百个小时人工(man-hours)才能完成。可是,如果你的数据库结构定义后来改变了怎么办? 那样的话, 你只需把这个过程重复一遍就可以了。甚至有一些工具能自动完成这项变动工作。你只要把它作为工程构造的一部分, 每次编译工程的时候, 数据库部分也会自动地重新构造。这真的太棒了。你要做的事情基本上减到了0。如果数据库结构定义发生了改变, 并在编译时自动更新了数据访问层的代码,那么程序中任何使用过时的旧代码的地方, 都会引发编译错误。 数据访问层是个很好的例子, 这样的例子还有好多。从GUI样板代码, WEB代码, COM和CORBA存根, 以及MFC和ATL等等。在这些地方, 都是有好多相似代码多次重复。既然这些代码有可能自动编写, 而程序员时间又远远比CPU时间昂贵, 当然就产生了好多工具来自动生成样板代码。这些工具的本质是什么呢? 它们实际上就是制造程序的程序。它们有一个神秘的名字, 叫做元编程。所谓元编程的本义, 就是如此。 元编程本来可以用到无数多的地方, 但实际上使用的次数却没有那么多。归根结底, 我们心里还是在盘算, 假设重复代码用拷贝粘贴的话, 大概要重复6,7次, 对于这样的工作量,值得专门建立一套生成工具吗? 当然不值得。数据访问层和COM存根往往需要重用数百次,甚至上千次, 所以用工具生成是最好的办法。而那些仅仅是重复几次十几次的代码, 是没有必要专门做工具的。不必要的时候也去开发代码生成工具, 那就显然过度估计了代码生成的好处。当然, 如果创建这类工具足够简单的话, 还是应当尽量多用, 因为这样做必然会节省时间。现在来看一下有没有合理的办法来达到这个目的。 现在, C预处理器要派上用场了。我们都用过C/C++的预处理器, 我们用它执行简单的编译指令, 来产生简单的代码变换(比方说, 设置调试代码开关), 看一个例子:1#define triple(X) X+X+X 这一行的作用是什么? 这是一个简单的预编译指令, 它把程序中的triple(X)替换称为X+X+X。例如, 把所有triple(5)都换成5+5+5, 然后再交给编译器编译。这就是一个简单的代码生成的例子。要是C的预处理器再强大一点, 要是能够允许连接数据库, 要是能多一些其他简单的机制, 我们就可以在我们程序的内部开发自己的数据访问层。下面这个例子, 是一个假想的对C宏的扩展:1234567#get-db-schema(&quot;127.0.0.1&quot;)V#iterate-through-tables#for-each-table class #table-name &#123; &#125;;#end-for-each 我们连接数据库结构定义, 遍历数据表, 然后对每个表创建一个类, 只消几行代码就完成了这个工作。这样每次编译工程的时候, 这些类都会根据数据库的定义同步更新。显而易见, 我们不费吹灰之力就在程序内部建立了一个完整的数据访问层, 根本用不着任何外部工具。当然这种作法有一个缺点, 那就是我们得学习一套新的”编译时语言”, 另一个缺点就是根本不存在这么一个高级版的C预处理器。需要做复杂代码生成的时候, 这个语言(译者注: 这里指预处理指令, 即作者所说的”编译时语言”)本身也一定会变得相当复杂。它必须支持足够多的库和语言结构。比如说我们想要生成的代码要依赖某些ftp服务器上的文件, 预处理器就得支持ftp访问, 仅仅因为这个任务而不得不创造和学习一门新的语言,真是有点让人恶心(事实上已经存在着有此能力的语言, 这样做就更显荒谬)。我们不妨再灵活一点, 为什么不直接用 C/C++自己作为自己的预处理语言呢? 这样子的话, 我们可以发挥语言的强大能力, 要学的新东西也只不过是几个简单的指示字 , 这些指示字用来区别编译时代码和运行时代码。12345678&lt;% cout&lt;&lt;&quot;Enter a number: &quot;; cin&gt;&gt;n;%&gt;for(int i=0;i&lt; &lt;% n %&gt;;i++)&#123; cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;&#125; 你明白了吗? 在&lt;%和%&gt;标记之间的代码是在编译时运行的, 标记之外的其他代码都是普通代码。编译程序时, 系统会提示你输入一个数, 这个数在后面的循环中会用到。而for循环的代码会被编译。假定你在编译时输入5, for循环的代码将会是:1234for(int i=0;i&lt;5; i++)&#123; cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;&#125; 又简单又有效率, 也不需要另外的预处理语言。我们可以在编译时就充分发挥宿主语言(此处是C/C++)的强大能力, 我们可以很容易地在编译时连接数据库, 建立数据访问层, 就像JSP或者ASP创建网页那样。我们也用不着专门的窗口工具来另外建立工程。我们可以在代码中立即加入必要的工具。我们也用不着顾虑建立这种工具是不是值得, 因为这太容易了, 太简单了。这样子不知可以节省多少时间啊。 你好, Lisp到此刻为止, 我们所知的关于Lisp的指示可以总结为一句话: Lisp是一个可执行的语法更优美的XML, 但我们还没有说Lisp是怎样做到这一点的, 现在开始补上这个话题。 Lisp有丰富的内置数据类型, 其中的整数和字符串和其他语言没什么分别。像71或者”hello”这样的值, 含义也和C++或者Java这样的语言大体相同。真正有意思的三种类型是符号(symbol), 表和函数。这一章的剩余部分, 我都会用来介绍这几种类型, 还要介绍Lisp环境是怎样编译和运行源码的。这个过程用Lisp的术语来说通常叫做求值。通读这一节内容, 对于透彻理解元编程的真正潜力, 以及代码和数据的同一性, 和面向领域语言的观念, 都极其重要。万勿等闲视之。我会尽量讲得生动有趣一些, 也希望你能获得一些启发。那好, 我们先讲符号。 大体上, 符号相当于C++或Java语言中的标志符, 它的名字可以用来访问变量值(例如currentTime, arrayCount, n, 等等), 差别在于, Lisp中的符号更加基本。在C++或Java里面, 变量名只能用字母和下划线的组合, 而Lisp的符号则非常有包容性, 比如, 加号(+)就是一个合法的符号, 其他的像-, =, hello-world, *等等都可以是符号名。符号名的命名规则可以在网上查到。你可以给这些符号任意赋值, 我们这里先用伪码来说明这一点。假定函数set是给变量赋值(就像等号=在C++和Java里的作用), 下面是我们的例子:12345set(test, 5) // 符号test的值为5set(=, 5) // 符号=的值为5set(test, &quot;hello&quot;) // 符号test的值为字符串&quot;hello&quot;set(test, =) // 此时符号=的值为5, 所以test的也为5set(*, &quot;hello&quot;) // 符号*的值为&quot;hello&quot; 好像有什么不对的地方? 假定我们对赋给整数或者字符串值, 那做乘法时怎么办? 不管怎么说, 总是乘法呀? 答案简单极了。Lisp中函数的角色十分特殊, 函数也是一种数据类型, 就像整数和字符串一样, 因此可以把它赋值给符号。乘法函数Lisp的内置函数, 默认赋给, 你可以把其他函数赋值给, 那样*就不代表乘法了。你也可以把这函数的值存到另外的变量里。我们再用伪码来说明一下:1234567*(3,4) // 3乘4, 结果是12set(temp, *) // 把*的值, 也就是乘法函数, 赋值给tempset(*, 3) // 把3赋予**(3,4) // 错误的表达式, *不再是乘法, 而是数值3temp(3,4) // temp是乘法函数, 所以此表达式的值为3乘4等于12set(*, temp) // 再次把乘法函数赋予**(3,4) // 3乘4等于12 再古怪一点, 把减号的值赋给加号:12set(+, -) // 减号(-)是内置的减法函数+(5, 4) // 加号(+)现在是代表减法函数, 结果是5减4等于1 这只是举例子, 我还没有详细讲函数。Lisp中的函数是一种数据类型, 和整数, 字符串,符号等等一样。一个函数并不必然有一个名字, 这和C++或者Java语言的情形很不相同。在这里函数自己代表自己。事实上它是一个指向代码块的指针, 附带有一些其他信息(例如一组参数变量)。只有在把函数赋予其他符号时, 它才具有了名字, 就像把一个数值或字符串赋予变量一样的道理。你可以用一个内置的专门用于创建函数的函数来创建函数,然后把它赋值给符号fn, 用伪码来表示就是:1234fn [a]&#123; return *(a, 2);&#125; 这段代码返回一个具有一个参数的函数, 函数的功能是计算参数乘2的结果。这个函数还没有名字, 你可以把此函数赋值给别的符号:1set(times-two, fn [a] &#123;return *(a, 2)&#125;) 我们现在可以这样调用这个函数:1time-two(5) // 返回10 我们先跳过符号和函数, 讲一讲表。什么是表? 你也许已经听过好多相关的说法。表, 一言以蔽之, 就是把类似XML那样的数据块, 用s表达式来表示。表用一对括号括住, 表中元素以空格分隔, 表可以嵌套。例如(这回我们用真正的Lisp语法, 注意用分号表示注释):123456() ; 空表(1) ; 含一个元素的表(1 &quot;test&quot;) ; 两元素表, 一个元素是整数1, 另一个是字符串(test &quot;hello&quot;) ; 两元素表, 一个元素是符号, 另一个是字符串(test (1 2) &quot;hello&quot;) ; 三元素表, 一个符号test, 一个含有两个元素1和2的 ; 表, 最后一个元素是字符串 当Lisp系统遇到这样的表时, 它所做的, 和Ant处理XML数据所做的, 非常相似, 那就是试图执行它们。其实, Lisp源码就是特定的一种表, 好比Ant源码是一种特定的XML一样。Lisp执行表的顺序是这样的, 表的第一个元素当作函数, 其他元素当作函数的参数。如果其中某个参数也是表, 那就按照同样的原则对这个表求值, 结果再传递给最初的函数作为参数。这就是基本原则。我们看一下真正的代码:12345678(* 3 4) ; 相当于前面列举过的伪码*(3,4), 即计算3乘4(times-two 5) ; 返回10, times-two按照前面的定义是求参数的2倍(3 4) ; 错误, 3不是函数(time-two) ; 错误, times-two要求一个参数(times-two 3 4) ; 错误, times-two只要求一个参数(set + -) ; 把减法函数赋予符号+(+ 5 4) ; 依据上一句的结果, 此时+表示减法, 所以返回1(* 3 (+ 2 2)) ; 2+2的结果是4, 再乘3, 结果是12 上述的例子中, 所有的表都是当作代码来处理的。怎样把表当作数据来处理呢? 同样的,设想一下, Ant是把XML数据当作自己的参数。在Lisp中, 我们给表加一个前缀’来表示数据。123(set test &apos;(1 2)) ; test的值为两元素表(set test (1 2)) ; 错误, 1不是函数(set test &apos;(* 3 4)) ; test的值是三元素表, 三个元素分别是*, 3, 4 我们可以用一个内置的函数head来返回表的第一个元素, tail函数来返回剩余元素组成的表。1234(head &apos;(* 3 4)) ; 返回符号*(tail &apos;(* 3 4)) ; 返回表(3 4)(head (tal &apos;(* 3 4))) ; 返回3(head test) ; 返回* 你可以把Lisp的内置函数想像成Ant的任务。差别在于, 我们不用在另外的语言中扩展Lisp(虽然完全可以做得到), 我们可以用Lisp自己来扩展自己, 就像上面举的times-two函数的例子。Lisp的内置函数集十分精简, 只包含了十分必要的部分。剩下的函数都是作为标准库来实现的。 Lisp宏我们已经看到, 元编程在一个类似jsp的模板引擎方面的应用。我们通过简单的字符串处理来生成代码。但是我们可以做的更好。我们先提一个问题, 怎样写一个工具, 通过查找目录结构中的源文件来自动生成Ant脚本。 用字符串处理的方式生成Ant脚本是一种简单的方式。当然, 还有一种更加抽象, 表达能力更强, 扩展性更好的方式, 就是利用XML库在内存中直接生成XML节点, 这样的话内存中的节点就可以自动序列化成为字符串。不仅如此, 我们的工具还可以分析这些节点, 对已有的XML文件做变换。通过直接处理XML节点。我们可以超越字符串处理, 使用更高层次的概念, 因此我们的工作就会做的更快更好。 我们当然可以直接用Ant自身来处理XML变换和制作代码生成工具。或者我们也可以用Lisp来做这项工作。正像我们以前所知的, 表是Lisp内置的数据结构, Lisp含有大量的工具来快速有效的操作表(head和tail是最简单的两个)。而且, Lisp没有语义约束, 你可以构造任何数据结构, 只要你原意。 Lisp通过宏(macro)来做元编程。我们写一组宏来把任务列表(to-do list)转换为专用领域语言。 回想一下上面to-do list的例子, 其XML的数据格式是这样的:12345&lt;todo name = &quot;housework&quot;&gt; &lt;item priority = &quot;high&quot;&gt;Clean the hose&lt;/item&gt; &lt;item priority = &quot;medium&quot;&gt;Wash the dishes&lt;/item&gt; &lt;item priority = &quot;medium&quot;&gt;Buy more soap&lt;/item&gt;&lt;/todo&gt; 相应的s表达式是这样的:1234(todo &quot;housework&quot; (item (priority high) &quot;Clean the house&quot;) (item (priority medium) &quot;Wash the dishes&quot;) (item (priority medium) &quot;Buy more soap&quot;)) 假设我们要写一个任务表的管理程序, 把任务表数据存到一组文件里, 当程序启动时, 从文件读取这些数据并显示给用户。在别的语言里(比如说Java), 这个任务该怎么做? 我们会解析XML文件, 从中得出任务表数据, 然后写代码遍历XML树, 再转换为Java的数据结构(老实讲, 在Java里解析XML真不是件轻松的事情), 最后再把数据展示给用户。现在如果用Lisp, 该怎么做? 假定要用同样思路的化, 我们大概会用Lisp库来解析XML。XML对我们来说就是一个Lisp的表(s表达式), 我们可以遍历这个表, 然后把相关数据提交给用户。可是, 既然我们用Lisp, 就根本没有必要再用XML格式保存数据, 直接用s表达式就好了, 这样就没有必要做转换了。我们也用不着专门的解析库, Lisp可以直接在内存里处理s表达式。注意, Lisp编译器和.net编译器一样, 对Lisp程序来说, 在运行时总是随时可用的。 但是还有更好的办法。我们甚至不用写表达式来存储数据, 我们可以写宏, 把数据当作代码来处理。那该怎么做呢? 真的简单。回想一下, Lisp的函数调用格式:1(function-name arg1 arg2 arg3) 其中每个参数都是s表达式, 求值以后, 传递给函数。如果我们用(+ 4 5)来代替arg1,那么, 程序会先求出结果, 就是9, 然后把9传递给函数。宏的工作方式和函数类似。主要的差别是, 宏的参数在代入时不求值。1(macro-name (+ 4 5)) 这里, (+ 4 5)作为一个表传递给宏, 然后宏就可以任意处理这个表, 当然也可以对它求值。宏的返回值是一个表, 然后有程序作为代码来执行。宏所占的位置, 就被替换为这个结果代码。我们可以定义一个宏把数据替换为任意代码, 比方说, 替换为显示数据给用户的代码。 这和元编程, 以及我们要做的任务表程序有什么关系呢? 实际上, 编译器会替我们工作,调用相应的宏。我们所要做的, 仅仅是创建一个把数据转换为适当代码的宏。 例如, 上面曾经将过的C的求三次方的宏, 用Lisp来写是这样子:12(defmacro triple (x) `(+ ~x ~x ~x)) (译注: 在Common Lisp中, 此处的单引号应当是反单引号, 意思是对表不求值, 但可以对表中某元素求值, 记号~表示对元素x求值, 这个求值记号在Common Lisp中应当是逗号。反单引号和单引号的区别是, 单引号标识的表, 其中的元素都不求值。这里作者所用的记号是自己发明的一种Lisp方言Blaise, 和common lisp略有不同, 事实上, 发明方言是lisp高手独有的乐趣, 很多狂热分子都热衷这样做。比如Paul Graham就发明了ARC, 许多记号比传统的Lisp简洁得多, 显得比较现代) 单引号的用处是禁止对表求值。每次程序中出现triple的时候,1(triple 4) 都会被替换成:1(+ 4 4 4) 我们可以为任务表程序写一个宏, 把任务数据转换为可执行码, 然后执行。假定我们的输出是在控制台:1234(defmacro item (priority note) `(block (print stdout tab &quot;Prority: &quot; ~(head (tail priority)) endl) (print stdout tab &quot;Note: &quot; ~note endl endl))) 我们创造了一个非常小的有限的语言来管理嵌在Lisp中的任务表。这个语言只用来解决特定领域的问题, 通常称之为DSLs(特定领域语言, 或专用领域语言)。 特定领域语言本文谈到了两个特定领域语言, 一个是Ant, 处理软件构造。一个是没起名字的, 用于处理任务表。两者的差别在于, Ant是用XML, XML解析器, 以及Java语言合在一起构造出来的。而我们的迷你语言则完全内嵌在Lisp中, 只消几分钟就做出来了。 我们已经说过了DSL的好处, 这也就是Ant用XML而不直接用Java的原因。如果使用Lisp,我们可以任意创建DSL, 只要我们需要。我们可以创建用于网站程序的DSL, 可以写多用户游戏, 做固定收益贸易(fixed income trade), 解决蛋白质折叠问题, 处理事务问题, 等等。我们可以把这些叠放在一起, 造出一个语言, 专门解决基于网络的贸易程序, 既有网络语言的优势, 又有贸易语言的好处。每天我们都会收获这种方法带给我们的益处, 远远超过Ant所能给予我们的。 用DSL解决问题, 做出的程序精简, 易于维护, 富有弹性。在Java里面, 我们可以用类来处理问题。这两种方法的差别在于, Lisp使我们达到了一个更高层次的抽象, 我们不再受语言解析器本身的限制, 比较一下用Java库直接写的构造脚本和用Ant写的构造脚本其间的差别。同样的, 比较一下你以前所做的工作, 你就会明白Lisp带来的好处。 接下来学习Lisp就像战争中争夺山头。尽管在电脑科学领域, Lisp已经算是一门古老的语言, 直到现在仍然很少有人真的明白该怎样给初学者讲授Lisp。尽管Lisp老手们尽了很大努力,今天新手学习Lisp仍然是困难重重。好在现在事情正在发生变化, Lisp的资源正在迅速增加, 随着时间推移, Lisp将会越来越受关注。 Lisp使人超越平庸, 走到前沿。学会Lisp意味着你能找到更好的工作, 因为聪明的雇主会被你与众不同的洞察力所打动。学会Lisp也可能意味着明天你可能会被解雇, 因为你总是强调, 如果公司所有软件都用Lisp写, 公司将会如何卓越, 而这些话你的同事会听烦的。Lisp值得努力学习吗? 那些已经学会Lisp的人都说值得, 当然, 这取决于你的判断。 你的看法呢?这篇文章写写停停, 用了几个月才最终完成。如果你觉得有趣, 或者有什么问题, 意见或建议, 请给我发邮件coffeemug@gmail.com, 我会很高兴收到你的反馈。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux下加速ThinkPad小红点]]></title>
      <url>%2F2016%2F12%2F20%2FLinux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%B0%8F%E7%BA%A2%E7%82%B9%E9%80%9F%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[Linux下加速ThinkPad小红点： 在终端下取得小红点的ID123xinput list | grep TrackPointTPPS/2 IBM TrackPoint id=14 [slave pointer (2)] 由此可知小红点的输入ID是14。 然后获得该ID的设置12345678xinput list-props 14Device &apos;TPPS/2 IBM TrackPoint&apos;: Device Enabled (137): 1 Coordinate Transformation Matrix (139): 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000 Device Accel Profile (263): 0 Device Accel Constant Deceleration (264): 1.000000 Device Accel Adaptive Deceleration (265): 1.000000 第5、6行就是关于小红点速度的设置：12Device Accel Constant Deceleration (264): 1.000000Device Accel Adaptive Deceleration (265): 1.000000 括号里的整数就是该项设置的ID，后面的小数是该项设置的参数值。ID为264（我的机器）代表的是小红点的固定阻力值(Constant Deceleration)，取值范围是 [0,1]；ID为265代表的是随力度减弱时阻力增加的速度，即小红点停下来的速度。一般来说设置第264项就够了。 设置速度1xinput set-prop 14 264 0.35 把ID为14（小红点）的设备的ID为264（阻力）设置为0.35。 shell脚本把这条命令加入到 /etc/rc.local 或者其它启动运行的命令里就好了。当然还可以写个完整的shell脚本来运行上面的一切：1234567891011#!/bin/bash# obtain TrackPoint ID from xinput listTP_ID=$(xinput list | grep TrackPoint | cut -f 2 | grep -Eo &apos;[0-9]&#123;1,&#125;&apos;)if [ -n &quot;$TP_ID&quot; ]; then # obtain properties from xinput list-props &quot;$TP_ID&quot; AS_ID=$(xinput list-props &quot;$TP_ID&quot; | grep &apos;Accel Constant Deceleration (&apos; | cut -f 2 | grep -Eo &apos;[0-9]&#123;1,&#125;&apos;) # set the speed you want xinput set-prop &quot;$TP_ID&quot; &quot;$AS_ID&quot; 0.25fi]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis获取PostgreSQL数据库插入记录的自增序列值]]></title>
      <url>%2F2016%2F12%2F01%2FMybatis%E8%8E%B7%E5%8F%96PostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E7%9A%84%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%88%97%E5%80%BC%2F</url>
      <content type="text"><![CDATA[开发过程中，经常需要获取刚刚插入的记录的自增键值。对于PostgreSQL,使用Mybatis三种方法： useGeneratedKeys参考Mybatis官方文档useGeneratedKeys（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段）. 如果自增键的名字不叫id,还需要设置一个属性keyProperty使Mybaits将获取回的结果设置到那个字段上。一般情况最好明确设置keyProperty属性。 12345&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; selectKey参考Mybatis官方文档selectKey定义一个子查询，将查询的自增键的结果赋予insert参数的相应字段。 RETURNING子句参考PostgreSQL官方文档If the INSERT command contains a RETURNING clause, the result will be similar to that of a SELECT statement containing the columns and values defined in the RETURNING list, computed over the row(s) inserted by the command.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JMS消息类型]]></title>
      <url>%2F2016%2F11%2F24%2FJMSMessageTypes%2F</url>
      <content type="text"><![CDATA[JMS消息类型 官方Message Bodies官方The JMS API defines five message body formats, also called message types, which allow you to send and to receive data in many different forms and provide compatibility with existing messaging formats. Table 30–2 describes these message types. Table 30–2 JMS Message Types Message Type Body Contains TextMessage A java.lang.String object (for example, the contents of an XML file). MapMessage A set of name-value pairs, with names as String objects and values as primitive types in the Java programming language. The entries can be accessed sequentially by enumerator or randomly by name. The order of the entries is undefined. BytesMessage A stream of uninterpreted bytes. This message type is for literally encoding a body to match an existing message format. StreamMessage A stream of primitive values in the Java programming language, filled and read sequentially. ObjectMessage A Serializable object in the Java programming language. Message Nothing. Composed of header fields and properties only. This message type is useful when a message body is not required. The JMS API provides methods for creating messages of each type and for filling in their contents. For example, to create and send a TextMessage, you might use the following statements:123TextMessage message = session.createTextMessage();message.setText(msg_text); // msg_text is a Stringproducer.send(message); At the consuming end, a message arrives as a generic Message object and must be cast to the appropriate message type. You can use one or more getter methods to extract the message contents. The following code fragment uses the getText method:1234567Message m = consumer.receive();if (m instanceof TextMessage) &#123; TextMessage message = (TextMessage) m; System.out.println(&quot;Reading message: &quot; + message.getText());&#125; else &#123; // Handle error&#125; IBM Knowledge CenterJMS message types Version:10.0.0IBM Knowledge Center JMS defines six message interface types; a base message type and five subtypes. The message types are defined according to the type of the message payload, where the payload is the body of a message that holds the content. JMS specifies only the interface and does not specify the implementation. This approach allows for vendor-specific implementation and transportation of messages while using a common interface. The following table describes the six message types: Message type Description Message The base class. This message type is used for event notification, and does not have a payload. BytesMessage The payload is stored as an array of bytes. This message type is useful for exchanging data in a format that is native to the application, and when JMS is used as a transport between two systems, where the JMS client does not know the message payload type. Use this message type to transmit XML messages to ensure that the message is transmitted efficiently, and is not subject to unnecessary data conversion. TextMessage Data is stored as a string. This message type is useful for exchanging simple text messages. StreamMessage A Stream message is a sequence of primitive Java™ types. The message object tracks the order and the types of these primitives within the stream. Formal conversion rules apply; for example, an exception is thrown if a JMS application tries to read a double value as a short value. Refer to the Java Message Service Specification version 1.1 or 2.0 for a full list of the conversion rules. 21ABCDEFGH32.345 is an example of a StreamMessage payload. It consists of the following three fields: An Integer,A String,A Float. If the data structure is unknown, the generic method readObject() can be used to return the next object in the stream. If the structure of the data is known, the JMS client can be specific about the type of object being accessed. MapMessage The payload of a MapMessage is stored as a set of name-value pairs. The name is defined as a string and the value is typed. The MapMessage is useful for delivering keyed data that can change from one message to the next.NumberOfCopies:5 is an example of a MapMessage payload, where NumberOfCopies is the key and 5 is the value.Data can be accessed by using getMapNames(), which returns a Java Enumeration object. It is possible to iterate through the MapMessage by using hasMoreElements() to retrieve the mapped name-value pairs. ObjectMessage The Object message carries a serializable Java Object as its payload. It is useful for exchanging Java objects. Last updated 2016-08-25 13:25:34]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring JMS]]></title>
      <url>%2F2016%2F11%2F24%2FSpringJMS%2F</url>
      <content type="text"><![CDATA[Spring中使用JMSSpring JMS Version:5.0.0 Introduction 简介Spring provides a JMS integration framework that simplifies the use of the JMS API much like Spring’s integration does for the JDBC API. Spring提供了一个JMS集成框架，简化了JMS API的使用，就像Spring集成JDBC API一样。 JMS can be roughly divided into two areas of functionality, namely the production and consumption of messages. The JmsTemplate class is used for message production and synchronous message reception. For asynchronous reception similar to Java EE’s message-driven bean style, Spring provides a number of message listener containers that are used to create Message-Driven POJOs (MDPs). Spring also provides a declarative way of creating message listeners. JMS可以大致分为两个功能区域，即消息的生产和消费。 JmsTemplate类用于消息生成和同步消息接收。 对于类似于Java EE的消息驱动bean样式的异步接收，Spring提供了许多用于创建消息驱动的POJO(MDP)的消息侦听容器。 Spring还提供了一种创建消息侦听器的声明式方法。 The package org.springframework.jms.core provides the core functionality for using JMS. It contains JMS template classes that simplify the use of the JMS by handling the creation and release of resources, much like the JdbcTemplate does for JDBC. The design principle common to Spring template classes is to provide helper methods to perform common operations and for more sophisticated usage, delegate the essence of the processing task to user implemented callback interfaces. The JMS template follows the same design. The classes offer various convenience methods for the sending of messages, consuming a message synchronously, and exposing the JMS session and message producer to the user. 包org.springframework.jms.core提供了使用JMS的核心功能。 它包含JMS模板类，通过处理资源的创建和释放来简化JMS的使用，类似于JdbcTemplate对JDBC的使用。 Spring模板类的通用设计原则是提供帮助方法来执行常见操作，为了更复杂的使用，将处理任务的本质委托给用户实现的回调接口。 JMS模板遵循相同的设计。 这些类提供了用于发送消息，同步消费消息以及向用户公开JMS会话和消息产生器的各种方便的方法。 The package org.springframework.jms.support provides JMSException translation functionality. The translation converts the checked JMSException hierarchy to a mirrored hierarchy of unchecked exceptions. If there are any provider specific subclasses of the checked javax.jms.JMSException, this exception is wrapped in the unchecked UncategorizedJmsException. 包org.springframework.jms.support提供JMSException翻译功能。 该转换将检查的JMSException层次结构转换为未检查异常的镜像层次结构。 如果检查的javax.jms.JMSException有任何特定于提供程序的子类，则此异常将包含在未检查的UncategorizedJmsException中。 The package org.springframework.jms.support.converter provides a MessageConverter abstraction to convert between Java objects and JMS messages. 包org.springframework.jms.support.converter提供了一个MessageConverter抽象来在Java对象和JMS消息之间进行转换。 The package org.springframework.jms.support.destination provides various strategies for managing JMS destinations, such as providing a service locator for destinations stored in JNDI. 包org.springframework.jms.support.destination提供了用于管理JMS目的地的各种策略，例如为存储在JNDI中的目的地提供服务定位符。 The package org.springframework.jms.annotation provides the necessary infrastructure to support annotation-driven listener endpoints using @JmsListener. org.springframework.jms.annotation包提供了使用@JmsListener支持注释驱动的侦听器端点的必要基础结构。 The package org.springframework.jms.config provides the parser implementation for the jms namespace as well the java config support to configure listener containers and create listener endpoints. 包org.springframework.jms.config提供了jms命名空间的解析器实现以及配置侦听器容器和创建侦听器端点的java config支持。 Finally, the package org.springframework.jms.connection provides an implementation of the ConnectionFactory suitable for use in standalone applications. It also contains an implementation of Spring’s PlatformTransactionManager for JMS (the cunningly named JmsTransactionManager). This allows for seamless integration of JMS as a transactional resource into Spring’s transaction management mechanisms. 最后，包org.springframework.jms.connection提供了适用于独立应用程序的ConnectionFactory的实现。 它还包含Spring的PlatformTransactionManager for JMS(巧妙的名称为JmsTransactionManager)的实现。 这允许将JMS作为事务资源无缝集成到Spring的事务管理机制中。 Using Spring JMSJmsTemplateThe JmsTemplate class is the central class in the JMS core package. It simplifies the use of JMS since it handles the creation and release of resources when sending or synchronously receiving messages. JmsTemplate类是JMS核心包中的中心类。它简化了JMS的使用，因为它在发送或同步接收消息时处理资源的创建和释放。 Code that uses the JmsTemplate only needs to implement callback interfaces giving them a clearly defined high level contract. The MessageCreator callback interface creates a message given a Session provided by the calling code in JmsTemplate. In order to allow for more complex usage of the JMS API, the callback SessionCallback provides the user with the JMS session and the callback ProducerCallback exposes a Session and MessageProducer pair. 使用JmsTemplate的代码只需要实现回调接口，为它们提供一个清晰定义的高级别契约。 MessageCreator回调接口创建一个消息，给出由JmsTemplate中的调用代码提供的会话。为了允许更复杂地使用JMS API，回调SessionCallback向用户提供JMS会话，而回调ProducerCallback公开一个Session和MessageProducer对。 The JMS API exposes two types of send methods, one that takes delivery mode, priority, and time-to-live as Quality of Service (QOS) parameters and one that takes no QOS parameters which uses default values. Since there are many send methods in JmsTemplate, the setting of the QOS parameters have been exposed as bean properties to avoid duplication in the number of send methods. Similarly, the timeout value for synchronous receive calls is set using the property setReceiveTimeout. JMS API公开两种类型的发送方法，一种采用交付模式，优先级和生存时间作为服务质量(QOS)参数，另一种不使用使用默认值的QOS参数。因为JmsTemplate中有很多发送方法，所以QOS参数的设置已经公开为bean属性，以避免发送方法的数量重复。类似地，同步接收调用的超时值使用属性setReceiveTimeout设置。 Some JMS providers allow the setting of default QOS values administratively through the configuration of the ConnectionFactory. This has the effect that a call to MessageProducer’s send method send(Destination destination, Message message) will use different QOS default values than those specified in the JMS specification. In order to provide consistent management of QOS values, the JmsTemplate must therefore be specifically enabled to use its own QOS values by setting the boolean property isExplicitQosEnabled to true. 某些JMS提供程序允许通过配置ConnectionFactory来管理性地设置默认QOS值。这具有的效果是，调用MessageProducer的发送方法send(Destination destination，Message message)将使用不同于JMS规范中指定的QOS默认值。为了提供一致的QOS值管理，因此必须通过将布尔属性isExplicitQosEnabled设置为true来专门启用JmsTemplate以使用自己的QOS值。 For convenience, JmsTemplate also exposes a basic request-reply operation that allows to send a message and wait for a reply on a temporary queue that is created as part of the operation. 为了方便起见，JmsTemplate还公开了一个基本的请求 - 回复操作，它允许发送消息并等待在作为操作的一部分创建的临时队列上的回复。 Instances of the JmsTemplate class are thread-safe once configured. This is important because it means that you can configure a single instance of a JmsTemplate and then safely inject this shared reference into multiple collaborators. To be clear, the JmsTemplate is stateful, in that it maintains a reference to a ConnectionFactory, but this state is not conversational state. JmsTemplate类的实例在配置后是线程安全的。 这很重要，因为这意味着您可以配置JmsTemplate的单个实例，然后将此共享引用安全地注入多个协作者。 要清楚，JmsTemplate是有状态的，因为它维护对ConnectionFactory的引用，但是这个状态不是会话状态。 As of Spring Framework 4.1, JmsMessagingTemplate is built on top of JmsTemplate and provides an integration with the messaging abstraction, i.e. org.springframework.messaging.Message. This allows you to create the message to send in generic manner. 从Spring Framework 4.1开始，JmsMessagingTemplate构建在JmsTemplate之上，并提供与消息抽象的集成，即org.springframework.messaging.Message。 这允许您以通用方式创建要发送的消息。 ConnectionsThe JmsTemplate requires a reference to a ConnectionFactory. The ConnectionFactory is part of the JMS specification and serves as the entry point for working with JMS. It is used by the client application as a factory to create connections with the JMS provider and encapsulates various configuration parameters, many of which are vendor specific such as SSL configuration options. JmsTemplate需要对ConnectionFactory的引用。 ConnectionFactory是JMS规范的一部分，用作处理JMS的入口点。 它由客户端应用程序用作工厂来创建与JMS提供程序的连接，并封装各种配置参数，其中许多是供应商特定的，例如SSL配置选项。 When using JMS inside an EJB, the vendor provides implementations of the JMS interfaces so that they can participate in declarative transaction management and perform pooling of connections and sessions. In order to use this implementation, Java EE containers typically require that you declare a JMS connection factory as a resource-ref inside the EJB or servlet deployment descriptors. To ensure the use of these features with the JmsTemplate inside an EJB, the client application should ensure that it references the managed implementation of the ConnectionFactory. 当在EJB中使用JMS时，供应商提供JMS接口的实现，以便它们可以参与声明性事务管理并执行连接和会话的池。 为了使用这个实现，Java EE容器通常需要将一个JMS连接工厂声明为EJB或servlet部署描述符中的resource-ref。 要确保在EJB中使用JmsTemplate的这些功能，客户端应用程序应确保它引用ConnectionFactory的托管实现。 Caching Messaging ResourcesThe standard API involves creating many intermediate objects. To send a message the following ‘API’ walk is performed 标准API涉及创建许多中间对象。 要发送消息，将执行以下’API’步行 ConnectionFactory-&gt;Connection-&gt;Session-&gt;MessageProducer-&gt;send Between the ConnectionFactory and the Send operation there are three intermediate objects that are created and destroyed. To optimise the resource usage and increase performance two implementations of ConnectionFactory are provided. 在ConnectionFactory和发送操作之间，有三个中间对象被创建和销毁。 为了优化资源使用和提高性能，提供了ConnectionFactory的两个实现。 SingleConnectionFactorySpring provides an implementation of the ConnectionFactory interface, SingleConnectionFactory, that will return the same Connection on all createConnection() calls and ignore calls to close(). This is useful for testing and standalone environments so that the same connection can be used for multiple JmsTemplate calls that may span any number of transactions. SingleConnectionFactory takes a reference to a standard ConnectionFactory that would typically come from JNDI. Spring提供了ConnectionFactory接口的一个实现，SingleConnectionFactory，将在所有createConnection()调用上返回相同的Connection，并忽略对close()的调用。这对于测试和独立环境非常有用，因此，同一连接可用于可能跨越任何数量事务的多个JmsTemplate调用。 SingleConnectionFactory采用对通常来自JNDI的标准ConnectionFactory的引用。 CachingConnectionFactoryThe CachingConnectionFactory extends the functionality of SingleConnectionFactory and adds the caching of Sessions, MessageProducers, and MessageConsumers. The initial cache size is set to 1, use the property sessionCacheSize to increase the number of cached sessions. Note that the number of actual cached sessions will be more than that number as sessions are cached based on their acknowledgment mode, so there can be up to 4 cached session instances when sessionCacheSize is set to one, one for each acknowledgment mode. MessageProducers and MessageConsumers are cached within their owning session and also take into account the unique properties of the producers and consumers when caching. MessageProducers are cached based on their destination. MessageConsumers are cached based on a key composed of the destination, selector, noLocal delivery flag, and the durable subscription name (if creating durable consumers). CachingConnectionFactory扩展了SingleConnectionFactory的功能，并添加了Sessions，MessageProducers和MessageConsumers的缓存。初始高速缓存大小设置为1，使用属性sessionCacheSize增加高速缓存的会话数。请注意，实际缓存会话的数量将大于该数量，因为根据其确认模式缓存会话，因此当sessionCacheSize设置为1时，可以有多达4个缓存会话实例，每个确认模式一个。 MessageProducers和MessageConsum在其拥有的会话中进行缓存，并在缓存时考虑生产者和消费者的独特属性。 MessageProducer根据其目标进行缓存。 MessageConsum基于由目标，选择器，noLocal传递标志和持久预订名称(如果创建持久消费者)组成的密钥进行缓存。 Destination ManagementDestinations, like ConnectionFactories, are JMS administered objects that can be stored and retrieved in JNDI. When configuring a Spring application context you can use the JNDI factory class JndiObjectFactoryBean / to perform dependency injection on your object’s references to JMS destinations. However, often this strategy is cumbersome if there are a large number of destinations in the application or if there are advanced destination management features unique to the JMS provider. Examples of such advanced destination management would be the creation of dynamic destinations or support for a hierarchical namespace of destinations. The JmsTemplate delegates the resolution of a destination name to a JMS destination object to an implementation of the interface DestinationResolver. DynamicDestinationResolver is the default implementation used by JmsTemplate and accommodates resolving dynamic destinations. A JndiDestinationResolver is also provided that acts as a service locator for destinations contained in JNDI and optionally falls back to the behavior contained in DynamicDestinationResolver. 目标，如ConnectionFactories，是JMS管理的对象，可以在JNDI中存储和检索。在配置Spring应用程序上下文时，可以使用JNDI工厂类JndiObjectFactoryBean / 对对象对JMS目标的引用执行依赖注入。但是，如果应用程序中有大量目标，或者如果有对JMS提供程序独有的高级目标管理功能，则此策略通常很麻烦。这种高级目的地管理的示例是创建动态目的地或者支持目的地的分层命名空间。 JmsTemplate将目标名称的解析委派给JMS目标对象到接口DestinationResolver的实现。 DynamicDestinationResolver是JmsTemplate使用的默认实现，适合解析动态目标。还提供JndiDestinationResolver，其作为用于包含在JNDI中的目的地的服务定位器，并且可选地回退到包含在DynamicDestinationResolver中的行为。 Quite often the destinations used in a JMS application are only known at runtime and therefore cannot be administratively created when the application is deployed. This is often because there is shared application logic between interacting system components that create destinations at runtime according to a well-known naming convention. Even though the creation of dynamic destinations is not part of the JMS specification, most vendors have provided this functionality. Dynamic destinations are created with a name defined by the user which differentiates them from temporary destinations and are often not registered in JNDI. The API used to create dynamic destinations varies from provider to provider since the properties associated with the destination are vendor specific. However, a simple implementation choice that is sometimes made by vendors is to disregard the warnings in the JMS specification and to use the TopicSession method createTopic(String topicName) or the QueueSession method createQueue(String queueName) to create a new destination with default destination properties. Depending on the vendor implementation, DynamicDestinationResolver may then also create a physical destination instead of only resolving one. 通常，JMS应用程序中使用的目标仅在运行时知道，因此在部署应用程序时无法在管理上创建。这通常是因为在根据公知的命名约定在运行时创建目的地的交互系统组件之间存在共享的应用逻辑。即使创建动态目标不是JMS规范的一部分，大多数供应商也提供了这一功能。动态目标是使用用户定义的名称创建的，它将它们与临时目标区分开来，并且通常不会在JNDI中注册。用于创建动态目标的API因供应商而异，因为与目标相关联的属性是供应商特定的。然而，有时供应商做出的一个简单的实现选择是忽略JMS规范中的警告，并使用TopicSession方法createTopic(String topicName)或QueueSession方法createQueue(String queueName)来创建具有默认目标属性的新目标。根据供应商实现，DynamicDestinationResolver可以创建物理目的地，而不是只解析一个。 The boolean property pubSubDomain is used to configure the JmsTemplate with knowledge of what JMS domain is being used. By default the value of this property is false, indicating that the point-to-point domain, Queues, will be used. This property used by JmsTemplate determines the behavior of dynamic destination resolution via implementations of the DestinationResolver interface. 布尔属性pubSubDomain用于配置JmsTemplate知道正在使用的JMS域。默认情况下，此属性的值为false，表示将使用点对点域(Queues)。 JmsTemplate使用的此属性通过DestinationResolver接口的实现来确定动态目标解析的行为。 You can also configure the JmsTemplate with a default destination via the property defaultDestination. The default destination will be used with send and receive operations that do not refer to a specific destination. 您还可以通过属性defaultDestination为默认目标配置JmsTemplate。默认目标将用于不指向特定目标的发送和接收操作。 Message Listener ContainersOne of the most common uses of JMS messages in the EJB world is to drive message-driven beans (MDBs). Spring offers a solution to create message-driven POJOs (MDPs) in a way that does not tie a user to an EJB container. (See Section 30.4.2, “Asynchronous Reception - Message-Driven POJOs” for detailed coverage of Spring’s MDP support.) As from Spring Framework 4.1, endpoint methods can be simply annotated using @JmsListener see Section 30.6, “Annotation-driven listener endpoints” for more details. 在EJB世界中JMS消息最常见的用途之一是驱动消息驱动的bean(MDB)。 Spring提供了一种解决方案，以不将用户绑定到EJB容器的方式创建消息驱动的POJO(MDP)。 (参见第30.4.2节“异步接收 - 消息驱动的POJO”，了解Spring的MDP支持的详细信息。)从Spring Framework 4.1开始，可以使用@JmsListener简单地注释端点方法，请参见第30.6节“注释驱动的侦听器端点“ 更多细节。 A message listener container is used to receive messages from a JMS message queue and drive the MessageListener that is injected into it. The listener container is responsible for all threading of message reception and dispatches into the listener for processing. A message listener container is the intermediary between an MDP and a messaging provider, and takes care of registering to receive messages, participating in transactions, resource acquisition and release, exception conversion and suchlike. This allows you as an application developer to write the (possibly complex) business logic associated with receiving a message (and possibly responding to it), and delegates boilerplate JMS infrastructure concerns to the framework. 消息侦听器容器用于从JMS消息队列接收消息，并驱动注入到其中的MessageListener。侦听器容器负责消息接收和分派到侦听器中的所有线程的处理。消息侦听器容器是MDP和消息传递提供者之间的中介，并且负责注册以接收消息，参与事务，资源获取和释放，异常转换等。这允许您作为应用程序开发人员编写与接收消息(可能响应消息)相关联的(可能是复杂的)业务逻辑，并将模板JMS基础结构问题委托给框架。 There are two standard JMS message listener containers packaged with Spring, each with its specialised feature set. 有两个使用Spring打包的标准JMS消息侦听器容器，每个都有其专门的功能集。 SimpleMessageListenerContainerThis message listener container is the simpler of the two standard flavors. It creates a fixed number of JMS sessions and consumers at startup, registers the listener using the standard JMS MessageConsumer.setMessageListener() method, and leaves it up the JMS provider to perform listener callbacks. This variant does not allow for dynamic adaption to runtime demands or for participation in externally managed transactions. Compatibility-wise, it stays very close to the spirit of the standalone JMS specification - but is generally not compatible with Java EE’s JMS restrictions. 这个消息监听器容器是两个标准中较简单的。 它在启动时创建固定数量的JMS会话和消费者，使用标准的JMS MessageConsumer.setMessageListener()方法注册侦听器，并将它留给JMS提供程序执行侦听器回调。 此变体不允许动态适应运行时需求或参与外部管理事务。 兼容性，它保持非常接近独立的JMS规范的精神 - 但是通常不与Java EE的JMS限制兼容。 While SimpleMessageListenerContainer does not allow for the participation in externally managed transactions, it does support native JMS transactions: simply switch the ‘sessionTransacted’ flag to ‘true’ or, in the namespace, set the ‘acknowledge’ attribute to ‘transacted’: Exceptions thrown from your listener will lead to a rollback then, with the message getting redelivered. Alternatively, consider using ‘CLIENT_ACKNOWLEDGE’ mode which provides redelivery in case of an exception as well but does not use transacted Sessions and therefore does not include any other Session operations (such as sending response messages) in the transaction protocol. 虽然SimpleMessageListenerContainer不允许参与外部管理事务，但它支持本地JMS事务：只需将“sessionTransacted”标志切换为“true”，或者在命名空间中将“acknowledge”属性设置为“transacted”：抛出异常 从您的侦听器将导致回滚，然后，消息重新提交。 或者，考虑使用“CLIENT_ACKNOWLEDGE”模式，该模式在异常情况下也提供重新传递，但不使用事务会话，因此不在事务协议中包括任何其他会话操作(例如发送响应消息)。 DefaultMessageListenerContainerThis message listener container is the one used in most cases. In contrast to SimpleMessageListenerContainer, this container variant allows for dynamic adaptation to runtime demands and is able to participate in externally managed transactions. Each received message is registered with an XA transaction when configured with a JtaTransactionManager; so processing may take advantage of XA transaction semantics. This listener container strikes a good balance between low requirements on the JMS provider, advanced functionality such as the participation in externally managed transactions, and compatibility with Java EE environments. 此消息侦听器容器是大多数情况下使用的容器。与SimpleMessageListenerContainer相反，此容器变体允许动态适应运行时需求，并能够参与外部管理事务。当配置有JtaTransactionManager时，每个接收的消息都用XA事务注册;因此处理可以利用XA事务语义。此侦听器容器在JMS提供程序的低要求，高级功能(如参与外部管理事务)和与Java EE环境的兼容性之间达到很好的平衡。 The cache level of the container can be customized. Note that when no caching is enabled, a new connection and a new session is created for each message reception. Combining this with a non durable subscription with high loads may lead to message lost. Make sure to use a proper cache level in such case. 可以定制容器的高速缓存级别。注意，当没有启用缓存时，为每个消息接收创建新连接和新会话。将此与具有高负载的非持久订阅相结合可能导致消息丢失。在这种情况下，请确保使用适当的缓存级别。 This container also has recoverable capabilities when the broker goes down. By default, a simple BackOff implementation retries every 5 seconds. It is possible to specify a custom BackOff implementation for more fine-grained recovery options, see ExponentialBackOff for an example. 当代理停机时，此容器还具有可恢复功能。默认情况下，简单的BackOff实现每5秒重试一次。可以为更细粒度的恢复选项指定自定义BackOff实现，请参见ExponentialBackOff示例。 Like its sibling SimpleMessageListenerContainer, DefaultMessageListenerContainer supports native JMS transactions and also allows for customizing the acknowledgment mode. This is strongly recommended over externally managed transactions if feasible for your scenario: that is, if you can live with occasional duplicate messages in case of the JVM dying. Custom duplicate message detection steps in your business logic may cover such situations, e.g. in the form of a business entity existence check or a protocol table check. Any such arrangements will be significantly more efficient than the alternative: wrapping your entire processing with an XA transaction (through configuring your DefaultMessageListenerContainer with an JtaTransactionManager), covering the reception of the JMS message as well as the execution of the business logic in your message listener (including database operations etc). 像它的同级SimpleMessageListenerContainer一样，DefaultMessageListenerContainer支持本地JMS事务，并且还允许定制确认模式。 强烈建议对于外部管理的事务，如果可行的情况下：这是，如果你可以生活偶尔的重复消息的情况下JVM死亡。 您的业务逻辑中的自定义重复邮件检测步骤可能会涉及此类情况，例如 以业务实体存在检查或协议表检查的形式。 任何这样的安排将明显比替代方案更有效率：使用XA事务封装整个处理(通过使用JtaTransactionManager配置DefaultMessageListenerContainer)，覆盖JMS消息的接收以及在消息侦听器中执行业务逻辑 (包括数据库操作等)。 Transaction managementSpring provides a JmsTransactionManager that manages transactions for a single JMS ConnectionFactory. This allows JMS applications to leverage the managed transaction features of Spring as described in Chapter 17, Transaction Management. The JmsTransactionManager performs local resource transactions, binding a JMS Connection/Session pair from the specified ConnectionFactory to the thread. JmsTemplate automatically detects such transactional resources and operates on them accordingly. Spring提供了一个JmsTransactionManager，用于管理单个JMS ConnectionFactory的事务。这允许JMS应用程序利用Spring的托管事务功能，如第17章“事务管理”中所述。 JmsTransactionManager执行本地资源事务，将来自指定的ConnectionFactory的JMS连接/会话对绑定到线程。 JmsTemplate会自动检测这种事务资源并相应地对其进行操作。 In a Java EE environment, the ConnectionFactory will pool Connections and Sessions, so those resources are efficiently reused across transactions. In a standalone environment, using Spring’s SingleConnectionFactory will result in a shared JMS Connection, with each transaction having its own independent Session. Alternatively, consider the use of a provider-specific pooling adapter such as ActiveMQ’s PooledConnectionFactory class. 在Java EE环境中，ConnectionFactory将缓冲连接和会话，因此这些资源在事务之间有效地重用。在独立环境中，使用Spring的SingleConnectionFactory将导致共享JMS连接，每个事务都有自己的独立会话。或者，考虑使用特定于提供程序的池适配器，例如ActiveMQ的PooledConnectionFactory类。 JmsTemplate can also be used with the JtaTransactionManager and an XA-capable JMS ConnectionFactory for performing distributed transactions. Note that this requires the use of a JTA transaction manager as well as a properly XA-configured ConnectionFactory! (Check your Java EE server’s / JMS provider’s documentation.) JmsTemplate也可以与JtaTransactionManager和一个支持XA的JMS ConnectionFactory一起使用，用于执行分布式事务。注意，这需要使用JTA事务管理器以及正确的XA配置的ConnectionFactory！ (检查Java EE服务器的/ JMS提供程序的文档。) Reusing code across a managed and unmanaged transactional environment can be confusing when using the JMS API to create a Session from a Connection. This is because the JMS API has only one factory method to create a Session and it requires values for the transaction and acknowledgment modes. In a managed environment, setting these values is the responsibility of the environment’s transactional infrastructure, so these values are ignored by the vendor’s wrapper to the JMS Connection. When using the JmsTemplate in an unmanaged environment you can specify these values through the use of the properties sessionTransacted and sessionAcknowledgeMode. When using a PlatformTransactionManager with JmsTemplate, the template will always be given a transactional JMS Session. 在使用JMS API从连接创建会话时，跨托管和非托管事务环境重用代码可能会引起混淆。这是因为JMS API只有一个工厂方法来创建会话，并且它需要事务和确认模式的值。在托管环境中，设置这些值是环境事务基础结构的责任，因此供应商的JMS连接包装器将忽略这些值。在非托管环境中使用JmsTemplate时，可以通过使用属性sessionTransacted和sessionAcknowledgeMode来指定这些值。当使用带有JmsTemplate的PlatformTransactionManager时，模板将始终被赋予事务性JMS会话。 Sending a MessageThe JmsTemplate contains many convenience methods to send a message. There are send methods that specify the destination using a javax.jms.Destination object and those that specify the destination using a string for use in a JNDI lookup. The send method that takes no destination argument uses the default destination. JmsTemplate包含许多方便的方法来发送消息。 有一些发送方法使用javax.jms.Destination对象指定目标，使用字符串指定目标的方法用于JNDI查找。 不带目标参数的send方法使用默认目标。123456789101112131415161718192021222324252627282930import javax.jms.ConnectionFactory;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Queue;import javax.jms.Session;import org.springframework.jms.core.MessageCreator;import org.springframework.jms.core.JmsTemplate;public class JmsQueueSender &#123; private JmsTemplate jmsTemplate; private Queue queue; public void setConnectionFactory(ConnectionFactory cf) &#123; this.jmsTemplate = new JmsTemplate(cf); &#125; public void setQueue(Queue queue) &#123; this.queue = queue; &#125; public void simpleSend() &#123; this.jmsTemplate.send(this.queue, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(&quot;hello queue world&quot;); &#125; &#125;); &#125;&#125; This example uses the MessageCreator callback to create a text message from the supplied Session object. The JmsTemplate is constructed by passing a reference to a ConnectionFactory. As an alternative, a zero argument constructor and connectionFactory is provided and can be used for constructing the instance in JavaBean style (using a BeanFactory or plain Java code). Alternatively, consider deriving from Spring’s JmsGatewaySupport convenience base class, which provides pre-built bean properties for JMS configuration. 此示例使用MessageCreator回调从提供的Session对象创建文本消息。 JmsTemplate是通过传递对ConnectionFactory的引用构造的。 作为替代，提供零参数构造函数和connectionFactory，并且可以用于以JavaBean风格构建实例(使用BeanFactory或纯Java代码)。 或者，考虑从Spring的JmsGatewaySupport方便基类派生，它为JMS配置提供了预构建的bean属性。 The method send(String destinationName, MessageCreator creator) lets you send a message using the string name of the destination. If these names are registered in JNDI, you should set the destinationResolver property of the template to an instance of JndiDestinationResolver. 方法send(String destinationName，MessageCreator creator)允许您使用目标的字符串名称发送消息。 如果这些名称在JNDI中注册，则应将模板的destinationResolver属性设置为JndiDestinationResolver的实例。 If you created the JmsTemplate and specified a default destination, the send(MessageCreator c) sends a message to that destination. 如果创建了JmsTemplate并指定了默认目标，则send(MessageCreator c)向该目标发送消息。 Using Message ConvertersIn order to facilitate the sending of domain model objects, the JmsTemplate has various send methods that take a Java object as an argument for a message’s data content. The overloaded methods convertAndSend() and receiveAndConvert() in JmsTemplate delegate the conversion process to an instance of the MessageConverter interface. This interface defines a simple contract to convert between Java objects and JMS messages. The default implementation SimpleMessageConverter supports conversion between String and TextMessage, byte[] and BytesMesssage, and java.util.Map and MapMessage. By using the converter, you and your application code can focus on the business object that is being sent or received via JMS and not be concerned with the details of how it is represented as a JMS message. 为了方便发送域模型对象，JmsTemplate有各种发送方法，它们将Java对象作为消息数据内容的参数。 JmsTemplate中的重载方法convertAndSend()和receiveAndConvert()将转换过程委派给MessageConverter接口的实例。这个接口定义了一个简单的契约来在Java对象和JMS消息之间进行转换。默认实现SimpleMessageConverter支持在String和TextMessage之间转换，byte []和BytesMesssage，以及java.util.Map和MapMessage。通过使用转换器，您和您的应用程序代码可以专注于通过JMS发送或接收的业务对象，而不关心它如何表示为JMS消息的细节。 The sandbox currently includes a MapMessageConverter which uses reflection to convert between a JavaBean and a MapMessage. Other popular implementation choices you might implement yourself are Converters that use an existing XML marshalling package, such as JAXB, Castor, XMLBeans, or XStream, to create a TextMessage representing the object. 沙箱目前包括一个MapMessageConverter，它使用反射在JavaBean和MapMessage之间进行转换。您可能实现的其他流行实现选择是使用现有XML编组包(例如JAXB，Castor，XMLBeans或XStream)的转换器，以创建表示对象的TextMessage。 To accommodate the setting of a message’s properties, headers, and body that can not be generically encapsulated inside a converter class, the MessagePostProcessor interface gives you access to the message after it has been converted, but before it is sent. The example below demonstrates how to modify a message header and a property after a java.util.Map is converted to a message. 为了适应不能一般地封装在转换器类中的消息属性，头和主体的设置，MessagePostProcessor接口允许您在转换后但在发送消息之前访问消息。下面的示例演示了如何在将java.util.Map转换为消息后修改消息头和属性。123456789101112public void sendWithConversion() &#123; Map map = new HashMap(); map.put(&quot;Name&quot;, &quot;Mark&quot;); map.put(&quot;Age&quot;, new Integer(47)); jmsTemplate.convertAndSend(&quot;testQueue&quot;, map, new MessagePostProcessor() &#123; public Message postProcessMessage(Message message) throws JMSException &#123; message.setIntProperty(&quot;AccountID&quot;, 1234); message.setJMSCorrelationID(&quot;123-00001&quot;); return message; &#125; &#125;);&#125; This results in a message of the form:12345678910111213MapMessage=&#123; Header=&#123; ... standard headers ... CorrelationID=&#123;123-00001&#125; &#125; Properties=&#123; AccountID=&#123;Integer:1234&#125; &#125; Fields=&#123; Name=&#123;String:Mark&#125; Age=&#123;Integer:47&#125; &#125;&#125; SessionCallback and ProducerCallbackWhile the send operations cover many common usage scenarios, there are cases when you want to perform multiple operations on a JMS Session or MessageProducer. The SessionCallback and ProducerCallback expose the JMS Session and Session / MessageProducer pair respectively. The execute() methods on JmsTemplate execute these callback methods. 虽然发送操作涵盖了许多常见的使用场景，但有时您希望在JMS会话或MessageProducer上执行多个操作。 SessionCallback和ProducerCallback分别公开了JMS Session和Session / MessageProducer对。 JmsTemplate上的execute()方法执行这些回调方法。 Receiving a messageSynchronous ReceptionWhile JMS is typically associated with asynchronous processing, it is possible to consume messages synchronously. The overloaded receive(..) methods provide this functionality. During a synchronous receive, the calling thread blocks until a message becomes available. This can be a dangerous operation since the calling thread can potentially be blocked indefinitely. The property receiveTimeout specifies how long the receiver should wait before giving up waiting for a message. 虽然JMS通常与异步处理相关联，但是可以同步地消费消息。 重载的receive(..)方法提供这个功能。 在同步接收期间，调用线程阻塞，直到消息变为可用。 这可能是一个危险的操作，因为调用线程可能会无限期地被阻止。 属性receiveTimeout指定接收器在放弃等待消息之前应该等待多长时间。 Asynchronous Reception - Message-Driven POJOs Spring also supports annotated-listener endpoints through the use of the @JmsListener annotation and provides an open infrastructure to register endpoints programmatically. This is by far the most convenient way to setup an asynchronous receiver, see Section 30.6.1, “Enable listener endpoint annotations” for more details. Spring还通过使用@JmsListener注释支持注释监听器端点，并提供了一种开放式基础结构，以编程方式注册端点。 这是迄今为止设置异步接收器的最方便的方法，有关更多详细信息，请参见第30.6.1节“启用侦听器端点注释”。 In a fashion similar to a Message-Driven Bean (MDB) in the EJB world, the Message-Driven POJO (MDP) acts as a receiver for JMS messages. The one restriction (but see also below for the discussion of the MessageListenerAdapter class) on an MDP is that it must implement the javax.jms.MessageListener interface. Please also be aware that in the case where your POJO will be receiving messages on multiple threads, it is important to ensure that your implementation is thread-safe. 以类似于EJB世界中的消息驱动Bean(MDB)的方式，消息驱动POJO(MDP)充当JMS消息的接收器。 MDP上的一个限制(但是下面讨论MessageListenerAdapter类的)是它必须实现javax.jms.MessageListener接口。 还请注意，在您的POJO将在多个线程上接收消息的情况下，确保您的实现是线程安全的很重要。 Below is a simple implementation of an MDP:12345678910111213141516171819202122import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class ExampleListener implements MessageListener &#123; public void onMessage(Message message) &#123; if (message instanceof TextMessage) &#123; try &#123; System.out.println(((TextMessage) message).getText()); &#125; catch (JMSException ex) &#123; throw new RuntimeException(ex); &#125; &#125; else &#123; throw new IllegalArgumentException(&quot;Message must be of type TextMessage&quot;); &#125; &#125;&#125; Once you’ve implemented your MessageListener, it’s time to create a message listener container. 一旦你实现了MessageListener，就是创建一个消息监听器容器的时候了。 Find below an example of how to define and configure one of the message listener containers that ships with Spring (in this case the DefaultMessageListenerContainer). 下面是如何定义和配置Spring附带的一个消息监听器容器(在本例中为DefaultMessageListenerContainer)的示例。123456789&lt;!-- this is the Message Driven POJO (MDP) --&gt;&lt;bean id=&quot;messageListener&quot; class=&quot;jmsexample.ExampleListener&quot; /&gt;&lt;!-- and this is the message listener container --&gt;&lt;bean id=&quot;jmsContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt; &lt;property name=&quot;destination&quot; ref=&quot;destination&quot;/&gt; &lt;property name=&quot;messageListener&quot; ref=&quot;messageListener&quot; /&gt;&lt;/bean&gt; Please refer to the Spring javadocs of the various message listener containers for a full description of the features supported by each implementation. 有关每个实现支持的功能的完整描述，请参阅各种消息侦听器容器的Spring Javadoc。 the SessionAwareMessageListener interfaceThe SessionAwareMessageListener interface is a Spring-specific interface that provides a similar contract to the JMS MessageListener interface, but also provides the message handling method with access to the JMS Session from which the Message was received. SessionAwareMessageListener接口是一个Spring特定的接口，它为JMS MessageListener接口提供了一个类似的契约，但也提供了消息处理方法，以访问接收到消息的JMS会话。1234567package org.springframework.jms.listener;public interface SessionAwareMessageListener &#123; void onMessage(Message message, Session session) throws JMSException;&#125; You can choose to have your MDPs implement this interface (in preference to the standard JMS MessageListener interface) if you want your MDPs to be able to respond to any received messages (using the Session supplied in the onMessage(Message, Session) method). All of the message listener container implementations that ship with Spring have support for MDPs that implement either the MessageListener or SessionAwareMessageListener interface. Classes that implement the SessionAwareMessageListener come with the caveat that they are then tied to Spring through the interface. The choice of whether or not to use it is left entirely up to you as an application developer or architect. 如果希望MDP能够响应任何接收的消息(使用onMessage(消息，会话)方法提供的会话)，您可以选择让MDP实现此接口(优先于标准JMS MessageListener接口)。 Spring附带的所有消息侦听器容器实现都支持实现MessageListener或SessionAwareMessageListener接口的MDP。 实现SessionAwareMessageListener的类带有警告，它们通过接口绑定到Spring。 是否使用它的选择完全取决于您作为应用程序开发人员或架构师。 Please note that the onMessage(..) method of the SessionAwareMessageListener interface throws JMSException. In contrast to the standard JMS MessageListener interface, when using the SessionAwareMessageListener interface, it is the responsibility of the client code to handle any exceptions thrown. 请注意，SessionAwareMessageListener接口的onMessage(..)方法抛出JMSException。 与标准的JMS MessageListener接口相反，当使用SessionAwareMessageListener接口时，客户端代码负责处理抛出的任何异常。 the MessageListenerAdapterThe MessageListenerAdapter class is the final component in Spring’s asynchronous messaging support: in a nutshell, it allows you to expose almost any class as a MDP (there are of course some constraints). MessageListenerAdapter类是Spring的异步消息传递支持的最后一个组件：简而言之，它允许你暴露几乎任何类作为MDP(当然有一些约束)。 Consider the following interface definition. Notice that although the interface extends neither the MessageListener nor SessionAwareMessageListener interfaces, it can still be used as a MDP via the use of the MessageListenerAdapter class. Notice also how the various message handling methods are strongly typed according to the contents of the various Message types that they can receive and handle. 请考虑以下接口定义。 请注意，虽然接口既不扩展MessageListener也不扩展SessionAwareMessageListener接口，但仍然可以通过使用MessageListenerAdapter类用作MDP。 还要注意各种消息处理方法如何根据它们可以接收和处理的各种消息类型的内容进行强类型化。1234567891011public interface MessageDelegate &#123; void handleMessage(String message); void handleMessage(Map message); void handleMessage(byte[] message); void handleMessage(Serializable message);&#125; 123public class DefaultMessageDelegate implements MessageDelegate &#123; // implementation elided for clarity...&#125; In particular, note how the above implementation of the MessageDelegate interface (the above DefaultMessageDelegate class) has no JMS dependencies at all. It truly is a POJO that we will make into an MDP via the following configuration. 特别要注意上面MessageDelegate接口的实现(上面的DefaultMessageDelegate类)是否没有JMS依赖。 它真的是一个POJO，我们将通过以下配置成为MDP。12345678910111213&lt;!-- this is the Message Driven POJO (MDP) --&gt;&lt;bean id=&quot;messageListener&quot; class=&quot;org.springframework.jms.listener.adapter.MessageListenerAdapter&quot;&gt; &lt;constructor-arg&gt; &lt;bean class=&quot;jmsexample.DefaultMessageDelegate&quot;/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- and this is the message listener container... --&gt;&lt;bean id=&quot;jmsContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt; &lt;property name=&quot;destination&quot; ref=&quot;destination&quot;/&gt; &lt;property name=&quot;messageListener&quot; ref=&quot;messageListener&quot; /&gt;&lt;/bean&gt; Below is an example of another MDP that can only handle the receiving of JMS TextMessage messages. Notice how the message handling method is actually called ‘receive’ (the name of the message handling method in a MessageListenerAdapter defaults to ‘handleMessage’), but it is configurable (as you will see below). Notice also how the ‘receive(..)’ method is strongly typed to receive and respond only to JMS TextMessage messages. 下面是另一个只能处理JMS TextMessage消息接收的MDP的示例。 注意消息处理方法实际上叫做“receive”(MessageListenerAdapter中的消息处理方法的名称默认为’handleMessage’)，但它是可配置的(如下所示)。 还要注意’receive(..)’方法是如何强类型地接收和响应JMS TextMessage消息。12345public interface TextMessageDelegate &#123; void receive(TextMessage message);&#125; 123public class DefaultTextMessageDelegate implements TextMessageDelegate &#123; // implementation elided for clarity...&#125; The configuration of the attendant MessageListenerAdapter would look like this: 12345678910&lt;bean id=&quot;messageListener&quot; class=&quot;org.springframework.jms.listener.adapter.MessageListenerAdapter&quot;&gt; &lt;constructor-arg&gt; &lt;bean class=&quot;jmsexample.DefaultTextMessageDelegate&quot;/&gt; &lt;/constructor-arg&gt; &lt;property name=&quot;defaultListenerMethod&quot; value=&quot;receive&quot;/&gt; &lt;!-- we don&apos;t want automatic message context extraction --&gt; &lt;property name=&quot;messageConverter&quot;&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; Please note that if the above ‘messageListener’ receives a JMS Message of a type other than TextMessage, an IllegalStateException will be thrown (and subsequently swallowed). Another of the capabilities of the MessageListenerAdapter class is the ability to automatically send back a response Message if a handler method returns a non-void value. Consider the interface and class: 请注意，如果上面的’messageListener’接收到一个类型不是TextMessage的JMS消息，IllegalStateException将被抛出(并随后被吞噬)。 MessageListenerAdapter类的另一个功能是能够在处理程序方法返回非空值时自动发回响应消息。 考虑接口和类：123456public interface ResponsiveTextMessageDelegate &#123; // notice the return type... String receive(TextMessage message);&#125; 123public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate &#123; // implementation elided for clarity...&#125; If the above DefaultResponsiveTextMessageDelegate is used in conjunction with a MessageListenerAdapter then any non-null value that is returned from the execution of the ‘receive(..)’ method will (in the default configuration) be converted into a TextMessage. The resulting TextMessage will then be sent to the Destination (if one exists) defined in the JMS Reply-To property of the original Message, or the default Destination set on the MessageListenerAdapter (if one has been configured); if no Destination is found then an InvalidDestinationException will be thrown (and please note that this exception will not be swallowed and will propagate up the call stack). 如果上述DefaultResponsiveTextMessageDelegate与MessageListenerAdapter一起使用，则从’receive(..)’方法的执行返回的任何非空值将(在默认配置中)转换为TextMessage。 然后将生成的TextMessage发送到在原始Message的JMS Reply-To属性中定义的Destination(如果存在)或MessageListenerAdapter上的默认目标集(如果已配置); 如果没有找到Destination，那么将抛出一个InvalidDestinationException(请注意，这个异常不会被吞掉，并且会向上传播到调用堆栈)。 Processing messages within transactionsInvoking a message listener within a transaction only requires reconfiguration of the listener container. 在事务内调用消息侦听器只需要重新配置侦听器容器。 Local resource transactions can simply be activated through the sessionTransacted flag on the listener container definition. Each message listener invocation will then operate within an active JMS transaction, with message reception rolled back in case of listener execution failure. Sending a response message (via SessionAwareMessageListener) will be part of the same local transaction, but any other resource operations (such as database access) will operate independently. This usually requires duplicate message detection in the listener implementation, covering the case where database processing has committed but message processing failed to commit. 本地资源事务可以简单地通过监听器容器定义上的sessionTransacted标志来激活。 然后，每个消息侦听器调用将在活动的JMS事务中操作，在侦听器执行失败的情况下消息接收回滚。 发送响应消息(通过SessionAwareMessageListener)将是同一本地事务的一部分，但任何其他资源操作(例如数据库访问)将独立操作。 这通常需要在侦听器实现中重复消息检测，涵盖数据库处理已提交但消息处理无法提交的情况。 123456&lt;bean id=&quot;jmsContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt; &lt;property name=&quot;destination&quot; ref=&quot;destination&quot;/&gt; &lt;property name=&quot;messageListener&quot; ref=&quot;messageListener&quot;/&gt; &lt;property name=&quot;sessionTransacted&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt; For participating in an externally managed transaction, you will need to configure a transaction manager and use a listener container which supports externally managed transactions: typically DefaultMessageListenerContainer. 要参与外部管理事务，您需要配置事务管理器并使用支持外部管理事务的侦听器容器：通常为DefaultMessageListenerContainer。 To configure a message listener container for XA transaction participation, you’ll want to configure a JtaTransactionManager (which, by default, delegates to the Java EE server’s transaction subsystem). Note that the underlying JMS ConnectionFactory needs to be XA-capable and properly registered with your JTA transaction coordinator! (Check your Java EE server’s configuration of JNDI resources.) This allows message reception as well as e.g. database access to be part of the same transaction (with unified commit semantics, at the expense of XA transaction log overhead). 要配置用于XA事务参与的消息侦听器容器，您需要配置一个JtaTransactionManager(默认情况下，委派给Java EE服务器的事务子系统)。 请注意，底层JMS ConnectionFactory需要具有XA能力，并且正确地注册到您的JTA事务协调器！ (检查Java EE服务器的JNDI资源的配置。)这允许消息接收，例如。 数据库访问是同一事务的一部分(具有统一的提交语义，以牺牲XA事务日志开销为代价)。1&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;/&gt; Then you just need to add it to our earlier container configuration. The container will take care of the rest. 然后你只需要将它添加到我们早期的容器配置。 容器将照顾其余的。123456&lt;bean id=&quot;jmsContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt; &lt;property name=&quot;destination&quot; ref=&quot;destination&quot;/&gt; &lt;property name=&quot;messageListener&quot; ref=&quot;messageListener&quot;/&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;&lt;/bean&gt; Support for JCA Message EndpointsBeginning with version 2.5, Spring also provides support for a JCA-based MessageListener container. The JmsMessageEndpointManager will attempt to automatically determine the ActivationSpec class name from the provider’s ResourceAdapter class name. Therefore, it is typically possible to just provide Spring’s generic JmsActivationSpecConfig as shown in the following example. 从版本2.5开始，Spring还提供对基于JCA的MessageListener容器的支持。 JmsMessageEndpointManager将尝试从提供程序的ResourceAdapter类名自动确定ActivationSpec类名。 因此，通常可以只提供Spring的通用JmsActivationSpecConfig，如下面的示例所示。123456789&lt;bean class=&quot;org.springframework.jms.listener.endpoint.JmsMessageEndpointManager&quot;&gt; &lt;property name=&quot;resourceAdapter&quot; ref=&quot;resourceAdapter&quot;/&gt; &lt;property name=&quot;activationSpecConfig&quot;&gt; &lt;bean class=&quot;org.springframework.jms.listener.endpoint.JmsActivationSpecConfig&quot;&gt; &lt;property name=&quot;destinationName&quot; value=&quot;myQueue&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;messageListener&quot; ref=&quot;myMessageListener&quot;/&gt;&lt;/bean&gt; Alternatively, you may set up a JmsMessageEndpointManager with a given ActivationSpec object. The ActivationSpec object may also come from a JNDI lookup (using ). 或者，您可以使用给定的ActivationSpec对象设置JmsMessageEndpointManager。 ActivationSpec对象也可能来自JNDI查找(使用)。12345678910&lt;bean class=&quot;org.springframework.jms.listener.endpoint.JmsMessageEndpointManager&quot;&gt; &lt;property name=&quot;resourceAdapter&quot; ref=&quot;resourceAdapter&quot;/&gt; &lt;property name=&quot;activationSpec&quot;&gt; &lt;bean class=&quot;org.apache.activemq.ra.ActiveMQActivationSpec&quot;&gt; &lt;property name=&quot;destination&quot; value=&quot;myQueue&quot;/&gt; &lt;property name=&quot;destinationType&quot; value=&quot;javax.jms.Queue&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;messageListener&quot; ref=&quot;myMessageListener&quot;/&gt;&lt;/bean&gt; Using Spring’s ResourceAdapterFactoryBean, the target ResourceAdapter may be configured locally as depicted in the following example.12345678910&lt;bean id=&quot;resourceAdapter&quot; class=&quot;org.springframework.jca.support.ResourceAdapterFactoryBean&quot;&gt; &lt;property name=&quot;resourceAdapter&quot;&gt; &lt;bean class=&quot;org.apache.activemq.ra.ActiveMQResourceAdapter&quot;&gt; &lt;property name=&quot;serverUrl&quot; value=&quot;tcp://localhost:61616&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;workManager&quot;&gt; &lt;bean class=&quot;org.springframework.jca.work.SimpleTaskWorkManager&quot;/&gt; &lt;/property&gt;&lt;/bean&gt; The specified WorkManager may also point to an environment-specific thread pool - typically through SimpleTaskWorkManager’s “asyncTaskExecutor” property. Consider defining a shared thread pool for all your ResourceAdapter instances if you happen to use multiple adapters. 指定的WorkManager还可以指向特定于环境的线程池 - 通常通过SimpleTaskWorkManager的“asyncTaskExecutor”属性。考虑为您的所有ResourceAdapter实例定义共享线程池(如果您正好使用多个适配器)。 In some environments (e.g. WebLogic 9 or above), the entire ResourceAdapter object may be obtained from JNDI instead (using ). The Spring-based message listeners can then interact with the server-hosted ResourceAdapter, also using the server’s built-in WorkManager. 在一些环境(例如WebLogic 9或更高版本)中，可以从JNDI(使用)获取整个ResourceAdapter对象。然后基于Spring的消息侦听器可以与服务器托管的ResourceAdapter交互，也使用服务器的内置WorkManager。 Please consult the JavaDoc for JmsMessageEndpointManager, JmsActivationSpecConfig, and ResourceAdapterFactoryBean for more details. 有关更多详细信息，请参阅JavaDoc的JmsMessageEndpointManager，JmsActivationSpecConfig和ResourceAdapterFactoryBean。 Spring also provides a generic JCA message endpoint manager which is not tied to JMS: org.springframework.jca.endpoint.GenericMessageEndpointManager. This component allows for using any message listener type (e.g. a CCI MessageListener) and any provider-specific ActivationSpec object. Check out your JCA provider’s documentation to find out about the actual capabilities of your connector, and consult GenericMessageEndpointManager’s JavaDoc for the Spring-specific configuration details. Spring还提供了一个通用的JCA消息端点管理器，它不绑定到JMS：org.springframework.jca.endpoint.GenericMessageEndpointManager。此组件允许使用任何消息侦听器类型(例如，CCI MessageListener)和任何特定于提供程序的ActivationSpec对象。请查看您的JCA提供程序的文档以了解您的连接器的实际功能，并查阅“GenericMessageEndpointManager的JavaDoc”了解Spring特定的配置详细信息。 JCA-based message endpoint management is very analogous to EJB 2.1 Message-Driven Beans; it uses the same underlying resource provider contract. Like with EJB 2.1 MDBs, any message listener interface supported by your JCA provider can be used in the Spring context as well. Spring nevertheless provides explicit ‘convenience’ support for JMS, simply because JMS is the most common endpoint API used with the JCA endpoint management contract. 基于JCA的消息端点管理非常类似于EJB 2.1消息驱动Bean; 它使用相同的底层资源提供程序合同。 与EJB 2.1 MDB一样，您的JCA提供程序支持的任何消息侦听器接口也可以在Spring上下文中使用。 Spring仍然为JMS提供了显式的“方便”支持，只是因为JMS是与JCA终端管理合同一起使用的最常用的端点API。 Annotation-driven listener endpointsThe easiest way to receive a message asynchronously is to use the annotated listener endpoint infrastructure. In a nutshell, it allows you to expose a method of a managed bean as a JMS listener endpoint. 以异步方式接收消息的最简单方法是使用带注释的侦听器端点基础结构。 简而言之，它允许您将受管Bean的方法公开为JMS侦听器端点。123456@Componentpublic class MyService &#123; @JmsListener(destination = &quot;myDestination&quot;) public void processOrder(String data) &#123; ... &#125;&#125; The idea of the example above is that whenever a message is available on the javax.jms.Destination “myDestination”, the processOrder method is invoked accordingly (in this case, with the content of the JMS message similarly to what the MessageListenerAdapter provides). 上面的例子的想法是，当javax.jms.Destination“myDestination”上有消息可用时，相应地调用processOrder方法(在这种情况下，JMS消息的内容类似于MessageListenerAdapter提供的内容)。 The annotated endpoint infrastructure creates a message listener container behind the scenes for each annotated method, using a JmsListenerContainerFactory. Such a container is not registered against the application context but can be easily located for management purposes using the JmsListenerEndpointRegistry bean. 注释的端点基础结构使用JmsListenerContainerFactory为每个注释的方法在幕后创建一个消息侦听器容器。 这样的容器不是针对应用程序上下文注册的，但可以使用JmsListenerEndpointRegistry bean轻松地进行管理。 @JmsListener is a repeatable annotation on Java 8, so it is possible to associate several JMS destinations to the same method by adding additional @JmsListener declarations to it. On Java 6 and 7, you can use the @JmsListeners annotation. @JmsListener是Java 8上的可重复注释，因此可以通过向其中添加额外的@JmsListener声明将多个JMS目标关联到同一个方法。 在Java 6和7上，可以使用@JmsListeners注释。 Enable listener endpoint annotationsTo enable support for @JmsListener annotations add @EnableJms to one of your @Configuration classes. 要启用对@JmsListener注释的支持，请将@EnableJms添加到您的一个@Configuration类。1234567891011121314@Configuration@EnableJmspublic class AppConfig &#123; @Bean public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() &#123; DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); factory.setConnectionFactory(connectionFactory()); factory.setDestinationResolver(destinationResolver()); factory.setConcurrency(&quot;3-10&quot;); return factory; &#125;&#125; By default, the infrastructure looks for a bean named jmsListenerContainerFactory as the source for the factory to use to create message listener containers. In this case, and ignoring the JMS infrastructure setup, the processOrder method can be invoked with a core poll size of 3 threads and a maximum pool size of 10 threads. 默认情况下，基础结构会查找名为jmsListenerContainerFactory的bean作为工厂用于创建消息侦听器容器的源。 在这种情况下，忽略JMS基础结构设置，可以使用3个线程的核心轮询大小和10个线程的最大池大小调用processOrder方法。 It is possible to customize the listener container factory to use per annotation or an explicit default can be configured by implementing the JmsListenerConfigurer interface. The default is only required if at least one endpoint is registered without a specific container factory. See the javadoc for full details and examples. 可以自定义侦听器容器工厂以便每个注释使用，或者可以通过实现JmsListenerConfigurer接口来配置显式默认值。 仅当至少一个端点注册时没有特定的容器工厂时，才需要默认值。 有关完整的详细信息和示例，请参阅javadoc。 If you prefer XML configuration use the element. 如果您喜欢XML配置，请使用元素。12345678&lt;jms:annotation-driven/&gt;&lt;bean id=&quot;jmsListenerContainerFactory&quot; class=&quot;org.springframework.jms.config.DefaultJmsListenerContainerFactory&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt; &lt;property name=&quot;destinationResolver&quot; ref=&quot;destinationResolver&quot;/&gt; &lt;property name=&quot;concurrency&quot; value=&quot;3-10&quot;/&gt;&lt;/bean&gt; Programmatic endpoints registrationJmsListenerEndpoint provides a model of an JMS endpoint and is responsible for configuring the container for that model. The infrastructure allows you to configure endpoints programmatically in addition to the ones that are detected by the JmsListener annotation. JmsListenerEndpoint提供了一个JMS端点的模型，并负责配置该模型的容器。 除了JmsListener注释检测到的端口之外，基础架构还允许您以编程方式配置端点。123456789101112131415@Configuration@EnableJmspublic class AppConfig implements JmsListenerConfigurer &#123; @Override public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) &#123; SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint(); endpoint.setId(&quot;myJmsEndpoint&quot;); endpoint.setDestination(&quot;anotherQueue&quot;); endpoint.setMessageListener(message -&gt; &#123; // processing &#125;); registrar.registerEndpoint(endpoint); &#125;&#125; In the example above, we used SimpleJmsListenerEndpoint which provides the actual MessageListener to invoke but you could just as well build your own endpoint variant describing a custom invocation mechanism. 在上面的例子中，我们使用SimpleJmsListenerEndpoint，它提供了实际的MessageListener来调用，但是你也可以创建自己的描述自定义调用机制的端点变量。 It should be noted that you could just as well skip the use of @JmsListener altogether and only register your endpoints programmatically through JmsListenerConfigurer. 应该注意，你也可以跳过使用@JmsListener，并且只通过JmsListenerConfigurer以编程方式注册您的端点。 Annotated endpoint method signatureSo far, we have been injecting a simple String in our endpoint but it can actually have a very flexible method signature. Let’s rewrite it to inject the Order with a custom header: 到目前为止，我们已经在我们的端点中注入了一个简单的String，但是它实际上可以有一个非常灵活的方法签名。 让我们重写它以注入订单与自定义标题：12345678@Componentpublic class MyService &#123; @JmsListener(destination = &quot;myDestination&quot;) public void processOrder(Order order, @Header(&quot;order_type&quot;) String orderType) &#123; ... &#125;&#125; These are the main elements you can inject in JMS listener endpoints: 这些是您可以在JMS侦听器端点中注入的主要元素： The raw javax.jms.Message or any of its subclasses (provided of course that it matches the incoming message type). The javax.jms.Session for optional access to the native JMS API e.g. for sending a custom reply. The org.springframework.messaging.Message representing the incoming JMS message. Note that this message holds both the custom and the standard headers (as defined by JmsHeaders). @Header-annotated method arguments to extract a specific header value, including standard JMS headers. @Headers-annotated argument that must also be assignable to java.util.Map for getting access to all headers. A non-annotated element that is not one of the supported types (i.e. Message and Session) is considered to be the payload. You can make that explicit by annotating the parameter with @Payload. You can also turn on validation by adding an extra @Valid. 原始javax.jms.Message或其任何子类(当然它提供了匹配传入消息类型)。 javax.jms.Session用于可选访问本机JMS API，例如 发送自定义回复。 org.springframework.messaging.Message表示传入的JMS消息。 请注意，此消息包含自定义标头和标准头(由JmsHeaders定义)。 @Header-annotated方法参数，用于提取特定标头值，包括标准JMS头。 @Header-annotated参数，必须也可以分配给java.util.Map以获取对所有头的访问。 不是受支持类型(即消息和会话)之一的非注释元素被认为是有效载荷。 您可以通过使用@Payload注释参数来使其显式。 您还可以通过添加一个额外的@Valid来启用验证。 The ability to inject Spring’s Message abstraction is particularly useful to benefit from all the information stored in the transport-specific message without relying on transport-specific API. 注入Spring消息抽象的能力特别有利于从传输特定消息中存储的所有信息中受益，而不依赖于传输特定的API。12@JmsListener(destination = &quot;myDestination&quot;)public void processOrder(Message&lt;Order&gt; order) &#123; ... &#125; Handling of method arguments is provided by DefaultMessageHandlerMethodFactory which can be further customized to support additional method arguments. The conversion and validation support can be customized there as well. 方法参数的处理由DefaultMessageHandlerMethodFactory提供，可以进一步自定义以支持其他方法参数。 转换和验证支持也可以在那里定制。 For instance, if we want to make sure our Order is valid before processing it, we can annotate the payload with @Valid and configure the necessary validator as follows: 例如，如果我们要在处理之前确保我们的Order是有效的，我们可以用@Valid注释有效负载，并配置必要的验证器如下：12345678910111213141516@Configuration@EnableJmspublic class AppConfig implements JmsListenerConfigurer &#123; @Override public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) &#123; registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory()); &#125; @Bean public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123; DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory(); factory.setValidator(myValidator()); return factory; &#125;&#125; Response managementThe existing support in MessageListenerAdapter already allows your method to have a non-void return type. When that’s the case, the result of the invocation is encapsulated in a javax.jms.Message sent either in the destination specified in the JMSReplyTo header of the original message or in the default destination configured on the listener. That default destination can now be set using the @SendTo annotation of the messaging abstraction. MessageListenerAdapter中的现有支持已允许您的方法具有非void返回类型。 在这种情况下，调用的结果将封装在javax.jms.Message中，该消息在原始消息的JMSReplyTo标头中指定的目标中或在侦听器上配置的默认目标中发送。 现在可以使用消息抽象的@SendTo注释来设置默认目标。 Assuming our processOrder method should now return an OrderStatus, it is possible to write it as follow to automatically send a response: 假设我们的processOrder方法现在应该返回一个OrderStatus，它可以写如下，自动发送一个响应：123456@JmsListener(destination = &quot;myDestination&quot;)@SendTo(&quot;status&quot;)public OrderStatus processOrder(Order order) &#123; // order processing return status;&#125; If you have several @JmsListener-annotated methods, you can also place the @SendTo annotation at the class level to share a default reply destination. 如果您有多个@ JmsListener注释的方法，您还可以将@SendTo注释放在类级别以共享默认回复目标。 If you need to set additional headers in a transport-independent manner, you could return a Message instead, something like: 如果您需要以独立于传输方式设置附加标题，则可以返回一条消息，如下所示：123456789@JmsListener(destination = &quot;myDestination&quot;)@SendTo(&quot;status&quot;)public Message&lt;OrderStatus&gt; processOrder(Order order) &#123; // order processing return MessageBuilder .withPayload(status) .setHeader(&quot;code&quot;, 1234) .build();&#125; If you need to compute the response destination at runtime, you can encapsulate your response in a JmsResponse instance that also provides the destination to use at runtime. The previous example can be rewritten as follows: 如果需要在运行时计算响应目标，则可以将响应封装在JmsResponse实例中，该实例还提供在运行时使用的目标。 前面的例子可以改写如下：123456789@JmsListener(destination = &quot;myDestination&quot;)public JmsResponse&lt;Message&lt;OrderStatus&gt;&gt; processOrder(Order order) &#123; // order processing Message&lt;OrderStatus&gt; response = MessageBuilder .withPayload(status) .setHeader(&quot;code&quot;, 1234) .build(); return JmsResponse.forQueue(response, &quot;status&quot;);&#125; JMS namespace supportSpring provides an XML namespace for simplifying JMS configuration. To use the JMS namespace elements you will need to reference the JMS schema: Spring提供了一个XML命名空间来简化JMS配置。 要使用JMS命名空间元素，您需要引用JMS模式：1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd&quot;&gt; &lt;!-- bean definitions here --&gt;&lt;/beans&gt; The namespace consists of three top-level elements: , and .]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[调整Spring中的JMS消息消费]]></title>
      <url>%2F2016%2F11%2F23%2F%E8%B0%83%E6%95%B4Spring%E4%B8%AD%E7%9A%84JMS%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%2F</url>
      <content type="text"><![CDATA[ActiveMQ官方推荐博客:原文In a previous blog post titled Using Spring to Receive JMS Messages, I introduced the use of the Spring default message listener container for asynchronous consumption of JMS messages. One very common discovery that folks make when first using JMS is that producers can send messages much faster than consumers can receive and process them. When using JMS queues, I always recommend the use of more consumers than you have producers. (When using JMS topics, you should only use a single consumer to guard against receiving the same message multiple times.) This is a normal situation with message-oriented middleware (MOM) and it is easy to handle if you are using the Spring message listener container. 在上一篇题为使用Spring接收JMS消息的博文中，我介绍了使用Spring默认消息侦听器容器来异步消费JMS消息。 人们在首次使用JMS时所做的一个非常常见的发现是，生产者可以发送消息的速度比消费者能够接收和处理消息的速度快得多。 当使用JMS队列时，我总是建议使用比生产者更多的消费者。 （当使用JMS主题时，你应该只使用一个消费者防止多次接收同一个消息。）这是一个正常的情况与面向消息的中间件（MOM），如果你使用Spring消息很容易处理监听器容器。 The Spring DefaultMessageListenerContainer (DMLC) is a highly flexible container for consuming JMS messages that can handle many different use cases via the numerous properties that it provides. For the situation mentioned above, the DMLC offers the ability to dynamically scale the number of consumers. That is, as the number of messages available for consumption increases, the DMLC can automatically increase and decrease the number of consumers. To configure the DMLC to automatically scale the number message consumers, the concurrentConsumers) property and the maxConcurrentConsumers property are used. Below is an example JMS namespace style of XML configuration that employs these properties: Spring DefaultMessageListenerContainer（DMLC）是一个高度灵活的容器，用于消费JMS消息，可以通过它提供的众多属性处理许多不同的用例。 对于上述情况，DMLC提供了动态扩展消费者数量的能力。 也就是说，随着可用于消费的消息的数量的增加，DMLC可以自动增加和减少消费者的数量。 要配置DMLC自动扩展消息使用者的数量，请使用concurrentConsumers)属性和maxConcurrentConsumers属性。 下面是使用这些属性的XML配置的示例JMS命名空间样式：12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-3.0.xsd&quot;&gt; &lt;!-- A JMS connection factory for ActiveMQ --&gt; &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; p:brokerURL=&quot;tcp://foo.example.com:61616&quot; /&gt; &lt;!-- A POJO that implements the JMS message listener --&gt; &lt;bean id=&quot;simpleMessageListener&quot; class=&quot;com.mycompany.SimpleMessageListener&quot;&gt; &lt;!-- A JMS namespace aware Spring configuration for the message listener container --&gt; &lt;jms:listener-container container-type=&quot;default&quot; connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot; concurrency=&quot;10-50&quot;&gt; &lt;jms:listener destination=&quot;TEST.FOO&quot; ref=&quot;simpleMessageListener&quot; method=&quot;onMessage&quot; /&gt; &lt;/jms:listener-container&gt;&lt;/beans&gt; Notice the concurrency=”10-50” property above. This is a simplified configuration for setting the concurrentConsumers=10 and the maxConcurrentConsumers=50 properties of the DMLC. This tells the DMLC to always start up a minimum of 10 consumers. When a new message has been received, if the maxConcurrentConsumers has not been reached and the value of the idleConsumerLimit property has not been reached, then a new consumer is created to process the message. This behavior from the DMLC continues up to the limit set by the maxConcurrentConsumers property. When no messages are being received and the consumers become idle, the number of consumers is automatically decreased. 注意上面的concurrency =“10-50”属性。 这是设置DMLC的concurrentConsumers = 10和maxConcurrentConsumers = 50属性的简化配置。 这告诉DMLC至少启动10个消费者。 当接收到新消息时，如果未达到maxConcurrentConsumers且未达到idleConsumerLimit属性的值，则会创建一个新的消费者来处理消息。 DMLC会重复这个行为直到达到由maxConcurrentConsumers属性设置的限制。 当没有接收到消息并且消费者空闲时，消费者的数量会自动减少。 (NOTE: The idleConsumerLimit property is used to specify the the maximum number of consumers that are allowed to be idle at a given time. The use of this property was recently clarified a bit in the Spring 3.x trunk. Increasing this limit causes invokers to be created more aggressively. This can be useful to ramp up the number of consumers faster.) （注意：idleConsumerLimit属性用于指定在给定时间内允许空闲消费者的最大数量。这个属性的使用最近在Spring 3.x中阐明了，增加这个限制会导致更积极地创建调用者，可以有助于更快的加快消费者的数量）。 It is important to be aware of a couple of things related to this dynamic scaling: You should not increase the number of concurrent consumers for a JMS topic. This leads to concurrent consumption of the same message, which is hardly ever desirable. The concurrentConsumers property and the maxConcurrentConsumers property can be modified at runtime, e.g., via JMX 重要的是要注意一些与这个动态缩放有关的事情： 不应增加JMS主题的并发消耗程序数。 这导致同时消费相同的消息，这是不可取的。 可以在运行时（例如，通过JMX）修改concurrentConsumers属性和maxConcurrentConsumers属性 The dynamic scaling can be tuned even further through the use of the idleTaskExecutionLimit) property. The use of this property is best explained by a portion of the Javadoc: 通过使用idleTaskExecutionLimit)属性，可以进一步调整动态缩放。 Javadoc的部分解释是此属性最好的使用方式： Within each task execution, a number of message reception attempts (according to the “maxMessagesPerTask” setting) will each wait for an incoming message (according to the “receiveTimeout” setting). If all of those receive attempts in a given task return without a message, the task is considered idle with respect to received messages. Such a task may still be rescheduled; however, once it reached the specified “idleTaskExecutionLimit”, it will shut down (in case of dynamic scaling). 在每个任务执行中，尝试接收多个消息（根据“maxMessagesPerTask”设置）将等待一个传入消息（根据“receiveTimeout”设置）。 如果在给定没有消息返回的任务中尝试接收，则该任务相对接收消息被认为是空闲的。 这样的任务可能仍然被重新安排; 然而，一旦它达到指定的“idleTaskExecutionLimit”，它将关闭（在动态缩放的情况下）。 Raise this limit if you encounter too frequent scaling up and down. With this limit being higher, an idle consumer will be kept around longer, avoiding the restart of a consumer once a new load of messages comes in. Alternatively, specify a higher “maxMessagesPerTask” and/or “receiveTimeout” value, which will also lead to idle consumers being kept around for a longer time (while also increasing the average execution time of each scheduled task). 如果过于频繁的放大和缩小，请提高此限制。 随着这个限制越来越高，空闲的消费者将保持更长时间，避免消费者的新负载进入时重新启动消费者。或者，指定更高的“maxMessagesPerTask” and/or “receiveTimeout”值，这也将导致闲置的消费者保持较长时间（同时还增加每个调度任务的平均执行时间）。 Note the recommendations if you experience dynamic scaling taking place too often. To deal with this situation, you should experiment with increases to one or more of the following properties: idleTaskExecutionLimit) - The limit for the number of allowed idle executions of a receive task. The default is 1 causing idle resources to be closed early once a task does not receive a message. maxMessagesPerTask) - The maximum number of messages to process in a single task. This determines how long a task lives before being reaped. The default is unlimited (-1) so you may not need to change this property. receiveTimeout) - The timeout to be used for JMS receive operations. The default is 1000 ms. As I noted above, in the Spring 3.x trunk, the idleConsumerLimit property was clarified a bit recently and exposed as a writable property. This is yet another property for tuning for situations where you need to ramp up the number of concurrent consumers faster. 请注意,如果您过于频繁的动态缩放，要处理这种情况，您应该尝试增加一个或多个以下属性： idleTaskExecutionLimit) - 接收任务的允许空闲执行次数的限制。 默认值为1，导致空闲资源在任务未收到消息时提前关闭。 maxMessagesPerTask) - 在单个任务中处理的最大消息数。 这决定了任务在获取之前的生存时间。 默认值为unlimited（-1），因此您可能不需要更改此属性。 receiveTimeout) - 要用于JMS接收操作的超时。 默认值为1000 ms。 如上所述，在Spring 3.x trunk中，idleConsumerLimit属性最近被澄清了一下，并被公开为可写属性。 这是另一个属性，用于调整您需要更快地提高并发消费者数量的情况。 One important thing to note about using these various properties for tuning. These are not usable in the JMS namespace style of XML configuration. To use these properties, you must use either a pure Spring XML configuration or straight Java. Below is an example of how to use the receiveTimeout property and the idleTaskExecutionLimit property: 使用这些各种属性进行调整时要注意一个重要的事情。 这些在XML配置的JMS命名空间样式中不可用。 要使用这些属性，必须使用纯Spring XML配置或纯Java。 下面是如何使用receiveTimeout属性和idleTaskExecutionLimit属性的示例：123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;!-- A JMS connection factory for ActiveMQ --&gt; &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; p:brokerURL=&quot;tcp://foo.example.com:61616&quot; /&gt; &lt;!-- The JMS destination --&gt; &lt;bean id=&quot;destination&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot; physicalName=&quot;TEST.FOO&quot; /&gt; &lt;!-- A POJO that implements the JMS message listener --&gt; &lt;bean id=&quot;simpleMessageListener&quot; class=&quot;com.mycompany.SimpleMessageListener&quot;&gt; &lt;!-- A pure Spring configuration for the message listener container --&gt; &lt;bean id=&quot;msgListenerContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot; p:connectionFactory-ref=&quot;connectionFactory&quot; p:destination-ref=&quot;destination&quot; p:messageListener-ref=&quot;simpleMessageListener&quot; p:concurrentConsumers=&quot;10&quot; p:maxConcurrentConsumers=&quot;50&quot; p:receiveTimeout=&quot;5000&quot; p:idleTaskExecutionLimit=&quot;10&quot; p:idleConsumerLimit=&quot;5&quot; /&gt;&lt;/beans&gt; In the example configuration above, the receiveTimeout property is set to five seconds to tell the DMLC’s receive operation to poll for message for five seconds instead of the default one second. Also, the idleTaskExecutionLimit property is set to 10 to allow tasks to execute 10 times instead of the default value of 1. Lastly, the idleConsumerLimit property specifies the limit on the number of idle consumers. This property can be used to more aggressively ramp up the number of concurrent consumers. 在上面的示例配置中，receiveTimeout属性设置为五秒，以告知DMLC每五秒执行接收消息操作，而不是默认的一秒。 此外，idleTaskExecutionLimit属性设置为10，允许任务执行10次，而不是默认值1。最后，idleConsumerLimit属性指定对空闲用户数量的限制。 此属性可用于更积极地增加并发消费者的数量。 In addition to tuning these various properties for dynamic consumer scaling, it is also important to understand that the DMLC can also provide various levels of caching for JMS resources (i.e., JMS connections, sessions and consumers). By default, the DMLC will cache all JMS resources unless an external transaction manager is configured (because some containers require fresh JMS resources for external transactions). When an external transaction manager is configured, none of the JMS resources are cached by defualt. The level of caching can be configured using the cacheLevel) property. This property allows for a tiered caching from connection, to session, to consumer. This allows caching of: The connection The connection and the session The connection, the session and the consumer 除了调整这些各种属性以用于缩放动态消费者之外，理解DMLC还可以为JMS资源（即，JMS连接，会话和消费者）提供各种级别的高速缓存也是重要的。 默认情况下，DMLC将缓存所有JMS资源，除非配置了外部事务管理器（因为一些容器需要用于外部事务的新JMS资源）。 配置外部事务管理器时，不会通过defualt缓存任何JMS资源。 可以使用cacheLevel)属性配置缓存级别。 此属性允许从连接到会话，到消费者的分层缓存。 允许缓存： 连接 连接和会话 连接，会话和消费者 Below is an example configuration that uses the cacheLevel property to specify consumer level caching: 以下是使用cacheLevel属性指定消费级别缓存的示例配置：1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-3.0.xsd&quot;&gt; &lt;!-- A JMS connection factory for ActiveMQ --&gt; &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; p:brokerURL=&quot;tcp://foo.example.com:61616&quot; /&gt; &lt;!-- A POJO that implements the JMS message listener --&gt; &lt;bean id=&quot;simpleMessageListener&quot; class=&quot;com.mycompany.SimpleMessageListener&quot;&gt; &lt;!-- A JMS namespace aware Spring configuration for the message listener container --&gt; &lt;jms:listener-container container-type=&quot;default&quot; connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot; concurrency=&quot;10-50&quot; cache=&quot;consumer&quot;&gt; &lt;jms:listener destination=&quot;TEST.FOO&quot; ref=&quot;simpleMessageListener&quot; method=&quot;onMessage&quot; /&gt; &lt;/jms:listener-container&gt;&lt;/beans&gt; By caching at the consumer level, this means that the connection, the session and the consumer is cached. Notice that the cacheLevel property can be used with the Spring JMS namespace style of XML configuration. 在消费者级别缓存，意味着缓存连接，会话和使用者。 请注意，cacheLevel属性可以与Spring JMS命名空间样式的XML配置一起使用。 The session is cached based on ack-mode and the consumer is cached based on the session, the selector and the destination. It’s necessary to know this info to better understand where/when the JMS resources can and cannot be reused. For example, caching consumers that use different selectors and consume from different destinations is only going to be relevant if you partition these items appropriately for reuse. That is, you may need to use a separate connection and listener-container configuration if the cache keys are different and if you want to cache sessions or consumers for reuse. 会话基于ack模式被缓存，且消费者基于会话，选择器和目的地被缓存。 知道这个信息，可以更好地了解JMS资源在哪里/什么时候可以或不能重复使用。 例如，缓存使用 不同选择器和从不同目的地使用的 消费者只有在适当分配这些项目以便重用时才会是相关的。 也就是说，如果缓存键(cache keys)不同，且您想要缓存会话或消费者以供重用，则可能需要使用单独的连接和侦听器/容器配置。 The overall point of the caching is that it can help to reduce the potential recurring thrash involved in creation and destruction of JMS resources. Reducing the thrash by using caching and employing the appropriate partitioning of these resources so as to allow for reuse can definitely improve the overall performance of the application. 总体上看，缓存可以帮助减少JMS资源的创建和销毁所涉及的潜在重复性事件。通过使用高速缓存和这些资源的适当分区来减少thrash以便允许重用,可以明确地提高应用的整体性能。 Hopefully this post helps you understand how to tune JMS message consumption in Spring. As you employ Spring JMS to your applications and experiment further and further, you will discover how much the DMLC is actually doing for you and how many more features it has beyond what you can easily build yourself. 希望这篇文章帮助你了解如何在Spring中调整JMS消息消费。当你对应用程序和实验进一步更进一步地使用Spring JMS，你会发现实际上DMLC为你做了许多，以及你自己轻松实现以外的许多功能。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2016%2F11%2F22%2FString%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[12345String s3 = new String(&quot;A&quot;) + new String(&quot;B&quot;);String s4 = &quot;AB&quot;;String s5 = s3.intern();System.out.println(s3 == s4);System.out.println(s4 == s5); 12345String s3 = new String(&quot;A&quot;) + new String(&quot;B&quot;);String s5 = s3.intern();String s4 = &quot;AB&quot;;System.out.println(s3 == s4);System.out.println(s4 == s5);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Spring接收JMS消息]]></title>
      <url>%2F2016%2F11%2F22%2F%E4%BD%BF%E7%94%A8Spring%E6%8E%A5%E6%94%B6JMS%E6%B6%88%E6%81%AF%2F</url>
      <content type="text"><![CDATA[ActiveMQ官方推荐博客:原文Have you ever had a need to create your own JMS consumer? Or will you have this need in the future? If you answered yes to either one of these questions, this post will simplify your life. 你有没有需要创建自己的JMS消费者(consumer)？ 或者你将来会有这种需要吗？ 如果你对这些问题中的任何一个回答“是”，这篇文章将简化你的生活。 In the previous post, I discussed Using the Spring JmsTemplate to Send JMS Messages. As a follow-on, in this post I will demonstrate how to receive messages using Spring JMS. Although the previously mentioned JmsTemplate can receive messages synchronously, here I will focus on asynchronous message reception using the Spring message listener container architecture, specifically the DefaultMessageListenerContainer. 在上一篇文章中，我讨论了使用Spring JmsTemplate发送JMS消息。 作为后续，在这篇文章中，我将演示如何使用Spring JMS接收消息。 尽管前面提到的JmsTemplate可以同步接收消息，这里我将重点介绍使用Spring消息侦听器容器体系结构的异步消息接收，特别是DefaultMessageListenerContainer。 The DefaultMessageListenerContainer (DMLC) is another wonderful convenience class that is part of the Spring Framework’s JMS package. As you can see in the Javadoc, the DMLC is not a single class, but a well-abstracted hierarchy for the purpose of receiving messages. The reason for this is that the DMLC takes its inspiration from Message Driven Beans (MDB). DefaultMessageListenerContainer（DMLC）是另一个非常方便的类，它是Spring Framework的JMS包的一部分。 正如您在Javadoc中可以看到的，DMLC不是一个类，而是一个抽象层次结构，用于接收消息。 其原因是DMLC从Message Driven Beans（MDB）中获得灵感。 MDBs were originally defined in the EJB 2.0 spec as a stateless, transaction aware message listener that use JMS resources provided by the Java EE container. MDBs can also be pooled by the Java EE container in order to scale up. In short, MDBs were designed for asynchronous message reception in a way that the Java EE container could manage them. Although the intention was good, unfortunately the disadvantages of MDBs are numerous including: MDBs are static in their configuration and creation (they cannot be created dynamically) MDBs can only listen to a single destination MDBs can only send messages after first receiving a message MDBs require an EJB container (and therefore the Java EE container) MDB最初在EJB 2.0规范中定义为使用由Java EE容器提供JMS资源的无状态事务感知消息侦听器。 MDB也可以由Java EE容器进行合并，以便向上扩展。 简而言之，MDB是为Java EE容器可以管理异步消息接收而设计的。 虽然目的是好的，但不幸的是，MDB的缺点很多，包括: MDB在其配置和创建中是静态的（不能动态创建） MDB只能侦听单个目标 MDB只能在首次接收消息后发送消息 MDB需要一个EJB容器（因此也就是Java EE容器） Although the Spring DMLC took its inspiration from MDBs, it did not replicate these disadvantages; quite the opposite, in fact. The Spring DMLC is commonly used to create what have become known as Message-Driven POJOs (MDP). MDPs offer all of the same functionality as MDBs but without the disadvantages listed above. The Spring DMLC provides many features including: Various levels of caching of the JMS resources (connections and sessions) and JMS consumers for increased performance The ability to dynamically grow and shrink the number of consumers to concurrently process messages based on load (see setConcurrentConsumers) and setMaxConcurrentConsumers)) for additional performance Automatically re-establishes connections if the message broker becomes unavailable Asynchronous execution of a message listener using the Spring TaskExecutor Support for local JMS transactions as well as an external transaction manager around message reception and listener execution Support for various message acknowledgement modes, each providing different semantics 虽然Spring的DMLC从MDBs的灵感，它没有复制这些缺点; 恰恰相反，事实上, Spring DMLC通常用于创建Message-Driven POJO（MDP）。 MDP提供与MDB相同的功能，但没有上面列出的缺点。 Spring DMLC提供了许多功能，包括: JMS资源（连接和会话）和JMS消费者的各种级别的缓存，以提高性能 能够动态增长和减少消费者数量，以便根据负载实时处理消息（请参阅setConcurrentConsumers)和setMaxConcurrentConsumers)）以获得更多性能 如果消息代理不可用，则自动重新建立连接 使用Spring任务执行器异步执行消息监听器 支持本地JMS事务以及围绕消息接收和侦听器执行的外部事务管理器 支持各种消息确认模式，每种模式提供不同的语义 For some situations, it is important to understand the additional error handling and the redelivery semantics that are provided by the DMLC. For more information, see the AbstractMessageListenerContainer JavaDoc. 对于某些情况，了解DMLC提供的附加错误处理和重新传递语义很重要。 有关更多信息，请参阅AbstractMessageListenerContainer JavaDoc。 The reason I recommend the DMLC (or even the SimpleMessageListenerContainer) is because writing JMS consumers can be a lot of work. In doing so, you must manually handle and mange the JMS resources and the JMS consumers, any concurrency that is necessary and any use of transactions. If you’ve ever done such work you know how arduous and error prone it can be. Certainly MDBs provide some of these features but with all their disadvantages. By creating MDPs using the Spring DMLC, I have seen users save a tremendous amount of time and increase their productivity significantly. This is because the DMLC offers much flexibility, robustness, a high amount of configurability and it has widespread deployment in businesses all over the world (so it has been widely tested). 我推荐DMLC（或者甚至SimpleMessageListenerContainer）的原因是因为编写JMS消费者是很大的工作量。 这样做，任何必要的并发和使用任何事务，您都必须手动处理和管理JMS资源和JMS使用者。 如果你做过这样的工作，你肯定知道它是多么艰巨和容易出错。 当然，MDB提供了一些这些功能，但是具有所有的缺点。 通过使用Spring DMLC创建MDP，我看到用户节省了大量的时间，并显着提高了他们的工作效率。 这是因为DMLC提供了很大的灵活性，鲁棒性，大量的可配置性，并且它在全世界的商业中广泛部署（因此它已经被广泛测试）。 Compared to MDBs, use of the Spring DMLC is actually surprisingly simple. The easiest way to get started is to using an XML configuration as the Spring DMLC provides JMS namespace support. Below is a Spring application context that demonstrates the configuration to use the Spring DMLC with Apache ActiveMQ: 与MDB相比，使用Spring DMLC实际上非常简单。 最简单的开始方法是使用XML配置，因为Spring DMLC提供了JMS命名空间支持。 下面是一个Spring应用程序上下文，演示了将Spring DMLC与Apache ActiveMQ结合使用的配置:123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-3.0.xsd&quot;&gt; &lt;!-- A JMS connection factory for ActiveMQ --&gt; &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; p:brokerURL=&quot;tcp://foo.example.com:61616&quot; /&gt; &lt;!-- A POJO that implements the JMS message listener --&gt; &lt;bean id=&quot;simpleMessageListener&quot; class=&quot;com.mycompany.SimpleMessageListener&quot;&gt; &lt;!-- The Spring message listener container configuration --&gt; &lt;jms:listener-container container-type=&quot;default&quot; connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot;&gt; &lt;jms:listener destination=&quot;TEST.FOO&quot; ref=&quot;simpleMessageListener&quot; method=&quot;onMessage&quot; /&gt; &lt;/jms:listener-container&gt;&lt;/beans&gt; For folks who are already familiar with the Spring Framework, the XML above is quite straightforward. It defines a connection factory bean for ActiveMQ, a message listener bean and the Spring listener-container. Notice that the jms:listener contains the destination name and not the listener-container. This level of separation is important because it means that the listener-container is not tied to any destination, only the jms:listener is. You can define as many jms:listener elements as is necessary for your application and the container will handle them all. 对于已经熟悉Spring框架的人来说，上面的XML非常简单。 它定义了ActiveMQ的连接工厂bean，一个消息监听器bean和Spring监听器容器。 请注意，jms:listener包含目标名称，而不是侦听器容器。 这种分离级别很重要，因为它意味着侦听器容器不绑定到任何目标，只有jms:listener。 如果你需要，可以定义尽可能多的jms:listener元素，容器会恰当的处理它们。 Below is the message listener implementation: 下面是消息侦听器实现:123456789101112131415161718192021import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.apache.log4j.Logger;public class SimpleMessageListener implements MessageListener &#123; private static final Logger LOG = Logger.getLogger(SimpleMessageListener.class); public void onMessage(Message message) &#123; try &#123; TextMessage msg = (TextMessage) message; LOG.info(&quot;Consumed message: &quot; + msg.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; The message listener implementation is deliberately simple as its only purpose is to demonstrate receiving the message and logging the payload of the message. Although this listener implements the javax.jms.MessageListener interface, there are a total of three options available for implementing a message listener to be used with the Spring DMLC: The javax.jms.MessageListener - This is what was used in the example above. It is a standardized interface from the JMS spec but handling threading is up to you. The Spring SessionAwareMessageListener - This is a Spring-specific interface the provides access to the JMS session object. This is very useful for request-response messaging. Just be aware that you must do your own exception handling (i.e., override the handleListenerException) method so exceptions are not lost). The Spring MessageListenerAdapter - This is a Spring-specific interface that allows for type-specific message handling. Use of this interface avoids any JMS-specific dependencies in your code. 简单的实现消息侦听器是故意的，因为它的唯一目的是示范接收消息和记录消息的有效载荷。 虽然此侦听器实现了javax.jms.MessageListener接口，但是总共有三个选项可用于实现要与Spring DMLC一起使用的消息侦听器: javax.jms.MessageListener - 这是上面的例子中使用的。 它是一个来自JMS规范的标准化接口，但是你要处理线程。 Spring SessionAwareMessageListener - 这是一个Spring特定的接口，提供对JMS会话对象的访问。 这对于请求 - 响应消息传递非常有用。 只需要注意，你必须做自己的异常处理（即，重写handleListenerException方法，这样异常不会丢失）。 Spring MessageListenerAdapter - 这是一个Spring特定的接口，允许特定类型的消息处理。 使用此接口可避免代码中任何特定于JMS的依赖关系。 So not only is the Spring message listener container easy to use, it is also full of options to adapt to many environments. And I’ve only focused on the DefaultMessageListenerContainer here, I have not talked about the SimpleMessageListenerContainer (SMLC) beyond a simple mention. At a high level the difference is that the SMLC is static and provides no support for transactions. 所以Spring消息监听器容器不仅易于使用，也充满了许多适应环境的选项。 这里我只专注于DefaultMessageListenerContainer，没有详细谈到SimpleMessageListenerContainer（SMLC）。 在高级别上，区别在于SMLC是静态的，并且不提供对事务的支持。 One very big advantage of the Spring message listener container is that this type of XML config can be used in a Java EE container, in a servlet container or stand alone. This same Spring application context will run in Weblogic, JBoss, Tomcat or in a stand alone Spring container. Furthermore, the Spring DMLC also works with just about any JMS compliant messaging middleware available. Just define a bean for the JMS connection factory for your MOM and possibly tweak a few properties on the listener-container and you can begin consuming messages from different MOMs. Spring消息监听器容器一个非常大的优点是，这种类型的XML配置可以在Java EE容器中，在servlet容器中使用，或者独立使用。 同样的Spring应用程序上下文将在Weblogic，JBoss，Tomcat或独立的Spring容器中运行。 此外，Spring DMLC还可以与任何JMS兼容的消息中间件可用。 只需为您的MOM的JMS连接工厂定义一个bean，并可能在侦听器容器上调整几个属性，并且您可以开始从不同的MOM消费消息。 I should also note that the XML configuration is certainly not a requirement either. You can go straight for the underlying Java classes in your own code if you wish. I’ve used each style in various situations, but to begin using the Spring DMLC in the shortest amount of time, I find the Spring XML application context the fastest. 还应该注意，XML配置不是唯一的方法。 如果你愿意，你可以直接在你代码底层的Java类中陪住。 我在各种情况下使用了各种方式，但我发现Spring XML应用程序上下文是在最快、最短的时间内开始使用Spring DMLC的方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Spring发送JMS消息]]></title>
      <url>%2F2016%2F11%2F21%2F%E4%BD%BF%E7%94%A8Spring%E5%8F%91%E9%80%81JMS%E6%B6%88%E6%81%AF%2F</url>
      <content type="text"><![CDATA[ActiveMQ官方推荐博客:原文Recently I stumbled upon a number of places in the some docs and mailing lists where claims are made that the Spring JmsTemplate is full of anti-patterns, is horribly inefficient and shouldn’t be used. Well I’m here to debunk these erroneous claims by pointing out a class in the Spring Framework that was overlooked entirely. 最近我偶然发现一些文档和邮件列表中一些地方声称Spring JmsTemplate充满了反模式，是非常低效的，不应该使用。 我在这里通过指出一个在Spring框架中被完全忽略的类来破解这些错误的观点。 The Spring JmsTemplate is a convenience class for sending and receiving JMS messages in a synchronous manner. The JmsTemplate was originally designed to be used with a J2EE container where the container provides the necessary pooling of the JMS resources (i.e., connections, consumers and producers). Such requirements came from the EJB spec. But when developers began using the JmsTemplate outside of J2EE containers, and because some JMS providers do not offer caching/pooling of JMS resources, a different solution was necessary. Enter the Spring CachingConnectionFactory. Spring JmsTemplate是一个方便的类，用于以同步方式发送和接收JMS消息。 JmsTemplate最初设计为与J2EE容器一起使用，其中容器为JMS资源(即，连接(connections)，消费者(consumers)和生产者(producers))提供必要的池。 这些要求来自EJB规范。 但是当开发人员开始在J2EE容器之外使用JmsTemplate时，因为一些JMS提供者不提供JMS资源的缓存/池化，所以需要一个不同的解决方案。 这就是Spring CachingConnectionFactory。 The CachingConnectionFactory is meant to wrap a JMS provider’s connection to provide caching of sessions, connections and producers as well as automatic connection recovery. By default, it uses a single session to create many connections and this model works very well with most MOMs. But if you need to scale further, you can also specify the number of sessions to cache using the sessionCacheSize property. CachingConnectionFactory意在包装JMS提供者的连接用于提供会话(sessions)，连接(connections)和生产者(producers)的缓存以及自动连接恢复。 默认情况下，它使用单个会话(session)创建许多连接(connections)，并且此模型与大多数MOM非常相配。 但是，如果您需要进一步扩展，您还可以使用sessionCacheSize属性指定要缓存的会话数。 Below is a snippet from a Spring app context that demonstrates the configuration for the CachingConnectionFactory 下面是一个来自Spring应用程序上下文的代码片段，演示了CachingConnectionFactory的配置12345678910111213141516171819202122&lt;!-- A connection to ActiveMQ --&gt;&lt;bean id=&quot;amqConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; p:brokerURL=&apos;tcp://localhost:61616&quot; /&gt;&lt;!-- A cached connection to wrap the ActiveMQ connection --&gt;&lt;bean id=&quot;cachedConnectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot; p:targetConnectionFactory-ref=&quot;amqConnectionFactory&quot; p:sessionCacheSize=&quot;10&quot; /&gt;&lt;!-- A destination in ActiveMQ --&gt;&lt;bean id=&quot;destination&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;&lt;constructor-arg value=&quot;FOO.TEST&quot; /&gt;&lt;/bean&gt;&lt;!-- A JmsTemplate instance that uses the cached connection and destination --&gt;&lt;bean id=&quot;producerTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot; p:connectionFactory-ref=&quot;cachedConnectionFactory&quot; p:defaultDestination-ref=&quot;destination&quot; /&gt; As you can see, the configuration for the CachingConnectionFactory along with the JmsTemplate is quite simple. Furthermore, these two classes are also both in the org.springframework.jms package path so they’re both included in the spring-jms.jar file making their use even easier. 如您所见，CachingConnectionFactory和JmsTemplate的配置非常简单。 此外，这两个类也都在org.springframework.jms包路径中，因此它们都包含在spring-jms.jar文件中，使它们的使用更加容易。 The only thing left to do is utilize the jmsTemplate bean in your Java code to actually send a message. This is shown below: 剩下唯一要做的就是在Java代码中使用jmsTemplate bean来实际发送消息。 如下所示：12345678910111213141516171819202122232425public class SimpleMessageProducer &#123; static final Logger LOG = Logger.getLogger(SimpleMessageProducer.class); @Autowired protected JmsTemplate jmsTemplate; protected int numberOfMessages = 100; public void sendMessages() throws JMSException &#123; StringBuilder payload = null; for (int i = 0; i &lt; numberOfMessages; ++i) &#123; payload = new StringBuilder(); payload.append(&quot;Message [&quot;).append(i).append(&quot;] sent at: &quot;).append(new Date()); jmsTemplate.send(new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; TextMessage message = session.createTextMessage(payload.toString()); message.setIntProperty(&quot;messageCount&quot;, i); LOG.info(&quot;Sending message number [&quot; + i + &quot;]&quot;); return message; &#125; &#125;); &#125; &#125;&#125; The SimpleMessageProducer class above demonstrates the use of Spring autowiring to resolve the relationship between the jmsTemplate property and the producerTemplate in the app context further above. Then an anonymous MessageCreator instance is used to actually create a message for the jmsTemplate to send. 上面的SimpleMessageProducer类演示了使用Spring自动装配来解决上述应用程序上下文中jmsTemplate属性和producerTemplate之间的关系。 然后使用一个匿名的MessageCreator实例来实际创建一个消息，供jmsTemplate发送。 The JmsTemplate and the CachingConnectionFactory are both very widely used in businesses of all sizes throughout the world. Coupled with one of the Spring message listener containers, they provide an ideal solution. JmsTemplate和CachingConnectionFactory都广泛应用于世界各地的各种规模的企业。 加上一个Spring消息侦听器容器，它们提供了一个理想的解决方案。 I’ll elaborate on message consumption using the Spring DefaultMessageListenerContainer and the SimpleMessageListenerContainer in a future blog post. 我将在未来的博客文章中使用Spring DefaultMessageListenerContainer和SimpleMessageListenerContainer详细说明消息消费。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Synchronous Request Response with ActiveMQ and Spring]]></title>
      <url>%2F2016%2F11%2F20%2FSynchronous%20Request%20Response%20with%20ActiveMQ%20and%20Spring%2F</url>
      <content type="text"><![CDATA[ActiveMQ官方推荐博客:Synchronous Request Response with ActiveMQ and Spring 原文A few months ago I did a deep dive into Efficient Lightweight JMS with Spring and ActiveMQ where I focused on the details for asynchronous sending and receiving of messages. In an ideal world all messaging would be asynchronous. If you need a response then you should set up an asynchronous listener and either have enough state stored in the service or in the message that you can continue processing once the response has been received. However, when ideals lead to complexity, we have to make the decision of how much complexity can we tolerate for the performance we need. Sometimes it just makes more sense to use a synchronous request/response. 几个月前，我对使用Spring和ActiveMQ实现高效轻量的JMS进行了深入的研究，其中我专注于异步发送和接收消息的细节。 在理想的世界里，所有的消息都是异步的。 如果您需要响应，那么您应该设置一个异步侦听器，并且有足够的状态存储在服务或消息中，您可以在收到响应后继续处理。 然而，当理想导致复杂性时，我们必须做出决定，为了需要的性能我们可以容忍多少复杂性。 有时，使用同步请求/响应更有意义。 Request Response with JMSActiveMQ documentation actually has a pretty good overview of how request-response semantics work in JMS. ActiveMQ文档实际上对如何在JMS中请求响应有一个很好的概述。 You might think at first that to implement request-response type operations in JMS that you should create a new consumer with a selector per request; or maybe create a new temporary queue per request. 您可能首先想到在JMS中实现请求 - 响应类型操作，您应该为每个请求创建一个带有选择器的新使用者(consumer); 或者可以为每个请求创建一个新的临时队列。 Creating temporary destinations, consumers, producers and connections are all synchronous request-response operations with the broker and so should be avoided for processing each request as it results in lots of chat with the JMS broker. 创建临时目标，使用者，生产者和连接都是与代理的同步请求 - 响应操作，因此应避免处理每个请求，因为它导致与JMS代理的大量聊天。 The best way to implement request-response over JMS is to create a temporary queue and consumer per client on startup, set JMSReplyTo property on each message to the temporary queue and then use a correlationID on each message to correlate request messages to response messages. This avoids the overhead of creating and closing a consumer for each request (which is expensive). It also means you can share the same producer &amp; consumer across many threads if you want (or pool them maybe). 通过JMS实现请求 - 响应的最佳方式是在启动时创建临时队列和每个客户端的消费者，将每个消息的JMSReplyTo属性设置为临时队列，然后对每个消息使用correlationID将请求消息与响应消息相关联。 这避免了为每个请求创建和关闭消费者(这是昂贵的)的开销。 这也意味着你可以共享相同的生产者和消费者跨多个线程，如果你想(或可能池)。 This is a pretty good start but it requires some tweaking to work best in Spring. It also should be noted that Lingo and Camel are also suggested as options when using ActiveMQ. In my previous post I addressed why I don’t use either of these options. In short Camel is more power than is needed for basic messaging and Lingo is built on Jencks, neither of which have been updated in years. 这是一个很好的开始，但它需要在Spring中做一些调整以最好的工作。 还应当注意，当使用ActiveMQ时，Lingo和Camel也被建议为选项。 在我的上一篇文章中，我解决了为什么我不使用这些选项。 简而言之，Camel是比基本消息所需要的更多的能量，而Lingo是建立在Jencks上的，这两者都不是多年来更新的。 Request Response in SpringThe first thing to notice is that its infeasible to create a consumer and temporary queue per client in Spring since pooling resources is required overcome the JmsTemplate gotchas. To get around this, I suggest using predefined request and response queues, removing the overhead of creating a temporary queue for each request/response. To allow for multiple consumers and producers on the same queue the JMSCorrelationId is used to correlated the request with its response message. 首先要注意的是，在Spring中为每个客户端创建一个消费者(consumer)和临时队列是不可行的，因为需要池资源来克服JmsTemplate陷阱。 为了解决这个问题，我建议使用预定义的请求和响应队列，消除为每个请求/响应创建临时队列的开销。 为了允许同一队列上的多个消费者(consumers)和生产者(producers)，JMSCorrelationId用于将请求与其响应消息相关联。 At this point I implemented the following naive solution: 在这一点上，我实现了以下天真的解决方案：12345678910111213141516171819202122232425262728293031@Componentpublic class Requestor &#123; private static final class CorrelationIdPostProcessor implements MessagePostProcessor &#123; private final String correlationId; public CorrelationIdPostProcessor( final String correlationId ) &#123; this.correlationId = correlationId; &#125; @Override public Message postProcessMessage( final Message msg ) throws JMSException &#123; msg.setJMSCorrelationID( correlationId ); return msg; &#125; &#125; private final JmsTemplate jmsTemplate; @Autowired public RequestGateway( JmsTemplate jmsTemplate ) &#123; this.jmsTemplate = jmsTemplate; &#125; public String request( final String request, String queue ) throws IOException &#123; final String correlationId = UUID.randomUUID().toString(); jmsTemplate.convertAndSend( queue+&quot;.request&quot;, request, new CorrelationIdPostProcessor( correlationId ) ); return (String) jmsTemplate.receiveSelectedAndConvert( queue+&quot;.response&quot;, &quot;JMSCorrelationID=&apos;&quot; + correlationId + &quot;&apos;&quot; ); &#125;&#125; This worked for a while until the system started occasionally timing out when making a request against a particularly fast responding service. After some debugging it became apparent that the service was responding so quickly that the receive() call was not fully initialized, causing it to miss the message. Once it finished initializing, it would wait until the timeout and fail. Unfortunately, there is very little in the way of documentation for this and the best suggestion I could find still seemed to leave open the possibility for the race condition by creating the consumer after sending the message. Luckily, according to the JMS spec, a consumer becomes active as soon as it is created and, assuming the connection has been started, it will start consuming messages. This allows for the reordering of the method calls leading to the slightly more verbose but also more correct solution. (NOTE: Thanks to Aaron Korver for pointing out that ProducerConsumer needs to implement SessionCallback and that true needs to be passed to the JmsTemplate.execute() for the connection to be started.) 这工作了一段时间，直到系统在针对特别快速响应的服务发出请求时偶尔超时。在一些调试之后，很明显，服务响应如此之快，以至于receive()调用没有完全初始化，导致它错过了消息。一旦它完成初始化，它将等待，直到超时和失败。不幸的是，在这方面的文档的很少，我可以发现最好的建议通过在发送消息后创建消费者似乎仍然留下了开放的竞争条件的可能性。幸运的是，根据JMS规范，消费者在它被创建时就变成活动的，并假设连接已经开始，它将开始消费消息。这允许方法调用重新排序，虽然导致略微冗长，但也是更正确的解决方案。 (注意：感谢Aaron Korver指出ProducerConsumer需要实现SessionCallback，并且true需要传递到JmsTemplate.execute()，以便连接被启动。)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Componentpublic class Requestor &#123; private static final class ProducerConsumer implements SessionCallback&lt;Message&gt; &#123; private static final int TIMEOUT = 5000; private final String msg; private final DestinationResolver destinationResolver; private final String queue; public ProducerConsumer( final String msg, String queue, final DestinationResolver destinationResolver ) &#123; this.msg = msg; this.queue = queue; this.destinationResolver = destinationResolver; &#125; public Message doInJms( final Session session ) throws JMSException &#123; MessageConsumer consumer = null; MessageProducer producer = null; try &#123; final String correlationId = UUID.randomUUID().toString(); final Destination requestQueue = destinationResolver.resolveDestinationName( session, queue+&quot;.request&quot;, false ); final Destination replyQueue = destinationResolver.resolveDestinationName( session, queue+&quot;.response&quot;, false ); // Create the consumer first! consumer = session.createConsumer( replyQueue, &quot;JMSCorrelationID = &apos;&quot; + correlationId + &quot;&apos;&quot; ); final TextMessage textMessage = session.createTextMessage( msg ); textMessage.setJMSCorrelationID( correlationId ); textMessage.setJMSReplyTo( replyQueue ); // Send the request second! producer = session.createProducer( requestQueue ); producer.send( requestQueue, textMessage ); // Block on receiving the response with a timeout return consumer.receive( TIMEOUT ); &#125; finally &#123; // Don&apos;t forget to close your resources JmsUtils.closeMessageConsumer( consumer ); JmsUtils.closeMessageProducer( producer ); &#125; &#125; &#125; private final JmsTemplate jmsTemplate; @Autowired public Requestor( final JmsTemplate jmsTemplate ) &#123; this.jmsTemplate = jmsTemplate; &#125; public String request( final String request, String queue ) &#123; // Must pass true as the second param to start the connection return (String) jmsTemplate.execute( new ProducerConsumer( msg, queue, jmsTemplate.getDestinationResolver() ), true ); &#125;&#125; About PoolingOnce the request/response logic was correct it was time to load test. Almost instantly, memory usage exploded and the garbage collector started thrashing. Inspecting ActiveMQ with the Web Console showed that MessageConsumers were hanging around even though they were being explicitly closed using Spring’s own JmsUtils. Turns out, the CachingConnectionFactory‘s JavaDoc held the key to what was going on: “Note also that MessageConsumers obtained from a cached Session won’t get closed until the Session will eventually be removed from the pool.” However, if the MessageConsumers could be reused this wouldn’t be an issue. Unfortunately, CachingConnectionFactory caches MessageConsumers based on a hash key which contains the selector among other values. Obviously each request/response call, with its necessarily unique selector, was creating a new consumer that could never be reused. Luckily ActiveMQ provides a PooledConnectionFactory which does not cache MessageConsumers and switching to it fixed the problem instantly. However, this means that each request/response requires a new MessageConsumer to be created. This is adds overhead but its the price that must be payed to do synchronous request/response. 一旦请求/响应逻辑正确，它就加载测试。几乎立即，内存使用爆炸，垃圾收集器开始抖动。使用Web控制台检查ActiveMQ显示MessageConsumers挂起，即使他们正在使用Spring的JmsUtils也被显式关闭。事实证明，CachingConnectionFactory的JavaDoc保存了所发生的事：“还要注意，从缓存的会话(Session)中获得的MessageConsum不会关闭，直到会话(Session)最终从池中删除”。然而，如果MessageConsumers可以被重用,这就不是一个问题。不幸的是，CachingConnectionFactory根据含有其他值中的选择器(selector)的哈希键来缓存MessageConsumers。显然，每个请求/响应调用，必然有唯一的选择器(selector)，正在创建一个新的消费者consumer，永远不能重复使用。幸运的是ActiveMQ提供了一个PooledConnectionFactory，它不缓存MessageConsumers,切换到它可立即解决问题。但是，这意味着每个请求/响应都需要创建一个新的MessageConsumer,这增加了开销，但为了同步请求/响应必须付出这个代价。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Logging]]></title>
      <url>%2F2016%2F11%2F20%2FSpring%20Logging%2F</url>
      <content type="text"><![CDATA[Spring日志 version:5.0.0 LoggingLogging is a very important dependency for Spring because a) it is the only mandatory external dependency, b) everyone likes to see some output from the tools they are using, and c) Spring integrates with lots of other tools all of which have also made a choice of logging dependency. One of the goals of an application developer is often to have unified logging configured in a central place for the whole application, including all external components. This is more difficult than it might have been since there are so many choices of logging framework. 对于 Spring 日志是非常重要的依赖，因为：a）它是唯一的外部强制性的依赖；b）每个人都喜欢从他们使用的工具看到一些输出；c）Spring 结合很多其他工具都选择了日志依赖。应用开发者的一个目标就是往往是有统一的日志配置在一个中心位置为了整个应用程序，包括所有的外部元件。这就更加困难，因为它可能已经有太多选择的日志框架。 The mandatory logging dependency in Spring is the Jakarta Commons Logging API (JCL). We compile against JCL and we also make JCL Log objects visible for classes that extend the Spring Framework. It’s important to users that all versions of Spring use the same logging library: migration is easy because backwards compatibility is preserved even with applications that extend Spring. The way we do this is to make one of the modules in Spring depend explicitly on commons-logging (the canonical implementation of JCL), and then make all the other modules depend on that at compile time. If you are using Maven for example, and wondering where you picked up the dependency on commons-logging, then it is from Spring and specifically from the central module called spring-core. Spring 强制性的日志依赖 是 Jakarta Commons Logging API（JCL）。我们编译 JCL，也使得 JCL Log对象对 Spring Framework 的扩展类可见。所有版本的 Spring 使用同样的日志库，这对于用户来说是很重要的：迁移就会变得容易向后兼容性，即使扩展 Spring的应用程序。我们这样做是为了是 Spring 的模块之一明确依赖 commons-logging (JCL的典型实现)，然后是的其他的所有模块在编译的时候都依赖它。如果你使用 Maven 为例，在你想拿起依赖 commons-logging ，这个是来自 Spring 的并且明确来自中心模块 spring-core。 The nice thing about commons-logging is that you don’t need anything else to make your application work. It has a runtime discovery algorithm that looks for other logging frameworks in well known places on the classpath and uses one that it thinks is appropriate (or you can tell it which one if you need to). If nothing else is available you get pretty nice looking logs just from the JDK (java.util.logging or JUL for short). You should find that your Spring application works and logs happily to the console out of the box in most situations, and that’s important. 关于 commons-logging 的好处是你不需要任何东西就能让你的应用程序程序跑起来。它运行时有一个发现算法，该算法在类路径的所有地方寻找其他的日志框架并且使用它认为适合的（或者你可以告诉它你需要的是哪一个）。如果没有其他的日志框架存在，你可以从JDK（Java.util.logging 或者JUL 的简称）获得日志。在大多数情况下，你可以在控制台查看你的Spring 应用程序工作和日志，并且这是很重要的。 Not Using Commons LoggingUnfortunately, the runtime discovery algorithm in commons-logging, while convenient for the end-user, is problematic. If we could turn back the clock and start Spring now as a new project it would use a different logging dependency. The first choice would probably be the Simple Logging Facade for Java ( SLF4J), which is also used by a lot of other tools that people use with Spring inside their applications. 不幸的，在 commons-logging 里运行时发现算法，方便最终用户,是有问题的。如果我们能够时光倒流，现在从新开始 Spring 项目并且他使用了不同的日志依赖。第一个选择很可能是Simple Logging Facade for Java ( SLF4J)，过去也曾被许多其他工具通过 Spring 使用在他们的应用程序。 There are basically two ways to switch off commons-logging: Exclude the dependency from the spring-core module (as it is the only module that explicitly depends on commons-logging) Depend on a special commons-logging dependency that replaces the library with an empty jar (more details can be found in the SLF4J FAQ) 基本上有两种方法可以关闭commons-logging： 通过 spring-core 模块排除依赖（因为它是唯一的显示依赖于 commons-logging 的模块）。 依赖特殊的 commons-logging 依赖，用空的jar（更多的细节可以在SLF4J FAQ中找到）替换掉库。 To exclude commons-logging, add the following to your dependencyManagement section: 排除 commons-logging，添加以下的内容到 dependencyManagement 部分：12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.0.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Now this application is probably broken because there is no implementation of the JCL API on the classpath, so to fix it a new one has to be provided. In the next section we show you how to provide an alternative implementation of JCL using SLF4J as an example. 现在，这个应用程序可以打破，因为在类路径上没有实现 JCL API，因此要修复它就必须提供有一个新的。在下一节我们将向你展示如何提供另一种实现 JCL，使用 SLF4J 作为例子的另一种实现。 Using SLF4JSLF4J is a cleaner dependency and more efficient at runtime than commons-logging because it uses compile-time bindings instead of runtime discovery of the other logging frameworks it integrates. This also means that you have to be more explicit about what you want to happen at runtime, and declare it or configure it accordingly. SLF4J provides bindings to many common logging frameworks, so you can usually choose one that you already use, and bind to that for configuration and management. SLF4J 是一个更加简洁的依赖，在运行时相对于 commons-logging 更加的有效因为它使用编译时绑定来代替运行时发现其他日志框架的集成。这也意味着，你不得不更加明确你想在运行时发生什么，并相应的声明它或者配置它。SLF4J 提供绑定很多的常见日志框架，因此你可以选择一个你已经使用的，并且绑定到配置和管理。 SLF4J provides bindings to many common logging frameworks, including JCL, and it also does the reverse: bridges between other logging frameworks and itself. So to use SLF4J with Spring you need to replace the commons-logging dependency with the SLF4J-JCL bridge. Once you have done that then logging calls from within Spring will be translated into logging calls to the SLF4J API, so if other libraries in your application use that API, then you have a single place to configure and manage logging. SLF4J 提供了绑定很多的常见日志框架，包括 JCL，它也做了反向工作:是其他日志框架和它自己之间的桥梁。因此在 Spring 中使用 SLF4J 时，你需要使用 SLF4J-JCL 桥接替换掉 commons-logging 的依赖。一旦你这么做了，Spring 调用日志就会调用 SLF4J API，因此如果在你的应用程序中的其他库使用这个API，那么你就需要有个地方配置和管理日志。 A common choice might be to bridge Spring to SLF4J, and then provide explicit binding from SLF4J to Log4J. You need to supply 4 dependencies (and exclude the existing commons-logging): the bridge, the SLF4J API, the binding to Log4J, and the Log4J implementation itself. In Maven you would do that like this 一个常见的选择就是桥接 Spring 和 SLF4J，提供显示的绑定 SLF4J 到Log4J 上。你需要支持 4 个的依赖（排除现有的 commons-logging）：桥接，SLF4J API，绑定 Log4J 和 Log4J 实现自身。在 Maven 中你可以这样做：123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.0.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; That might seem like a lot of dependencies just to get some logging. Well it is, but it is optional, and it should behave better than the vanilla commons-logging with respect to classloader issues, notably if you are in a strict container like an OSGi platform. Allegedly there is also a performance benefit because the bindings are at compile-time not runtime. 这似乎是一个很大的依赖性，其仅仅是为了得到一些日志文件。那就这样吧，但是它是可选的，它在关于类加载器的问题上应该比 commons-logging 表现的更加的好，值得注意的是，如果你在一个严格的容器中像OSGi 平台。据说也有一个性能优势应为绑定是在编译时而不是在运行时。 A more common choice amongst SLF4J users, which uses fewer steps and generates fewer dependencies, is to bind directly to Logback. This removes the extra binding step because Logback implements SLF4J directly, so you only need to depend on two libraries not four ( jcl-over-slf4j and logback). If you do that you might also need to exclude the slf4j-api dependency from other external dependencies (not Spring), because you only want one version of that API on the classpath. SLF4J 是用户中一个常见的选择，使用它可以更少的步骤和产生更少的依赖，直接绑定 Logback。这消除了多余的绑定步骤，因为 Logback 直接实现了 SLF4J，因此你只需要依赖两个库而不是4个（jcl-over-slf4j 和 logback）。如果你这样做，你可能还需要从其他外部依赖（不是 Spring）排除 slf4j-api 依赖，因为在类路径中你只需要一个版本的API。 Using Log4JMany people use Log4j as a logging framework for configuration and management purposes. It’s efficient and well-established, and in fact it’s what we use at runtime when we build and test Spring. Spring also provides some utilities for configuring and initializing Log4j, so it has an optional compile-time dependency on Log4j in some modules. 许多人使用 Log4j 作为日志框架，用于配置和管理的目的。它是有效的和完善的，事实上这也是我们在运行时使用的，当我们构架和测试 Spring 时。Spring 也提供一些配置和初始化 Log4j 的工具，因此在某些模块上它有一个可选的编译时依赖在 Log4j。 To make Log4j work with the default JCL dependency ( commons-logging) all you need to do is put Log4j on the classpath, and provide it with a configuration file ( log4j.properties or log4j.xml in the root of the classpath). So for Maven users this is your dependency declaration: 为了使 Log4j 工作在默认的 JCL 依赖下（commons-logging），所有你需要做的事就是把 Log4j 放到类路径下，为它提供配置文件(log4j.properties 或者 log4j.xml 在类路径的根目录下)。因此对于Maven 用户这就是你的依赖声明：123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.0.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; And here’s a sample log4j.properties for logging to the console: 下面是一个 log4j.properties 的实例，用于将日志打印到控制台：1234567log4j.rootCategory=INFO, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %t %c&#123;2&#125;:%L - %m%nlog4j.category.org.springframework.beans.factory=DEBUG Runtime Containers with Native JCLMany people run their Spring applications in a container that itself provides an implementation of JCL. IBM Websphere Application Server (WAS) is the archetype. This often causes problems, and unfortunately there is no silver bullet solution; simply excluding commons-logging from your application is not enough in most situations. 很多的人在提供 JCL 实现的容器下运行他们的 Spring 应用程序。IBM Websphere Application Server (WAS)为例。这样往往会导致问题，遗憾的是没有一个一劳永逸的解决方案；简单的包含 commons-logging 在大多数情况下是不够的。 To be clear about this: the problems reported are usually not with JCL per se, or even with commons-logging: rather they are to do with binding commons-logging to another framework (often Log4J). This can fail because commons-logging changed the way they do the runtime discovery in between the older versions (1.0) found in some containers and the modern versions that most people use now (1.1). Spring does not use any unusual parts of the JCL API, so nothing breaks there, but as soon as Spring or your application tries to do any logging you can find that the bindings to Log4J are not working. 要清楚这一点：问题报告通常不是 JCL 本身，或者 commons-logging：相反，他们是绑定 commons-logging 到其他的框架（通常是 Log4j ）。这可能会失败，因为commons-logging改变了路径，当他们运行时发现在一些容器中找到了老版本（1.0）并且现在大多数人使用的现代版本(1.1)。Spring 不使用 JCL API 任何不常见的模块，所以没有什么问题出现，但是很快 Spring 或者你的应用程序视图做一些日志时，你会发现绑定的 Log4j 不工作了。 In such cases with WAS the easiest thing to do is to invert the class loader hierarchy (IBM calls it “parent last”) so that the application controls the JCL dependency, not the container. That option isn’t always open, but there are plenty of other suggestions in the public domain for alternative approaches, and your mileage may vary depending on the exact version and feature set of the container. 在这种情况下，WAS 最容易的是转化类加载器的层次结构（IBM 称之为“parent last”），使应用程序控制 JCL 的依赖关系，而不是容器。该选项不是总是开放的，但是有很多其他的建议在公共领域的替代方法，你的里程可能取决于确切的版本和特定的容器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSR 303 - Bean Validation 介绍及最佳实践]]></title>
      <url>%2F2016%2F11%2F20%2FJSR%20303%20-%20Bean%20Validation%20%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[JSR 303 – Bean Validation 是一个数据验证的规范，2009 年 11 月确定最终方案。2009 年 12 月 Java EE 6 发布，Bean Validation 作为一个重要特性被包含其中。本文将对 Bean Validation 的主要功能进行介绍，并通过一些示例来演示如何在 Java 开发过程正确的使用 Bean Validation。 关于 Bean Validation在任何时候，当你要处理一个应用程序的业务逻辑，数据校验是你必须要考虑和面对的事情。应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。在通常的情况下，应用程序是分层的，不同的层由不同的开发人员来完成。很多时候同样的数据验证逻辑会出现在不同的层，这样就会导致代码冗余和一些管理的问题，比如说语义的一致性等。为了避免这样的情况发生，最好是将验证逻辑与相应的域模型进行绑定。 Bean Validation 为 JavaBean 验证定义了相应的元数据模型和 API。缺省的元数据是 Java Annotations，通过使用 XML 可以对原有的元数据信息进行覆盖和扩展。在应用程序中，通过使用 Bean Validation 或是你自己定义的 constraint，例如 @NotNull, @Max, @ZipCode， 就可以确保数据模型（JavaBean）的正确性。constraint 可以附加到字段，getter 方法，类或者接口上面。对于一些特定的需求，用户可以很容易的开发定制化的 constraint。Bean Validation 是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回。 下载 JSR 303 – Bean Validation 规范 http://jcp.org/en/jsr/detail?id=303 Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。如果想了解更多有关 Hibernate Validator 的信息，请查看 http://www.hibernate.org/subprojects/validator.html Bean Validation 中的 constraint表 1. Bean Validation 中内置的 constraint Constraint 详细信息 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 表 2. Hibernate Validator 附加的 constraint Constraint 详细信息 @Email 被注释的元素必须是电子邮箱地址 @Length 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range 被注释的元素必须在合适的范围内 一个 constraint 通常由 annotation 和相应的 constraint validator 组成，它们是一对多的关系。也就是说可以有多个 constraint validator 对应一个 annotation。在运行时，Bean Validation 框架本身会根据被注释元素的类型来选择合适的 constraint validator 对数据进行验证。 有些时候，在用户的应用中需要一些更复杂的 constraint。Bean Validation 提供扩展 constraint 的机制。可以通过两种方法去实现，一种是组合现有的 constraint 来生成一个更复杂的 constraint，另外一种是开发一个全新的 constraint。 创建一个包含验证逻辑的简单应用（基于 JSP）在本文中，通过创建一个虚构的订单管理系统（基于 JSP 的 web 应用）来演示如何在 Java 开发过程中应用 Bean Validation。该简化的系统可以让用户创建和检索订单。 系统设计和运用的技术图 1. 系统架构 图 1 是报表管理系统的结构图，是典型的 MVC（Model-View-Controller）应用。Controller 负责接收和处理请求，Servlet 扮演 Controller 的角色去处理请求、业务逻辑并转向合适的 JSP 页面。在 Servlet 中对数据进行验证。JSP 扮演 View 的角色以图型化界面的方式呈现 Model 中的数据方便用户交互。Model 就是此系统进行操作的数据模型，我们对这部分加以简化不对数据进行持久化。 数据模型图 2. 数据模型 图 2 展示的是订单管理系统的数据模型。 声明了 contraint 的 JavaBean清单 1. Order.java1234567891011121314151617181920212223242526272829public class Order &#123; // 必须不为 null, 大小是 10 @NotNull @Size(min = 10, max = 10) private String orderId; // 必须不为空 @NotEmpty private String customer; // 必须是一个电子信箱地址 @Email private String email; // 必须不为空 @NotEmpty private String address; // 必须不为 null, 必须是下面四个字符串&apos;created&apos;, &apos;paid&apos;, &apos;shipped&apos;, &apos;closed&apos;其中之一 // @Status 是一个定制化的 contraint @NotNull @Status private String status; // 必须不为 null @NotNull private Date createDate; // 嵌套验证 @Valid private Product product;… getter 和 setter &#125; 清单 2. Product.java1234567891011 public class Product &#123; // 必须非空 @NotEmpty private String productName; // 必须在 8000 至 10000 的范围内 // @Price 是一个定制化的 constraint @Price private float price;… Getter 和 setter &#125; 清单 3. OrderQuery.java123456789 // &apos;to&apos;所表示的日期必须在&apos;from&apos;所表示的日期之后 // @QueryConstraint 是一个定制化的 constraint @QueryConstraint public class OrderQuery &#123; private Date from; private Date to;… omitted … Getter and setter &#125; 定制化的 constraint @Price是一个定制化的 constraint，由两个内置的 constraint 组合而成。 清单 4. @Price 的 annotation 部分123456789101112// @Max 和 @Min 都是内置的 constraint@Max(10000)@Min(8000)@Constraint(validatedBy = &#123;&#125;)@Documented@Target( &#123; ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Price &#123;String message() default &quot;错误的价格&quot;;Class&lt;?&gt;[] groups() default &#123;&#125;;Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; @Status是一个新开发的 constraint. 清单 5. @Status 的 annotation 部分123456789@Constraint(validatedBy = &#123;StatusValidator.class&#125;)@Documented@Target( &#123; ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Status &#123;String message() default &quot;不正确的状态 , 应该是 &apos;created&apos;, &apos;paid&apos;, shipped&apos;, closed&apos;其中之一&quot;;Class&lt;?&gt;[] groups() default &#123;&#125;;Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 清单 6. @Status 的 constraint validator 部分12345678910public class StatusValidator implements ConstraintValidator&lt;Status, String&gt;&#123; private final String[] ALL_STATUS = &#123;&quot;created&quot;, &quot;paid&quot;, &quot;shipped&quot;, &quot;closed&quot;&#125;; public void initialize(Status status) &#123; &#125; public boolean isValid(String value, ConstraintValidatorContext context) &#123; if(Arrays.asList(ALL_STATUS).contains(value)) return true; return false; &#125;&#125; Bean Validation API 使用示例创建订单用户在创建一条订单记录时，需要填写以下信息：订单编号，客户，电子信箱，地址，状态，产品名称，产品价格 图 3. 创建订单 对这些信息的校验，使用 Bean Validation API 清单 7. 代码片段12345678910111213141516171819202122232425262728293031323334353637383940414243protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); // 从 request 中获取输入信息 String orderId = (String) req.getParameter(&quot;orderId&quot;); String customer = (String) req.getParameter(&quot;customer&quot;); String email = (String) req.getParameter(&quot;email&quot;); String address = (String) req.getParameter(&quot;address&quot;); String status = (String) req.getParameter(&quot;status&quot;); String productName = (String) req.getParameter(&quot;productName&quot;); String productPrice = (String) req.getParameter(&quot;productPrice&quot;); // 将 Bean 放入 session 中 Order order = new Order(); order.setOrderId(orderId); order.setCustomer(customer); order.setEmail(email); order.setAddress(address); order.setStatus(status); order.setCreateDate(new Date()); Product product = new Product(); product.setName(productName); if(productPrice != null &amp;&amp; productPrice.length() &gt; 0) product.setPrice(Float.valueOf(productPrice)); order.setProduct(product); session.setAttribute(&quot;order&quot;, order); ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); Validator validator = factory.getValidator(); Set&lt;ConstraintViolation&lt;Order&gt;&gt; violations = validator.validate(order); if(violations.size() == 0) &#123; session.setAttribute(&quot;order&quot;, null); session.setAttribute(&quot;errorMsg&quot;, null); resp.sendRedirect(&quot;creatSuccessful.jsp&quot;); &#125; else &#123; StringBuffer buf = new StringBuffer(); ResourceBundle bundle = ResourceBundle.getBundle(&quot;messages&quot;); for(ConstraintViolation&lt;Order&gt; violation: violations) &#123; buf.append(&quot;-&quot; + bundle.getString(violation.getPropertyPath().toString())); buf.append(violation.getMessage() + &quot;&lt;BR&gt;\n&quot;); &#125; session.setAttribute(&quot;errorMsg&quot;, buf.toString()); resp.sendRedirect(&quot;createOrder.jsp&quot;); &#125; &#125; 如果用户不填写任何信息提交订单，相应的错误信息将会显示在页面上 图 4. 验证后返回错误信息 其实在整个程序的任何地方都可以调用 JSR 303 API 去对数据进行校验，然后将校验后的结果返回。 清单 8. 调用 JSR 303 API 进行校验123456 Order order = new Order();… ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); Validator validator = factory.getValidator(); Set&lt;ConstraintViolation&lt;Order&gt;&gt; violations = validator.validate(order);… 结束语JSR 303 的发布使得在数据自动绑定和验证变得简单，使开发人员在定义数据模型时不必考虑实现框架的限制。当然 Bean Validation 还只是提供了一些最基本的 constraint，在实际的开发过程中，用户可以根据自己的需要组合或开发出更加复杂的 constraint 转自:IBM文档库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringMVC中使用Hibernate Validator检验数据]]></title>
      <url>%2F2016%2F11%2F20%2FSpringMVC%E6%95%B0%E6%8D%AE%E6%A3%80%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[SpringMVC中使用Hibernate Validator检验数据 JSR 303介绍 JSR 303 用于对Java Bean中的字段的值进行验证,使得验证逻辑从业务代码中脱离出来 是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回 一般用于表单提交页面(如用户名必填、只能由数字字母组成等等) 注解类 注解 意思 @NotNull 注解元素必须是非空 @Null 注解元素必须是空 @Digits 验证数字构成是否合法 @Future 验证是否在当前系统时间之后 @Past 验证是否在当前系统时间之前 @Max 验证值是否小于等于最大指定整数值 @Min 验证值是否大于等于最小指定整数值 @Pattern 验证字符串是否匹配指定的正则表达式 @Size 验证元素大小是否在指定范围内 @DecimalMax 验证值是否小于等于最大指定小数值 @DecimalMin 验证值是否大于等于最小指定小数值 @AssertTrue 被注释的元素必须为true @AssertFalse 被注释的元素必须为false Hibernate ValidatorHibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。 扩展注解 注解 意思 @Email 被注释的元素必须是电子邮箱地址 @Length 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range 被注释的元素必须在合适的范围内 配置SpringMVC配置 SpringMVC 校验框架引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.1.3.Final&lt;/version&gt;&lt;/dependency&gt; 在SpringMVC配置文件中配置12345678&lt;mvc:annotation-driven validator=&quot;validator&quot; /&gt;&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt; &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot; /&gt; &lt;!-- 如果不加默认到 使用classpath下的 ValidationMessages.properties --&gt; &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot; /&gt;&lt;/bean&gt; 在JavaBean中进行配置123456789101112131415161718192021public class User implements Serializable &#123; @NotEmpty(message=&quot;&#123;NotEmpty.user.userName&#125;&quot;) private String userName ; @Pattern(regexp=&quot;[0-9a-zA-Z]&#123;6,30&#125;&quot;, message=&quot;&#123;Pattern.user.password&#125;&quot;) private String password ; @Length(min=2, max=100, message=&quot;&#123;Length.user.realName&#125;&quot;) private String realName ; @Email(message=&quot;&#123;Email.user.email&#125;&quot;) private String email ; @NotNull(message = &quot;&#123;NotNull.user.age&#125;&quot;) @Between(min = 18, max = 45) private Integer age ; ...getter and setter...&#125; 在Controller中进行配置1234567891011121314151617@RequestMapping(value = &quot;/doRegister&quot;, method = RequestMethod.POST)public String doLogin(@Valid User user, BindingResult result, ModelMap map)&#123; // 如果入参有问题，返回注册页面 if (result.hasErrors()) &#123; List&lt;FieldError&gt; errorList = result.getFieldErrors(); for(FieldError error : errorList)&#123; System.out.println(error.getField() + &quot;*&quot; + error.getDefaultMessage()); map.put(&quot;ERR_&quot; + error.getField(), error.getDefaultMessage()); &#125; return &quot;/jsp/register.jsp&quot;; &#125; // 省略注册代码 return &quot;/jsp/registersuccess.jsp&quot;;&#125; 获取校验结果校验结果保存在BindingResult或Errors对象中： 这两个类都位于org.springframework.validation包中 需校验的表单对象和其绑定结果对象或错误对象是成对出现的 Errors接口提供了获取错误信息的方法，如getErrorCount()获取错误的数量， getFieldErrors(String field)得到成员属性的校验错误列表 BindingResult接口扩展了Errors接口，以便可以使用Spring的org.springframeword.validation.Validator对数据进行校验，同时获取数据绑定结果对象的信息在JSP页面中显示错误123456789101112131415161718192021222324252627&lt;div style=&quot;margin:0 auto; padding-top: 100px;&quot; align=&quot;center&quot;&gt; &lt;form action=&quot;doRegister.html&quot; method=&quot;post&quot;&gt; &lt;p&gt; $&#123;ERR_userName &#125;&lt;br&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;/p&gt; &lt;p&gt; $&#123;ERR_password &#125;&lt;br&gt; &lt;span&gt;密 码：&lt;/span&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; $&#123;ERR_realName &#125;&lt;br&gt; &lt;span&gt;真实姓名：&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;realName&quot;&gt; &lt;/p&gt; &lt;p&gt; $&#123;ERR_email &#125;&lt;br&gt; &lt;span&gt;邮 箱：&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt; &lt;/p&gt; &lt;p&gt; $&#123;ERR_age &#125;&lt;br&gt; &lt;span&gt;年 龄：&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/p&gt; &lt;/form&gt;&lt;/div&gt; 国际化错误信息 新建资源文件messages.properties和messages_zh_CN.properties文件，内容如下：注意:文件中的键值对，值可通过JDK自带的native2ascii工具，将中文转换成对应的unicode编码。 123456Between.user.age=\u5E94\u8BE5\u5728&#123;min&#125;\u4E0E&#123;max&#125;\u4E4B\u95F4Pattern.user.password=\u5BC6\u7801\u662F6-30\u4E2A\u5B57\u7B26\uFF0C\u5FC5\u987B\u662F\u5B57\u6BCD\u6216\u6570\u5B57\u7EC4\u5408Length.user.realName=\u975E\u6CD5\u771F\u5B9E\u59D3\u540DNotEmpty.user.userName=\u7528\u6237\u540D\u4E0D\u80FD\u4E3A\u7A7AEmail.user.email=\u8BF7\u8F93\u5165\u6B63\u786E\u7684\u90AE\u4EF6\u5730\u5740NotNull.user.age=\u8BF7\u586B\u5199\u60A8\u7684\u5E74\u9F84 在SpringMVC配置文件中配置 123&lt;bean id=&quot;messageSource&quot;class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;p:basename=&quot;messages&quot; /&gt; 自定义校验规则 定义注解类，并使用Constraint注解标注，属性validatedBy指定校验实现类 1234567891011121314151617@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)@Retention(RUNTIME)@Documented@Constraint(validatedBy = &#123;BetweenValidator.class&#125;)public @interface Between &#123; String message() default &quot;&#123;Between.user.age&#125;&quot;; Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; int min(); int max();&#125; 定义实现类，需要集成ConstraintValidator接口，isValid方法负责校验 1234567891011121314151617181920212223public class BetweenValidator implements ConstraintValidator&lt;Between, Integer&gt;&#123; private int min ; private int max ; @Override public void initialize(Between annotation) &#123; min = annotation.min(); max = annotation.max(); &#125; @Override public boolean isValid(Integer value, ConstraintValidatorContext context) &#123; if (value == null) &#123; return false; &#125; if (value &gt;= min &amp;&amp; value &lt;= max) &#123; return true; &#125; return false; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ActiveMQ官方文档 -- Spring支持]]></title>
      <url>%2F2016%2F11%2F19%2FActiveMQ%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3--Spring%E6%94%AF%E6%8C%81%2F</url>
      <content type="text"><![CDATA[ActiveMQ官方文档 – Spring支持We fully support Spring for configuration of the JMS client side as well as for configuring the JMS Message Broker.There is a great article on using Spring with ActiveMQ - I’d recommend reading it first. 我们完全支持Spring配置JMS客户端以及配置JMS Message Broker。这是一个关于使用Spring与ActiveMQ非常棒的文章 – 我建议首先阅读它。 Configuring the JMS client 配置JMS客户端To configure an ActiveMQ JMS client in Spring it is just a simple matter of configuring an instance of ActiveMQConnectionFactory within a standard Spring XML configuration file like any other bean. There are several examples and test cases available and this one shows how to construct an ActiveMQConnectionFactory in Spring which is then passed into a Spring JmsTemplate for use by some POJOs. 要在Spring中配置ActiveMQ JMS客户端，只需在标准Spring XML配置文件（像配置其他bean一样）中配置ActiveMQConnectionFactory的实例即可。 有几个可用的例子和测试用例，这一个展示了如何在Spring中构造一个ActiveMQConnectionFactory，然后将其传递到一个Spring JmsTemplate，供一些POJO使用。 e.g. the following fragment of XML shows us creating a JMS connection factory for ActiveMQ connecting to a remote broker on a specific host name and port. 例如: 以下XML片段显示了我们为ActiveMQ创建一个JMS连接工厂，连接到特定主机名和端口上的远程代理。12345&lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; &lt;property name=&quot;brokerURL&quot;&gt; &lt;value&gt;tcp://localhost:61616&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; The following shows how to use Zeroconf to discover the available brokers to connect to. 下面显示如何使用Zeroconf来发现可用的代理连接。12345&lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; &lt;property name=&quot;brokerURL&quot;&gt; &lt;value&gt;zeroconf://_activemq.broker.development.&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; From 1.1 of ActiveMQ onwards you can also use JNDI to configure ActiveMQ within Spring. This example shows how to configure Spring using ActiveMQ’s JNDI Support. 从1.1的ActiveMQ开始，你也可以使用JNDI在Spring中配置ActiveMQ。 此示例显示如何使用ActiveMQ的JNDI支持配置Spring。 Using Spring 使用SpringIf you are using the new XML Schema-based configuration of Spring 2.0 you can embed the ActiveMQ broker XML inside any regular Spring.xml file without requiring the above factory bean. e.g. here is an example of a regular Spring XML file in Spring 2.0 which also configures a broker. 如果您使用Spring 2.0基于XML Schema的新配置，您可以在任何常规Spring.xml文件中嵌入ActiveMQ代理XML，而不需要上述工厂bean。 例如:这里是Spring 2.0中常规Spring XML文件的一个例子，它也配置了一个代理。123456789101112131415&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd&quot;&gt; &lt;amq:broker useJmx=&quot;false&quot; persistent=&quot;false&quot;&gt; &lt;amq:transportConnectors&gt; &lt;amq:transportConnector uri=&quot;tcp://localhost:0&quot; /&gt; &lt;/amq:transportConnectors&gt; &lt;/amq:broker&gt; &lt;amq:connectionFactory id=&quot;jmsFactory&quot; brokerURL=&quot;vm://localhost&quot;/&gt;&lt;/beans&gt; This allows you to configure JMS artifacts like destinations and connection factories together with the entire broker. 这允许您将JMS工件（如目标和连接工厂）与整个代理一起配置。 Working with Spring’s JmsTemplate 使用Spring的JmsTemplateSpring supports a handy abstraction, JmsTemplate, which allows you to hide some of the lower level JMS details when sending messages etc. Spring支持一个简便的抽象，JmsTemplate，它允许你在发送消息时隐藏一些低级的JMS细节。 Please be aware that there are a number of JmsTemplate Gotchas to be careful of. 请注意，对很多JmsTemplate Gotchas要小心。 One thing to bear in mind with JmsTemplate is that by default it will create a new connection, session, producer for each message sent - then close them all down again. This is very inefficient! It is done like this to work in EJB containers which tend to use a special ConnectionFactory which does pooling. JmsTemplate要记住的一件事是，默认情况下，它将为每个发送的消息创建一个新的连接(connection)，会话(session)，生产者(producer)，然后再次关闭它们。 这是非常低效！ 它在EJB容器倾向于使用一个特殊的ConnectionFactory池工作。 If you are not using a JCA container to manage your JMS connections, we recommend you use our pooling JMS connection provider, (org.apache.activemq.pool.PooledConnectionFactory) from the activemq-pool library, which will pool the JMS resources to work efficiently with Spring’s JmsTemplate or with EJBs. 如果不使用JCA容器来管理JMS连接，我们建议您从activemq-pool库中使用我们的池JMS连接提供程序（org.apache.activemq.pool.PooledConnectionFactory），这将JMS资源池有效地使用Spring的JmsTemplate或EJB工作。 e.g.1234567891011121314151617&lt;!-- a pooling based JMS provider --&gt; &lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt; &lt;property name=&quot;connectionFactory&quot;&gt; &lt;bean class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; &lt;property name=&quot;brokerURL&quot;&gt; &lt;value&gt;tcp://localhost:61616&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Spring JMS Template --&gt; &lt;bean id=&quot;myJmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt; &lt;property name=&quot;connectionFactory&quot;&gt; &lt;ref local=&quot;jmsFactory&quot;/&gt; &lt;/property&gt; &lt;/bean&gt; The PooledConnectionFactory supports the pooling of Connection, Session and MessageProducer instances so it can be used with tools like Camel and Spring’s JmsTemplate and MessagListenerContainer . Connections, sessions and producers are returned to a pool after use so that they can be reused later without having to undergo the cost of creating them again. PooledConnectionFactory支持Connection，Session和MessageProducer实例的池，所以它可以与诸如Camel和Spring的JmsTemplate和MessagListenerContainer之类的工具一起使用。 Connections，sessions和producers在使用后返回到池，以便以后可以重用它们，而不必再承担创建它们的成本。 Note: while the PooledConnectionFactory does allow the creation of a collection of active consumers, it does not ‘pool’ consumers. Pooling makes sense for connections, sessions and producers, which can be seldom-used resources, are expensive to create and can remain idle a minimal cost. Consumers, on the other hand, are usually just created at startup and left going, handling incoming messages as they come. When a consumer is complete, it’s preferred to shut down it down rather than leave it idle and return it to a pool for later reuse: this is because, even if the consumer is idle, ActiveMQ will keep delivering messages to the consumer’s prefetch buffer, where they’ll get held up until the consumer is active again. 注意：虽然PooledConnectionFactory允许创建活动消费者(consumers)的集合，但它不创建消费者(consumers)’池’。 池是有意义的连接(connections)，会话(sessions)和生产者(producers)，这是很少使用的资源，创建昂贵，可以以最低成本保持空闲。 另一方面，消费者(Consumers)通常只是在启动时创建，并且随时随地处理传入的消息。 当消费者完成时，最好关闭它，而不是保持空闲状态，并将其返回到池以供稍后重用：这是因为即使消费者空闲，ActiveMQ将继续向消费者的预取缓冲区传递消息， 而在那里他们会被阻止，直到消费者再次活跃。 If you are creating a collection of consumers (for example, for multi-threaded message consumption), you should consider keeping a low prefetch value (e.g. 10 or 20), to ensure that all messages don’t end up going to just one of the consumers. 如果您正在创建一个消费者(consumers)集合（例如，对于多线程消息消费），则应考虑保持低预取值（例如10或20），以确保所有消息不会最终只到达一个消费者。 We do also have a pooling JMS ConnectionFactory for use inside a JCA / MDB container (org.apache.activemq.ra.InboundConnectionProxyFactory), when using our JCA Resource Adapter which will reuse the same JMS connection/session which is being used for inbound messages. 当使用我们的JCA资源适配器时，我们也有一个JMS ConnectionFactory池用于JCA / MDB容器（org.apache.activemq.ra.InboundConnectionProxyFactory），它将重用与入站消息相同的JMS连接(connection)/会话(session) 。 Consuming JMS from inside Spring 从Spring内部使用JMSSpring’s MessagListenerContainer should be used for message consumption. This provides all the power of MDBs - efficient JMS consumption and pooling of the message listeners - but without requiring a full EJB container. Spring的MessagListenerContainer应该用于消息消费(message consumption)。 它提供了MDB的所有功能 - 高效的JMS消耗和消息侦听器池 - 但不需要完整的EJB容器。 You can use the activemq-pool org.apache.activemq.pool.PooledConnectionFactory for efficient pooling of the connections and sessions for your collection of consumers, or you can use the Spring JMS org.springframework.jms.connection.CachingConnectionFactory to achieve the same effect. 您可以使用activemq-pool org.apache.activemq.pool.PooledConnectionFactory来有效地池化消费者集合的连接和会话，也可以使用Spring JMS org.springframework.jms.connection.CachingConnectionFactory实现相同的效果。 More Information 更多信息Also check out the following blogs for information about using Spring JMS with ActiveMQ: 另请参阅以下博客，了解有关使用ActiveMQ使用Spring JMS的信息： Synchronous Request Response with ActiveMQ and Spring Using Spring to Send JMS Messages Using Spring to Receive JMS Messages Tuning JMS Message Consumption In Spring]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于工程师成长的一点思考]]></title>
      <url>%2F2016%2F11%2F19%2F%E5%85%B3%E4%BA%8E%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%88%90%E9%95%BF%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[转自:嘀嗒嘀嗒先说说为什么写这个话题。 下周公司要举办一个活动，找了硅谷一些比较 Senior 的技术女性一起做一场分享（点击｛阅读原文｝查看活动详情）。请来的人包括 Google 的 VP of Engineering，Linden Lab 的 Director，Rackspace 的 Board Director，Medisas 的 VP of Engineering 等等。我有幸代表 Airbnb 去主持这次分享。主持的主要工作就是准备一些问题，以及在活动中引导每个 Speaker 的分享。 在做准备工作的过程中，自己不禁也对很多相关问题有了更多的思考。 我进入职场不到四年，总体说来，应该还属于一个初期的阶段。但是这四年，从周围的不同的人身上学习了很多东西，终身受益。这篇文章，着重谈两点体会。一是哪些外部因素会促进我们的成长；二是哪些方面是我们自身可以努力，以加快成长的速度。 先说成长的外部因素有很多读者问过我，硅谷的工程师拼不拼。这个问题确实不好回答，因为方差太大。不过我身边有不少特别拼的小伙伴，每天有效工作时间都在十二到十六个小时之间。公司并没有任何加班的要求或者机制。这种勤奋是完全自发的。每个人的情况可能不完全一样，但是有两个外部因素不容忽略：一是来自团队的反馈和肯定，二是在工作中获得的成就感。 先说正面的反馈和肯定。这不一定是做了多么了不起的事情，或者是公司给了什么特别的荣誉。但在整个体系里，对个人的贡献和努力能表示出认可，这在很多时候，会不断激发团队里的正能量。一些简单的例子：可能是一封 Email 对某个人在面试上花的精力表示 Appreciation；可能是某人解决了一次线上事故后在组会中点名表示感谢；可能是老板与其 1:1 的时候直接表示嘉奖；甚至是简单的，平时组里相互调侃时大家的一句 “你太猛了” 等等。在一个相互对彼此的努力和成就表达认可和鼓励的氛围里，大家更容易开心地一起进步。 再说成就感。我觉得工程师这个群体还是更容易对自己 “做了什么” 产生自豪感，而不是自己 “得到了什么”。所以这里说的成就感就包括两个方面：一是他/她得觉得自己做的事情很重要；二是他/她觉得自己不断地有产出，完成了一些事情。做的事情是不是重要，很多时候和团队的领导人息息相关。之前在《论一线技术领导者的基本素养》中提到过：一个好的领导人要善于 “挖坑”，也就是定义项目，安排各种工作的优先级，决定要做什么。换句话说就是长期的战略眼光。有了这样的眼光并对团队的工作有很好的计划和安排，把重要性传递给每个成员，这样，每个成员才能知道自己做的事情的战略地位，知道自己做的事情对团队乃至公司的发展是重要的。此外，适当地安排一些技术分享，让组员有机会去展示自己的工作，让他知道其实很多人对自己做的东西感兴趣，也是一个很好的手段。 而关于 “让工程师觉得自己不断地有产出，完成很多事情” 这一点，最近有一些切身的体会。我们组，总体说来每个人每天工作的激情很高，做事的效率也很高。前两天和老板聊天偶尔提到此事，他说的话我觉得很有道理：“一个团队应该有一些稍微 Aggressive 但又可行的 Milestone（里程碑），而且大里程碑分成小的，尽可能每两个里程碑之间间隔时间不要过久。这样，每隔一段时间，大家就会完成一个目标，就会有成就感。最糟糕的，就是定一些不切实际的目标，或是不断 Miss 预定的目标。这样的话，慢慢地每个人都会开始疲惫和迷惘，很难看清楚自己到底做成了什么。” 再说成长的自身因素写公众号后，接触到很多的工程师。我朋友圈里面，和软件开发、计算机技术相关的人绝不少于一千。加上身边同事、朋友等各路大牛，我也不好大言不惭说我成长地很快云云，这里分享的仅仅是个人的看法和思考。可能也并不能对所有人、所有技术岗都适用。 我觉得技术人的成长还是要做到三个方面的平衡。哪三个方面呢？ 一是思。也就是思考。你说是业务逻辑也行，说是系统架构也罢，我说的思考，是你需要不断地去想：你到底要解决一个什么样的问题？你的目标是什么？根据你的现有资源（时间、已有代码）和限制（各种业务逻辑、已有代码），你能做的最优的解决方案是什么？换句话说，我们的工作还是应该以解决问题为出发点。 一个人是不是真牛，不是看他会什么不会什么，而是看他是不是真的能把每一件交给他的事情妥妥地做成。 二是学。也就是学习。这不仅包括流行的新语言，新工具，还包括和自己工作相关的计算机理论。而这些学习的目的，就是让自己从技术出发，知道哪些事能做，哪些事不能做（比如 CAP 理论，NP 理论）；知道自己想解决的问题是不是可以抽象成一个经典的问题，或是已有类似的解决方案（比如三次握手、二段提交等）；知道别人走过的桥踩过的坑，自己是不是可以借鉴（比如关于并发、安全、性能），等等。 三是践。也就是实践。工程师的动手能力尤为重要。很多猫腻的、坑人的、虐心的问题，如果没有亲身交战过，你永远不能体会它的奥妙。而且经常动手会增强自己写程序的熟练度，提高自己的开发效率。另一个就是增强自己对问题的敏锐性。很多耗在 Debug 和 Troubleshooting 上的时间，其实从长久来看，会增加自己看问题的深度，尤其是对编程语言的熟悉度。很多时候，一个 Junior 问 Senior 一个程序相关的问题，Senior 信手就解决的，其实，没有其他，不过是因为练过经历过。 而这三方面，如果只注重任意两个甚至一个方面，你就会发现自己很努力却不见太大的进步。木桶盛水，水深总是受限于最短的一块木板的高度，就是这个道理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[写代码的四个境界]]></title>
      <url>%2F2016%2F11%2F19%2F%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%A2%83%E7%95%8C%2F</url>
      <content type="text"><![CDATA[转自:嘀嗒嘀嗒从你拿到第一份码工的工作开始，你就可以说你会写代码了，因为毕竟面试是需要写代码的。 然而会写面试的代码于工作是没有太大益处的。仅仅是你必备的一项找工作技能。 真正能写出在 production 也很 solid、很靠谱的代码，可能很多人都经历过类似的不同阶段： 第一阶段：抄代码大部分公司对于比较新手的程序员，不太会上手就让你从无到有的开创一个新的代码库。而是在某一个代码库里增加或者修改一个功能。或者至少又类似的代码库可以参照。从产品的角度说，就是增加或者修改一个已有产品的特性。很多时候，公司的代码库已经有了很多类似的代码模块可以参考，而这种代码写起来其实没有太大技术难度，按照前人的写法写就行了。 叫抄代码有点偏颇，但是什么意思，我想很多人都能体会。我在 Square 的前半年，感觉大部分代码是这么写出来的。其实收获会很大：第一，你见识了这样的系统的架构是什么样子的。第二，很多地方别人为什么要那么写，反复琢磨，琢磨透了，就会学会处理实际编程中的很多技巧。比如怎么处理并发，怎么处理异常，怎么减少代码耦合度，等等。第三，很多语言的巧妙之处，系统设计的精巧，这些都是单纯读文章或者读代码很难体会的，自己从需求出发去理解这样的方案，其实学习语言的效率也是事半功倍。 第二阶段：学代码当我们对业务逻辑，代码库都比较熟悉之后，这个时候多看看进阶的书和各种学习资料，我觉得是最有效的。因为你有了一定的基础，所以阅读起来更容易理解。更重要的，是书本或者资料里提到的一些优化方案或是设计技巧，会特别容易引起共鸣。 记得有一次，我要写一段处理 REST API request retry 情况下怎么保证 request 的执行在 timeout 或是 lost 等情况下都能保证 service 的功能函数被且只被调用一次。因为涉及到异步和并发，所以有很多奇怪的情况需要考虑。那几天满脑子里都是在想各种不同的出错场景该怎么处理，如何正确使用 idempotency key 来保证实现的严谨和正确性。就在这个时候，很幸运地看到一段类似情况的处理的代码，当时再读这样的实现，就对其简洁和全面无比欣赏，感觉就像发现了一件设计精巧、打造完美的艺术品似的。 工作中从别人、从资料积累的这样的学习慢慢会变多，这个时候，经常可以在对别人的代码审核中给出比较有价值的建议，或者能够对已有代码库做出进一步的优化和完善。 第三阶段：心中有代码虽然说很多时候，大家觉得程序员这个职业，年轻人更有优势。我倒真的不是完全认同。一个程序员如果坚持不断的上手写代码，不断思考，不断学习，这样积累下来的经验应该只会让自己不断增值的。 前几天和二爷说笑，二爷说，和一些牛人聊技术，聊团队，聊模式，往往之后会觉得技术之外的东西更有帮助。其实就是这个道理，技术不是靠一次能讲清楚的，牛人一次分享会给你一些启发，但是这些启发有多少能转化到产品中，其实还是有很多别的更重要的因素的。 所以很多公司都需要挖一些这样的高级甚至高高级的程序员，因为他们是心里面有代码，知道一个service 应该怎么写，会有哪些坑。哪怕是写出的只是几十行代码，其实可能都是多少年经验积累下来的最宝贵的经验。 第四阶段：心中无代码这句话好像有点虚。最近看了曹政哥的一篇文章《从值乎谈执行力》，有一段觉得写得特别好。 以前我请大牛云风给我们讲过课，讲系统架构设计，他口头语也是，这个什么什么其实很简单，从头到尾你看不到他卖弄什么技术，讲什么特别高深玄奥的东西，但是人家搞出来的系统确实好用，后来提问环节我们有员工问过一些新的技术名词相关的什么什么，云风也很直白，很务实的说我们目前这个需求，用不上什么什么的。我就觉得这是重剑无锋的一个典范；现在云风他们团队分享的skynet开源引擎已经有非常多游戏团队在用，代码量也不复杂，功能也不算丰富，但是很实用的一个轻架构，能极大减少某些类型游戏的服务端开发成本。 这恰恰引起了我的一点感触。最近我们 Airbnb 支付组在重构我们支付系统的 API，大家都知道 Airbnb 支持 191 个国家 75 种货币 几十种不同的支付方式，在设计中需要保持 API 的简洁，又要留出足够的灵巧性可以方便的扩展和支持任何一种已有的或是新的支付方式。在设计和实现的过程中，所有的编程模式要熟悉，却不可能硬搬任何一种模式。只有真正吃透了需求和所有的编程技巧，才有可能做出干净而实用的方案。（题图作者杨江明也是这个系统的主要架构师。） 最后小八卦一下。硅谷码工随着等级的上升，收入不是呈线性增长，很多时候是翻倍地长的。我觉得其实是合理的。所以在初入职场面临的很多选择，其实还是应该以提高自身水平作为最重要的因素。年薪上差的那几万十几万，如果好好发展，到了后面，真的就不算什么了。第一份工作为了 package 做选择，真的不值得。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Spring和ActiveMQ实现高效轻量的JMS]]></title>
      <url>%2F2016%2F11%2F18%2F%E4%BD%BF%E7%94%A8Spring%E5%92%8CActiveMQ%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E8%BD%BB%E9%87%8F%E7%9A%84JMS%2F</url>
      <content type="text"><![CDATA[官方推荐的文章，原文Asynchronicity, its the number one design principal for highly scalable systems, and for Java that means JMS, which in turn means ActiveMQ. But how do I use JMS efficiently? One can quickly become overwhelmed with talk of containers, frameworks, and a plethora of options, most of which are outdated. So lets pick it apart. 异步性，是高伸缩性系统的首要的设计原则，对Java来说，这意味着JMS和ActiveMQ。但是我应该如何高效的使用JMS呢？在谈论容器、框架、和一堆选项时，你可能会不知所措。所以，让我们分开来探讨下吧。 Frameworks 框架The ActiveMQ documentation makes mention of two frameworks; Camel and Spring. The decision here comes down to simplicity vs functionality. Camel supports an immense amount of Enterprise Integration Patterns that can greatly simplify integrating a variety of services and orchestrating complicated message flows between components. Its certainly a best of breed if your system requires such functionality. However, if you are looking for simplicity and support for the basic best practices then Spring has the upper hand. For me, simplicity wins out any day of the week. ActiveMQ文档中提及两个框架：Camel和Spring。那么如何做决定就取决于简单性和功能性的对比。Camel支持大量的企业集成模式，它可以大大简化集成组件间的大量服务和复杂的消息流。如果你的系统需要这样的功能，它当然是非常好的选择。然而，如果你寻找简单性，仅仅支持基本的最佳实践，那么Spring是好的选择。 JCA (Use It Or Loose It)Reading through ActiveMQ’s spring support one is instantly introduced to the idea of a JCA container and ActiveMQ’s various proxies and adaptors for working inside of one. However, this is all a red herring. JCA is part of the EJB specification and as with most of the EJB specification, Spring doesn’t support it. Then there is a mention of Jencks, a “lightweight JCA container for Spring”, which was spun off of ActiveMQ’s JCA container. At first this seems like the ideal solution, but let me stop you there. Jencks was last updated on January 3rd 2007. At that time ActiveMQ was at version 4.1.x and Spring was at version 2.0.x and things have come a long way, a very long way. Even trying to get Jencks from the maven repository fails due to dependencies on ActiveMQ 4.1.x jars that no longer exist. The simple fact is there are better and simpler ways to ensure resource caching. ActiveMQ的Spring支持文档，立即向开发者介绍了JCA容器和ActiveMQ的很多代理和适配器选项的概念，但这些都是不合适的。JCA是EJB规范的一部分，对于大部分EJB规范，Spring都没有提供很好的支持。这时，就提到了Jencks，为Spring提供的轻量级JCA容器，它可以作为ActiveMQ的JCA容器。 乍看上去，这是个非常好的解决方案，但是我在这里告诉你不要这样做。Jencks最后更新时间是2007年1月。那时ActiveMQ的版本是 4.1x，Spring的版本是2.0.x，但是随着时间的流逝，事情变化了很大。甚至试图从Maven库中获取Jencks都会失败，因为它的依赖包ActiveMQ4.1已经不存在了。简单的事实是有更好和更简单的方式来缓存资源。 Sending Messages 发送消息The core of Spring’s message sending architecture is the JmsTemplate. In typical Spring template fashion, the JmsTemplate abstracts away all the cruft of opening and closing sessions and producers so all the application developer needs to worry about is the actual business logic. However, ActiveMQ is quick to point out the JmsTemplate gotchas, mostly that JmsTemplate is designed to open and close the session and producer on each call. To prevent this from absolutely destroying the messaging performance the documentation recommends using ActiveMQ’s PooledConnectionFactory which caches the sessions and message producers. However this too is outdated. Starting with version 2.5.3, Spring started shipping its own CachingConnectionFactory which I believe to be the preferred caching method. (UPDATE: In my more recent post, I talk about when you might want to use PooledConnectionFactory.) However, there is one catch to point out. By default the CachingConnectionFactory only caches one session which the javadoc claims to be sufficient for low concurrency situations). By contrast, the PooledConnectionFactory defaults to 500. As with most settings of this type, some amount of experimentation is probably in order. I’ve started with 100 which seems like a good compromise. Spring发送消息的核心架构是JmsTemplate。在传统的Spring模板方式中，JmsTemplate隔离了像打开、关闭Session和Producer的繁琐操作，因此应用开发人员仅仅需要关注实际的业务逻辑。然而ActiveMQ快速的指出了JmsTemplate gotchas，大多是因为JmsTemplate被设计在每次调用时都打开和关闭session及producer。JmsTemplate损害了ActiveMQ的PooledConnectionFactory对session和消息producer的缓存机制而带来的性能提升。然而，这个太过时了。从Spring2.5.3开始，它开始提供自己的CachingConnectionFactory，我相信该类在缓存方面更加强大。然而，这里有一个点需要注意。默认情况下，CachingConnectionFactory只缓存一个session，在它的JavaDoc中，它声明对于低并发情况下这是足够的。与之相反，PooledConnectionFactory的默认值是500。这些设置，在很多情况下，需要亲自去测试并验证。我将其设置为100，对我来说还是很不错。 Receiving Messages 接收消息As you may have noticed, the JmsTemplate gotchas strongly discourages using the recieve() call on the JmsTemplate, again, since there is no pooling of sessions and consumers. Moreover, all calls on the JmsTemplate are synchronous which means the calling thread will block until the method returns. This is fine when using JmsTemplate to send messages since the method returns almost instantly. However, when using the recieve() call, the thread will block until a message is received, which has a huge impact on performance. Unfortunately, neither the JmsTemplate gotchas nor the spring support documentation mentions the simple Spring solution for these problems. In fact they both recommend using Jencks, which we already debunked. The actual solution, using the DefaultMessageListenerContainer, is buried in the how do I use JMS efficiently documentation. The DefaultMessageListenerContainer allows for the asynchronous receipt of messages as well as caching sessions and message consumers. Even more interesting, the DefaultMessageListenerContainer can dynamically grow and shrink the number of listeners based on message volume. In short, this is why we can completely ignore JCA. 可能你已经注意了，JmsTemplate gotchas非常不建议你使用JmsTemplate的receive()调用，同样也是因为没有session和consumer的池机制。更多的原因是在JmsTemplate上的所有调用都是同步的，这意味着调用线程需要被阻塞，直到方法返回。这在使用JmsTemplate发送消息时，没有任何问题， 因为该方法几乎是立即返回。然而，当调用receive方法时，线程将阻塞，直到接收到一个消息为止，这对性能影响很大。不幸的是，JmsTemplate gotchas和Spring支持文档中都没有对该问题提供简单的解决方案。实际上，它们均提倡使用Jencks，我们之前已经说过。实际的解决方案，使用DefaultMessageListenerContainer，已经写在了how do I use JMS efficiently文档中。DefaultMessageListenerContainer允许异步接收消息并缓存session和消息consumer。更有趣的是，DefaultMessageListenerContainer可以根据消息数量动态的增加或缩减监听器的数量。简而言之，我们可以完全忽视 JCA。 Putting It All Together 合并起来SPRING CONTEXT XMLSpring Context配置文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsdhttp://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.2.0.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsdhttp://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-2.5.xsd&quot;&gt;&lt;!-- enables annotation based configuration --&gt;&lt;context:annotation-config /&gt;&lt;!-- scans for annotated classes in the com.company package --&gt;&lt;context:component-scan base-package=&quot;com.company&quot;/&gt;&lt;!-- allows for $&#123;&#125; replacement in the spring xml configuration from the system.properties file on the classpath --&gt;&lt;context:property-placeholder location=&quot;classpath:system.properties&quot;/&gt;&lt;!-- creates an activemq connection factory using the amq namespace --&gt;&lt;amq:connectionFactory id=&quot;amqConnectionFactory&quot; brokerURL=&quot;$&#123;jms.url&#125;&quot; userName=&quot;$&#123;jms.username&#125;&quot; password=&quot;$&#123;jms.password&#125;&quot; /&gt;&lt;!-- CachingConnectionFactory Definition, sessionCacheSize property is the number of sessions to cache --&gt;&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt; &lt;constructor-arg ref=&quot;amqConnectionFactory&quot; /&gt; &lt;property name=&quot;exceptionListener&quot; ref=&quot;jmsExceptionListener&quot; /&gt; &lt;property name=&quot;sessionCacheSize&quot; value=&quot;100&quot; /&gt;&lt;/bean&gt;&lt;!-- JmsTemplate Definition --&gt;&lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt; &lt;constructor-arg ref=&quot;connectionFactory&quot;/&gt;&lt;/bean&gt;&lt;!-- listener container definition using the jms namespace, concurrency is the max number of concurrent listeners that can be started --&gt;&lt;jms:listener-container concurrency=&quot;10&quot; &gt; &lt;jms:listener id=&quot;QueueListener&quot; destination=&quot;Queue.Name&quot; ref=&quot;queueListener&quot; /&gt;&lt;/jms:listener-container&gt;&lt;/beans&gt; There are two things to notice here. First, I’ve added the amq and jms namespaces to the opening beans tag. Second, I’m using the Spring 2.5 annotation based configuration. By using the annotation based configuration I can simply add @Component annotation to my Java classes instead of having to specify them in the spring context xml explicitly. Additionally, I can add @Autowired on my constructors to have objects such as JmsTemplate automatically wired into my objects. 这里有两点需要注意。首先，我添加了amq和jms的命名空间。第二，我使用了Spring2.5基于注解的配置。通过使用基于注解的配置，我可以简单的添加@Component注解到我的Java类上，而不是使用XML文件显式的在spring配置文件中定义它们。另外，我可以在我的构造方法中使用@Autowired来将像JmsTemplate这样的对象注入到我的对象中。 QUEUESENDER12345678910111213141516171819202122package com.company;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;@Componentpublic class QueueSender&#123; private final JmsTemplate jmsTemplate; @Autowired public QueueSender( final JmsTemplate jmsTemplate ) &#123; this.jmsTemplate = jmsTemplate; &#125; public void send( final String message ) &#123; jmsTemplate.convertAndSend( &quot;Queue.Name&quot;, message ); &#125;&#125; QUEUE LISTENER12345678910111213141516171819202122232425262728package com.company;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.springframework.stereotype.Component;@Componentpublic class QueueListener implements MessageListener&#123; public void onMessage( final Message message ) &#123; if ( message instanceof TextMessage ) &#123; final TextMessage textMessage = (TextMessage) message; try &#123; System.out.println( textMessage.getText() ); &#125; catch (final JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ## JMSEXCEPTIONLISTENER123456789101112131415package com.company;import javax.jms.ExceptionListener;import javax.jms.JMSException;import org.springframework.stereotype.Component;@Componentpublic class JmsExceptionListener implements ExceptionListener&#123; public void onException( final JMSException e ) &#123; e.printStackTrace(); &#125;&#125; Update 更新I have finally updated the wiki at activemq.apache.org. The following pages now recommend using MessageListenerContainers and JmsTemplate with a Pooling ConnectionFactory instead of JCA and Jencks. 推荐查看下面的页面来使用带有池化连接池的MessageListenerContainer和JmsTemplate而不是JCA和Jencks。 http://activemq.apache.org/spring-support.html http://activemq.apache.org/how-do-i-use-jms-efficiently.html http://activemq.apache.org/jmstemplate-gotchas.html 译文参考:寒江的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码重构之道]]></title>
      <url>%2F2016%2F11%2F18%2F%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E4%B9%8B%E9%81%93%2F</url>
      <content type="text"><![CDATA[转自:程序人生 如果我纯粹为今天工作，明天我将完全无法工作。 – 某子 程序员要面向未来编程。代码重构永远是程序员们无法回避的话题，当你的软件在编写的那一刻起，重构就不可避免。做一个系统，我们为什么要费劲地不断抽象，竭尽全力让自己的代码能够被重用，说白了就是让我们今日所付出的时间，让未来的我们能够更轻松地工作而已。 有位读者让我就 Martin Fowler 的『重构 - 改善既有代码的设计』一书，谈谈重构。我诚惶诚恐。这本书我很久很久以前买过，至今还躺在北京家中的书柜里；当时对系统领悟还不够深，所以很多思想都并未参透，所以谈不上真正「读」进去了。如今手头并无此书，也无法就着书来谈重构。Martin Fowler 的书和博客都值得一看，这本书应该也不差（不知道翻译如何，实在没有印象了），大家可以买来翻翻。 这里我谈谈自己在工作中，对重构的看法。 重构之道自动化测试重构代码最最最重要的一个先验条件是：自动化测试。子在川上曰： 一切没有自动化测试的代码重构都是耍流氓。 写代码的目的是什么？是为了产出的系统能够满足功能需求。重构代码的目的是什么？是为了满足功能需求的代码能够像奥林匹克精神描述的那样：质量更高，性能更好，速度更快，让未来的工作更轻松，以及让代码看上去更美。如果你重构了代码，却破坏了基本的功能，纵使代码再漂亮，性能再高，又有何用？ 那么如何保证重构不破坏既有的功能？答曰：测试。无论你是单元测试，功能测试，集成测试，还是哔哩哔哩测试，总之你需要尽一切可能去测试。重构有一个个「点」（细胞）的重构，所以你需要单元测试；也有一个个「切面」（器官）的重构，所以你需要功能测试；当「切面」的改动甚大（器官移植），还需要集成测试…相关的测试是否存在决定了你能否重构；而测试所花费的时间直接决定了你是否会进行重构，以及以一个什么样的频率进行重构。如果重构了十行代码，却需要花费一个小时进行运行一次单元测试，那么你要么不会去重构代码，要么你重构了不会去测试。 好的重构发生在构建系统的每时每刻，而非问题发生或者老板要求。如果重构之后测试立刻会告知你结果，你会更有信心进行更多的重构，使其成为你工作生活的一部分。 你也许会质疑：什么样的单元测试可能会需要一个小时来完成？答曰：手工测试。这是为什么先验条件不是「测试」，而是「自动化测试」。没有自动化测试（以下简称测试），谈重构纯属扯淡。如果要重构的环节测试覆盖率不好，先想法提高覆盖率；如果根本没有测试例，请先做好这个基本功再谈重构。 时时刻刻重构前面已经提到了重构代码最佳的时间点：撰写每行代码的时候，而非火烧屁股的时候。那什么样的情况你需要进行重构呢？有道是 bad code smells —— 下面这些让你感到不太舒服的场景其实是提醒你，代码该重构了： 一. 当你写一段代码时，不得不从别处拷贝粘贴代码显然，这有悖于 DRY（Don’t repeat yourself）。一段代码（文档，测试，注释）如果要被复制，那么它的逻辑就该被抽取出来，单独成文。这几乎是重构最基础的实践。然而，这个问题，从小公司到大公司，几乎是每个系统最严重的问题之一。在我以前工作的公司，我维护过一个超过 5000 行的 C 函数，里面的 if-else 层层嵌套下的 copy&amp;paste 让人叹为观止，添加一点逻辑需要检查七八个地方是否需要同样的逻辑，完全可以入选教材作为经典的反面案例。 如今，感谢包括 GoF，Martin Fowler，Kent Beck，松本行弘等大师的不懈努力，以及程序君猫在角落里不断地摇旗呐喊，代码的 DRY 越来越得到重视。这很好。那么测试代码呢？文档呢？注释呢？是不是也该重视一下了？我曾接手过一个 API 系统的测试，所有的测试都在做一件事，就是给 mockup 的 API server 发一个（或者多个）request，然后验证 response 是否正确。几十个测试例，数百行代码其实可以用十多行公共代码以及下面的语法抽象： 不要小看测试的 DRY，文档的 DRY，它们也同样重要（如果不是更重要的话）。文档如若被多次 copy&amp;paste，可能导致某处的修改没有反映到所有的拷贝，误人子弟；测试代码不够 DRY，当其到达一个足够大的规模后，维护和更新起来会非常头疼。 二. 当你修改已有代码添加新功能时，发现已有代码总感觉哪里不对比如说，逻辑写得太绕，太复杂，太难以理解，循环太多，分支太多，状态太多等等。这样的代码几乎跪在那里请求你的重构，不重构说不过去。 三. 当你调用已有的代码时（函数，类），不得不阅读被调用的代码才能确定怎么调用时这个代码要么接口定义的不好，比如说，一个函数有十多个参数；要么是文档写的不好，比如说，关键性的函数没有对接口提供足够的说明。如果说上面所述的是纯粹的代码重构，那么这里就是用户体验的重构。程序员的代码是什么？是一个程序员为另一个程序员精心打造的产品！函数（或者类）的 signature，以及对 signature 的说明是这个产品的 UI。你如果打开微信，一个按钮是干什么的不知所云，总和你期望的效果不同，你是不是想像个混蛋一样跳起来骂娘？同样的道理，程序员也是人，尽管在工作中被磨砺得「温良恭俭让」，看到不知所谓的接口也会变身满嘴 WTF 的混蛋。 四. 当你写一段代码时，连带着要改很多代码当这个场景发生的时候，代码的味道相当糟糕，意味着不仅代码本身有问题，相关代码的设计甚至架构也有很大的问题。如果没有一定功底的程序员，重构这样的代码会比较费劲。 严格自律与他律稍微大一点的软件项目是多人一起合作完成的。和别人合作，我们要坚信两点：人天性都是懒惰的，有捷径的话，绝不规规矩矩走大道；同时人都会受到 role model 或者社区的感染，如果已有的代码库形成了一个良好的氛围，新加入的人有一种融入已有体系的紧迫感。开源项目其实可以给我们很多启发，看看那些著名的开源项目，很多参与其中的人在他们各自的公司里都未必有这么好的习惯，但在开源项目中，项目本身的检测和社区带来的压力会让它们自律。 对于人的这两种天性，我们可以如下引导之。 在一个项目启动之初，一定要设置足够的代码签入（checkin）门槛。lint / build / test 一个都不能少。这是我在公司给 team 定下的 linting 规矩（是的，我们用 nodejs）： 除了 airbnb 的 javascript style 的基本要求外，我还有这些要求： 代码中不能有任何形式的 console.xxx 出现。为此，我不惜定义 print 函数为 cli 使用。这是逼着程序员好好考虑如何 log，用什么样的 log level 合适。 一个函数最多有 50 行代码。那么超过 50 行代码怎么办？要么拆分之，要么精简之。 一个函数的嵌套不能超过 5 层。多个 for 循环，深层的 if-else，这些都是罪恶之源。如果超过这个限制，只能拆分，或者使用函数式编程：map/filter/reduce。 一个函数最多有 3 层 callback。这是逼着程序员不要误用 callback，尽量多用 Promise。 一个函数最多 5 个参数。参数太多的函数，基本是试图揉太多事情在一起。 一个函数的复杂性不超过 10。你的所有分支，循环，回调等等统统加在一起，在一个函数里不超过 10 个（注意不是嵌套）。 这些要求严格到令人发指。尤其是 complexity，我经常会一不小心就超出了这个限制。然而它逼迫我对要写的代码做更多的思考，把更多的代码逻辑转化成数据。代码到数据的转化是抽象思维的很重要一步（比如上面的那个 test fixture），它将代码和代码进一步解耦，用数据（一些 rule）串联起来。 除了 lint 外，强制的 test case 也很重要。我在代码的 pre-commit hook 里，加入了这些 task。一份代码想要 checkin，先过了 lint / build / test 关再说。虽然，git pre-commit hook 可以被 skip，但是若有人胆敢这样做，还有严格的 code review 和 CI 等着他。发现不符合规范直接杀威棒伺候。 以上种种，都是解决人性中的惰性。先来一大棒子。 接下来要有 role model，或者社区氛围来引导行为。一般我启动的项目，我会撰写初始的项目，力保每行代码清晰可读，每个函数深思熟虑，每个接口都有友好的文档，每个关键的函数有详尽的测试，然后在 code review 严格把关。这样，在更多的人加入项目后，大家前有模板可循，经验可依，后有鞭策之威，自然写出比较漂亮的代码。荀子说： 干将莫邪（哎，这哥们说了那么多宝剑我就记得这俩）等，古之良剑 —— 然而不加砥厉则不能利，不得人力则不能断…夫人虽有性质美而心辩知，必将求贤师而事之，择良友而友之。 这就是 role model 和大环境的作用。有了这层铺垫，每次 review 的 well done，每个 pull request 的 LGTM（look good to merge），都是一根根胡萝卜，让工程师尝到写出优秀代码的甜头。 整个过程和代码重构看上去没什么关系，但处处要求程序员重构代码以达到比较高的标准。相信我，这么做即便大家开始不适，等渐渐建立信心之后，会时时刻刻重构，自我追求更高质量的代码。 重构之术至于重构之术，我想，Martin Fowler 的书里应该都讲到了，不讲也罢。讲了的话无非是拾各种编程模式，范式之牙慧。而且各种编程范式，比如面向对象编程中的类的重构和函数式编程中的函数的重构也不尽相同；各种语言，比如 elixir（pattern matching, macro），javascript（closure，FP），和 C++（OOP） 三种语言的重构手段就千差万别。 就酱。如果你对代码重构有什么心得，或者我说的不妥之处，不妨也留言吐槽。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ActiveMQ官方文档 -- 入门]]></title>
      <url>%2F2016%2F11%2F17%2FActiveMQ%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[ActiveMQ官方文档 – 入门 Introduction 介绍This document describes how to install and configure ActiveMQ 4.x/5.x for both Unix and Windows’ platforms. 本文档介绍如何在Unix和Windows平台上安装和配置ActiveMQ 4.x / 5.x。 Pre-Installation Requirements 安装要求Hardware: 60 MB of free disk space for the ActiveMQ 5.x binary distribution.(you need additional disk space for storing persistent messages to disk) 300 MB of free disk space for the ActiveMQ 5.x source or developer’s distributions.Operating Systems: Windows: Windows XP SP2, Windows 2000, Windows Vista, Windows 7. Unix: Ubuntu Linux, Powerdog Linux, MacOS, AIX, HP-UX, Solaris, or any Unix platform that supports Java.Environment: Java Runtime Environment (JRE) JRE 1.7 (1.6 for version &lt;=5.10.0)(a JDK is required if you plan to recompile source code) The JAVA_HOME environment variable must be set to the directory where the JRE is installed(Unix: the binary “java” has to be resolvable by the PATH variable; execute “which java” to verify) Maven 3.0.0 build system(only if you plan to recompile source code) JARs that will be used must be added to the classpath.(only if you plan to recompile source code) Installation Procedure for Windows Windows的安装过程This section of the Getting Started Guide explains how to install binary and source distributions of ActiveMQ on a Windows system. “入门指南”的本部分介绍如何在Windows系统上安装ActiveMQ的二进制和源代码分发。 Windows Binary Installation Windows二进制安装This procedure explains how to download and install the binary distribution on a Windows system. 此过程说明如何在Windows系统上下载和安装二进制发行版。 Download the latest release(see Download -&gt; “The latest stable release” -&gt; “apache-activemq-x.x.x-bin.zip”) Extract the files from the ZIP file into a directory of your choice. Proceed to the #Starting ActiveMQ section of this document. Following start-up, go to the #Testing the Installation section of this document. 下载最新版本（请参阅下载 - &gt;“最新稳定版本” - &gt;“apache-activemq-x.x.x-bin.zip”） 将ZIP文件中的文件解压缩到您选择的目录中。 继续本文档的#Starting ActiveMQ部分。 启动后，请转到本文档的#Testing the Installation部分。 Windows Source Installation Windows源码安装This procedure explains how to download and install the source distribution on a Windows system. Download the latest release(see Download -&gt; “The latest stable release” -&gt; “apache-activemq-x.x.x-source-release.zip”) Extract ActiveMQ from the ZIP file into a directory of your choice. The recommended method of building ActiveMQ is the following:12REM add &quot;-Dmaven.test.skip=true&quot; if tests are failing on your system (should not happen)mvn clean install where [activemq_install_dir] is the directory in which ActiveMQ was installed. If you prefer to use an IDE, then you can auto-generate the IDE’s project file using maven plugins:1mvn eclipse:eclipse or1mvn idea:idea Feel free to use any other applicable IDE. Please refer to the plugin reference for more details. 此过程说明如何在Windows系统上下载和安装源码发行版。 下载最新版本（请参阅下载 - &gt;“最新稳定版本” - &gt;“apache-activemq-x.x.x-source-release.zip”） 将ActiveMQ从ZIP文件解压缩到您选择的目录中。 建议使用ActiveMQ的推荐方法如下：12如果测试在您的系统上失败（不应该发生）,REM添加“-Dmaven.test.skip = true”mvn clean install 其中[activemq_install_dir]是安装ActiveMQ的目录。 如果你喜欢使用IDE，那么你可以使用maven插件自动生成IDE的项目文件：1mvn eclipse:eclipse or1mvn idea:idea 可随意使用其他任何适用的IDE。 有关更多详细信息，请参阅插件参考。 Start ActiveMQ from the target directory, for example:1234cd [activemq_install_dir]\assembly\targetunzip activemq-x.x-SNAPSHOT.zipcd activemq-x.x-SNAPSHOTbin\activemq NOTE: Working directories get created relative to the current directory. To create the working directories in the proper place, ActiveMQ must be launched from its home/installation directory. Proceed to the #Testing the Installation section. 12Warning:If you are building ActiveMQ 4.x under Windows using Cygwin there is a path name length limitation. If the path name length is exceeded, you may see build errors. To correct this, move the ActiveMQ source directory higher in the file system tree, e.g., /cygdrive/c/d/sm. 从目标目录启动ActiveMQ，例如： 1234cd [activemq_install_dir]\assembly\targetunzip activemq-x.x-SNAPSHOT.zipcd activemq-x.x-SNAPSHOTbin\activemq 注意：相对于当前目录创建工作目录。 要在正确的位置创建工作目录，ActiveMQ必须从其home/安装目录启动。 转到#Testing安装部分。12警告如果您在Windows下使用Cygwin构建ActiveMQ 4.x，则存在路径名称长度限制。 如果超过路径名称长度，您可能会看到构建错误。 要纠正这一点，请将ActiveMQ源目录在文件系统树中更高的位置，例如/ cygdrive / c / d / sm。 Windows Developer’s Release Windows开发人员版本This procedure explains how to download and install the latest developer’s snapshot. Open the release archive: https://repository.apache.org/content/repositories/snapshots/org/apache/activemq/apache-activemq/(open one of the SNAPSHOT directories) Select the version of ActiveMQ to download (if necessary, scroll down to see the ActiveMQ snapshots). Extract the files from the ZIP file into a directory of your choice. If a binary snapshot was downloaded, proceed to the #Starting ActiveMQ section of this document.If a source snapshot was downloaded, perform step 6 and step 7 of the #Windows Source Installation procedure. Following start-up, proceed to the #Testing the Installation section. Installation Procedure for Unix Unix的安装过程Unix Binary Installation Unix二进制安装This procedure explains how to download and install the binary distribution on a Unix system. NOTE: There are several alternative ways to perform this type of installation. 此过程说明如何在Unix系统上下载和安装二进制发行版。 注意：有几种可选的方法来执行此类型的安装。 Download the activemq zipped tarball file to the Unix machine, using either a browser or a tool, i.e., wget, scp, ftp, etc. for example:(see Download -&gt; “The latest stable release”) 1wget http://activemq.apache.org/path/tofile/apache-activemq-x.x.x-bin.tar.gz Extract the files from the zipped tarball into a directory of your choice. For example: 12cd [activemq_install_dir]tar zxvf activemq-x.x.x-bin.tar.gz Proceed to the #Starting ActiveMQ section of this document. Following start-up, go to the #Testing the Installation section. Using Homebrew installer on OSXIf you use OSX as your platform, you can use Homebrew package manager to easily install Apache ActiveMQ. After installing Homebrew package manager successfully, just run1$ brew install apache-activemq You can expect the following output:1234567==&gt; Downloading http://www.gossipcheck.com/mirrors/apache/activemq/apache-activemq/x.x.x/apache-activemq-x.x.x-bin.tar.gz######################################################################## 100.0%==&gt; CaveatsSoftware was installed to: /usr/local/Cellar/apache-activemq/x.x.x/libexec==&gt; Summary/usr/local/Cellar/apache-activemq/x.x.x: 406 files, 35M, built in 2 seconds ActiveMQ will be installed in /usr/local/Cellar/apache-activemq/x.x.x/ directory (where x.x.x denotes the actual version being installed). Now you can proceed to #Starting ActiveMQ and #Testing the Installation sections. Unix Source InstallationThis procedure explains how to download and install the source distribution on a Unix system. This procedure assumes the Unix machine has a browser. Please see the previous #Unix Binary Installation section for details on how to install ActiveMQ without a browser. Download the latest source release(see Download -&gt; “The latest stable release” -&gt; “activemq-parent-x.x.x-source-release.zip”) Extract the files from the ZIP file into a directory of your choice. For example: 1tar zxvf activemq.x.x-src.tar.gz Build ActiveMQ using Maven:The preferred method of building ActiveMQ is the following:cd [activemq_install_dir] 1mvn clean install # add &quot;-Dmaven.test.skip=true&quot; if tests are failing on your system (should not happen) If Maven crashes with a java.lang.OutOfMemoryError, you you need to do this first (assuming a Bourne-like shell):1export MAVEN_OPTS=&quot;-Xmx512M&quot; If you prefer to use an IDE then you can auto-generate the IDE’s project file using maven plugins:1mvn eclipse:eclipse or1mvn idea:idea Feel free to use any other applicable IDE. Please refer to the plugin reference for more details.NOTE: Working directories get created relative to the current directory. To create working directories in the proper place, ActiveMQ must be launched from its home/installation directory. Proceed to the #Starting ActiveMQ section of this document. Proceed to #Testing the Installation section. ## Unix Developer’s ReleaseThis procedure explains how to download and install the latest developer’s snapshot. Open the release archive: https://repository.apache.org/content/repositories/snapshots/org/apache/activemq/apache-activemq/(open one of the SNAPSHOT directories) Select the version of ActiveMQ to download (you may have to scroll down to see the ActiveMQ snapshots).The filename will be similar to: activemq-x.x.x-tar.gz. Extract the files from the gzip file into a directory of your choice. For example:For a binary developer’s snapshot:1tar zxvf activemq-x.x.x.tar.gz For a source developer’s snapshot:1tar zxvf activemq-x.x.x-src.tar.gz If a binary snapshot was downloaded, to make it executable, the ActiveMQ script may need its permissions changed: 12cd [activemq_install_dir]/binchmod 755 activemq For a binary snapshot, proceed to the #Starting ActiveMQ section of this document. If a source snapshot was downloaded perform steps 6 - 8 of the #Unix Source Installation procedure. Proceed to the #Testing the Installation section. Starting ActiveMQ 运行ActiveMQThere now follows instructions on how to run the ActiveMQ Message Broker.现在有关于如何运行ActiveMQ消息代理的说明。 On Windows:From a console window, change to the installation directory and run ActiveMQ: 在控制台窗口中，切换到安装目录并运行ActiveMQ：1cd [activemq_install_dir] where activemq_install_dir is the directory in which ActiveMQ was installed, e.g., c:\Program Files\ActiveMQ-5.x.Then type: 其中activemq_install_dir是安装ActiveMQ的目录，例如c:\Program Files\ActiveMQ-5.x。然后键入：1bin\activemq start NOTE: Working directories get created relative to the current directory. To create working directories in the proper place, ActiveMQ must be launched from its home/installation directory. 注意：相对于当前目录创建工作目录。 要在正确的位置创建工作目录，ActiveMQ必须从其home/installation目录启动。 On Unix:From a command shell, change to the installation directory and run ActiveMQ as a foregroud process:12cd [activemq_install_dir]/bin./activemq console From a command shell, change to the installation directory and run ActiveMQ as a daemon process:12cd [activemq_install_dir]/bin./activemq start ## More helpFor other ways of running the broker see Here. For example you can run an embedded broker inside your JMS Connection to avoid starting a separate process. 有关运行代理的其他方法，请参阅这里。 例如，您可以在JMS连接中运行嵌入式代理，以避免启动单独的进程。 Testing the Installation 测试安装是否成功Using the administrative interface 使用管理接口 Open the administrative interface URL: http://127.0.0.1:8161/admin/ Login: admin Passwort: admin Navigate to “Queues” Add a queue name and click create Send test message by klicking on Send to 打开管理界面 网址：http://127.0.0.1:8161/admin/ 登录：admin 密码：admin 导航到“Queues” 添加队列名称，然后单击create 通过点击Send to发送测试消息 Logfile and console output 日志文件和控制台输出If ActiveMQ is up and running without problems, the Window’s console window or the Unix command shell will display information similar to the following log line: (see stdout output or “[activemq_install_dir]/data/activemq.log”) 如果ActiveMQ启动并运行没有问题，窗口的控制台窗口或Unix命令shell将显示类似以下日志行的信息： （请参见stdout输出或“[activemq_install_dir] /data/activemq.log”）1Apache ActiveMQ 5.11.1 (localhost, ID:ntbk11111-50816-1428933306116-0:1) started | org.apache.activemq.broker.BrokerService | main Listen port 监听端口ActiveMQ’s default port is 61616. From another window run netstat and search for port 61616. ActiveMQ的默认端口是61616.从另一个窗口运行netstat并搜索端口61616。 From a Windows console, type: 在Windows控制台中，键入：1netstat -an|find &quot;61616&quot; ORFrom a Unix command shell, type:1netstat -nl|grep 61616 Monitoring ActiveMQ 监视ActiveMQYou can monitor ActiveMQ using the Web Console by pointing your browser athttp://localhost:8161/admin 您可以通过指向浏览器使用Web控制台监视ActiveMQhttp://localhost:8161/admin12345From ActiveMQ 5.8 onwards the web apps is secured out of the box.The default username and password is admin/admin. You can configure this in the conf/jetty-real.properties file.从ActiveMQ 5.8起，网络应用程序是开箱即用的。默认用户名和密码为admin/admin。 您可以在conf/jetty-real.properties文件中进行配置。 Or you can use the JMX support to view the running state of ActiveMQ. 或者可以使用JMX支持来查看ActiveMQ的运行状态。 For more information see the file docs/WebConsole-README.txt in the distribution. 有关详细信息，请参阅分发中的文件docs / WebConsole-README.txt。 Stopping ActiveMQ 停止ActiveMQFor both Windows and Unix installations, terminate ActiveMQ by typing “CTRL-C” in the console or command shell in which it is running. 对于Windows和Unix安装，通过在其运行的控制台或命令shell中键入“CTRL-C”来终止ActiveMQ。 If ActiveMQ was started in the background on Unix, the process can be killed, with the following: 如果ActiveMQ是在后台在Unix上启动的，进程可以被以下命令杀死：12cd [activemq_install_dir]/bin./activemq stop Configuring ActiveMQThe ActiveMQ broker should now run. You can configure the broker by specifying an Xml Configuration file as a parameter to the activemq command. An alternative is to use the Broker Configuration URI to configure things on the command line in a concise format (though the configuration options are not as extensive as if you use Java or XML code). ActiveMQ代理现在应该运行。 您可以通过将Xml配置文件指定为activemq命令的参数来配置代理。 另一种方法是使用Broker配置URI以简洁的格式配置命令行中的内容（虽然配置选项不像使用Java或XML代码那样广泛）。 You can also see Configuring Transports to see how you can configure the various connection, transport and broker options using the connection URL in the ActiveMQConnectionFactory. 您还可以查看配置传输，了解如何使用ActiveMQConnectionFactory中的连接URL配置各种连接，传输和代理选项。 See the Initial Configuration for details of which jars you need to add to your classpath to start using ActiveMQ in your Java code 有关哪些jar需要添加到类路径以开始在Java代码中使用ActiveMQ的详细信息，请参阅初始配置 If you want to use JNDI to connect to your JMS provider then please view the JNDI Support. If you are a Spring user you should read about Spring Support 如果要使用JNDI连接到JMS提供程序，请查看JNDI支持。 如果你是一个Spring用户，你应该阅读关于Spring支持 After the installation, ActiveMQ is running with a basic configuration. For details on configuring options, please see refer to the Configuration section. 安装后，ActiveMQ正在使用基本配置运行。 有关配置选项的详细信息，请参阅配置部分。 Additional Resources 其他资源If you are new to using ActiveMQ, running the Web Samples or the Examples is a good next step to learn more about ActiveMQ. 如果您刚刚使用ActiveMQ，运行Web示例或示例可以了解ActiveMQ的更多信息。 The Commercial Providers listed on the Support page may also have additional documentation, examples, tutorials, etc… that can help you get started. 支持页面上列出的商业提供商可能还有其他文档，示例，教程等，可以帮助您开始。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate Validator官方文档 -- 第2章]]></title>
      <url>%2F2016%2F11%2F11%2FHibernate%20Validator%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3--%E7%AC%AC2%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[Hibernate Validator官方文档–第2章 声明和验证bean约束 2. Declaring and validating bean constraintsIn this chapter you will learn how to declare (see Section 2.1, “Declaring bean constraints”) and validate (see Section 2.2, “Validating bean constraints”) bean constraints. Section 2.3, “Built-in constraints” provides an overview of all built-in constraints coming with Hibernate Validator. If you are interested in applying constraints to method parameters and return values, refer to Chapter 3, Declaring and validating method constraints. 在本章中，您将学习如何声明(见第2.1节“声明bean约束”)和验证(参见第2.2节“验证bean约束”)bean约束。 第2.3节“内置约束”提供了Hibernate Validator提供的所有内置约束的概述。 如果您有兴趣对方法参数和返回值应用约束，请参阅第3章，声明和验证方法约束。 2.1. Declaring bean constraintsConstraints in Bean Validation are expressed via Java annotations. In this section you will learn how to enhance an object model with these annotations. There are the following three types of bean constraints: Bean验证中的约束通过Java注释来表示。 在本节中，您将学习如何使用这些注释增强对象模型。 有以下三种类型的bean约束： field constraints 字段约束 property constraints 属性约束 class constraints 类约束 Note：Not all constraints can be placed on all of these levels. In fact, none of the default constraints defined by Bean Validation can be placed at class level. The java.lang.annotation.Target annotation in the constraint annotation itself determines on which elements a constraint can be placed. See Chapter 6, Creating custom constraints for more information. 注意：不是所有的约束都可以放在所有这些级别上。 事实上，Bean Validation定义的默认约束不能放在类级别。 约束注释中的java.lang.annotation.Target注释本身确定了可以在哪些元素上放置约束。 有关更多信息，请参阅第6章，创建自定义约束。 2.1.1. Field-level constraintsConstraints can be expressed by annotating a field of a class. Example 2.1, “Field-level constraints” shows a field level configuration example: 约束可以通过注释类的字段来表示。 示例2.1，“字段级约束”显示字段级配置示例：1234567891011121314151617package org.hibernate.validator.referenceguide.chapter02.fieldlevel;public class Car &#123; @NotNull private String manufacturer; @AssertTrue private boolean isRegistered; public Car(String manufacturer, boolean isRegistered) &#123; this.manufacturer = manufacturer; this.isRegistered = isRegistered; &#125; //getters and setters...&#125; When using field-level constraints field access strategy is used to access the value to be validated. This means the validation engine directly accesses the instance variable and does not invoke the property accessor method even if such an accessor exists. Constraints can be applied to fields of any access type (public, private etc.). Constraints on static fields are not supported, though. Tip：When validating byte code enhanced objects property level constraints should be used, because the byte code enhancing library won’t be able to determine a field access via reflection. 当使用字段级约束时，字段访问策略用于访问要验证的值。 这意味着验证引擎不调用属性访问方法(即使这样的访问方法存在),而是直接访问实例变量。 约束可以应用于访问任何类型(公共，私有等)的字段，但不支持静态字段的约束。 提示：当验证字节码增强对象时，应该使用属性级别约束，因为字节码增强库将不能通过反射来确定字段访问。 2.1.2. Property-level constraintsIf your model class adheres to the JavaBeans standard, it is also possible to annotate the properties of a bean class instead of its fields. Example 2.2, “Property-level constraints” uses the same entity as in Example 2.1, “Field-level constraints”, however, property level constraints are used. 如果你的model类遵循JavaBeans标准，也可以注释一个bean类的属性，而不是它的字段。 示例2.2，“属性级别约束”使用与示例2.1“字段级别约束”中相同的实体类，但是，这里使用属性级别约束。12345678910111213141516171819202122232425262728293031package org.hibernate.validator.referenceguide.chapter02.propertylevel;public class Car &#123; private String manufacturer; private boolean isRegistered; public Car(String manufacturer, boolean isRegistered) &#123; this.manufacturer = manufacturer; this.isRegistered = isRegistered; &#125; @NotNull public String getManufacturer() &#123; return manufacturer; &#125; public void setManufacturer(String manufacturer) &#123; this.manufacturer = manufacturer; &#125; @AssertTrue public boolean isRegistered() &#123; return isRegistered; &#125; public void setRegistered(boolean isRegistered) &#123; this.isRegistered = isRegistered; &#125;&#125; Note:The property’s getter method has to be annotated, not its setter. That way also read-only properties can be constrained which have no setter method When using property level constraints property access strategy is used to access the value to be validated, i.e. the validation engine accesses the state via the property accessor method. Tip：It is recommended to stick either to field or property annotations within one class. It is not recommended to annotate a field and the accompanying getter method as this would cause the field to be validated twice. 注意：必须注解属性的getter方法，而不是它的setter方法。 这种方式也可以约束没有setter方法的只读属性。 当使用属性级别约束时，使用属性访问策略来访问要验证的值，即验证引擎通过属性访问方法来访问状态。 提示：建议注释一个类中的字段或属性。 不建议对字段和附带的getter方法进行注释，因为这会导致该字段被验证两次。 2.1.3. Type argument constraintsStarting from Java 8, it is possible to specify constraints directly on the type argument of a parameterized type. However, this requires that ElementType.TYPE_USE is specified via @Target in the constraint definition. To maintain backwards compatibility, built-in Bean Validation as well as Hibernate Validator specific constraints do not yet specify ElementType.TYPE_USE. To make use of type argument constraints, custom constraints must be used (see Chapter 6, Creating custom constraints). Hibernate Validator validates type arguments constraints specified on collections, map values, java.util.Optional, and custom parameterized types. 从Java 8开始，可以直接在参数化类型的类型参数上指定约束。 但是，这要求在约束定义中通过@Target指定ElementType.TYPE_USE。 为了保持向后兼容性，内置Bean验证以及Hibernate Validator特定的约束还没有指定ElementType.TYPE_USE。 要使用类型参数约束，必须使用自定义约束(请参见第6章，创建自定义约束)。 Hibernate Validator验证指定的集合，map，java.util.Optional和自定义参数化类型等类型参数的约束。 2.1.3.1. With IterableWhen applying constraints on an Iterable type argument, Hibernate Validator will validate each element. Example 2.3, “Type argument constraint on List” shows an example of a List with a type argument constraint. In this example, @ValidPart is a custom constraint allowed to be used in the TYPE_USE context. 当对Iterable类型参数应用约束时，Hibernate Validator将验证每个元素。 示例2.3，“List上的类型参数约束”显示了具有类型参数约束的List的示例。 在此示例中，@ValidPart是允许在TYPE_USE上下文中使用的自定义约束。123456789101112131415161718192021222324252627282930Example 2.3. Type argument constraint on Listpackage org.hibernate.validator.referenceguide.chapter02.typeargument;public class Car &#123; @Valid private List&lt;@ValidPart String&gt; parts = new ArrayList&lt;&gt;(); public void addPart(String part) &#123; parts.add( part ); &#125; //...&#125;Car car = Car();car.addPart( &quot;Wheel&quot; );car.addPart( null );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;&apos;null&apos; is not a valid car part.&quot;, constraintViolations.iterator().next().getMessage());assertEquals( &quot;parts[1].&lt;collection element&gt;&quot;, constraintViolations.iterator().next().getPropertyPath().toString() ); 2.1.3.2. With MapType argument constraints are also validated for map values. Constraints on the key are ignored. Example 2.4, “Type argument constraint on maps” shows an example of a Map value with a type argument constraint. 类型参数约束也针对map验证。 忽略键上的约束。 示例2.4，“map类型参数约束”显示了具有类型参数约束的Map值的示例。1234567891011121314151617181920212223242526272829Example 2.4. Type argument constraint on mapspackage org.hibernate.validator.referenceguide.chapter02.typeargument;public class Car &#123; public static enum FuelConsumption &#123; CITY, HIGHWAY &#125; @Valid private EnumMap&lt;FuelConsumption, @MaxAllowedFuelConsumption Integer&gt; fuelConsumption = new EnumMap&lt;&gt;( FuelConsumption.class ); public void setFuelConsumption(FuelConsumption consumption, int value) &#123; fuelConsumption.put( consumption, value ); &#125; //...&#125;Car car = new Car();car.setFuelConsumption( Car.FuelConsumption.HIGHWAY, 20 );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;20 is outside the max fuel consumption.&quot;, constraintViolations.iterator().next() 2.1.3.3. With java.util.OptionalWhen applying a constraint on the type argument of Optional, Hibernate Validator will automatically unwrap the type and validate the internal value. Example 2.5, “Type argument constraint on Optional” shows an example of an Optional with a type argument constraint. 当对Optional的类型参数应用约束时，Hibernate Validator将自动解包类型并验证内部值。 示例2.5，“Optional上的类型参数约束”显示了一个带有类型参数约束的Optional示例。123456789101112131415161718192021222324252627282930Example 2.5. Type argument constraint on Optionalpackage org.hibernate.validator.referenceguide.chapter02.typeargument;import java.util.ArrayList;import java.util.EnumMap;import java.util.List;import java.util.Optional;import javax.validation.Valid;public class Car &#123; private Optional&lt;@MinTowingCapacity(1000) Integer&gt; towingCapacity = Optional.empty(); public void setTowingCapacity(Integer alias) &#123; towingCapacity = Optional.of( alias ); &#125; //...&#125;Car car = Car();car.setTowingCapacity( 100 );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;Not enough towing capacity.&quot;, constraintViolations.iterator().next().getMessage() );assertEquals( &quot;towingCapacity&quot;, constraintViolations.iterator().next().getPropertyPath().toString() ); 2.1.3.4. With custom parameterized typesType arguments constraints can with two restrictions also be used with custom types. First, a ValidatedValueUnwrapper must be registered for the custom type allowing to retrieve the value to validate (see Section 11.13, “Unwrapping values”). Second, only types with one type arguments are supported. Parameterized types with two or more type arguments are not checked for type argument constraints. This limitation might change in future versions. Example 2.6, “Type argument constraint on custom parameterized type” shows an example of a custom parameterized type with a type argument constraint. 类型参数约束可以有两个限制也可以使用自定义类型。 首先，必须为自定义类型注册ValidatedValueUnwrapper，以允许检索要验证的值(请参见第11.13节“解包值”)。 第二，只支持具有一个类型参数的类型。 不检查具有两个或更多类型参数的参数化类型的类型参数约束。 此限制在将来的版本中可能会更改。 示例2.6，“自定义参数化类型的类型参数约束”显示了具有类型参数约束的自定义参数化类型的示例。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Example 2.6. Type argument constraint on custom parameterized typepackage org.hibernate.validator.referenceguide.chapter02.typeargument;public class Car &#123; private GearBox&lt;@MinTorque(100) Gear&gt; gearBox; public void setGearBox(GearBox&lt;Gear&gt; gearBox) &#123; this.gearBox = gearBox; &#125; //...&#125;package org.hibernate.validator.referenceguide.chapter02.typeargument;public class GearBox&lt;T extends Gear&gt; &#123; private final T gear; public GearBox(T gear) &#123; this.gear = gear; &#125; public Gear getGear() &#123; return this.gear; &#125;&#125;package org.hibernate.validator.referenceguide.chapter02.typeargument;public class Gear &#123; private final Integer torque; public Gear(Integer torque) &#123; this.torque = torque; &#125; public Integer getTorque() &#123; return torque; &#125; public static class AcmeGear extends Gear &#123; public AcmeGear() &#123; super( 100 ); &#125; &#125;&#125;package org.hibernate.validator.referenceguide.chapter02.typeargument;public class GearBoxUnwrapper extends ValidatedValueUnwrapper&lt;GearBox&gt; &#123; @Override public Object handleValidatedValue(GearBox gearBox) &#123; return gearBox == null ? null : gearBox.getGear(); &#125; @Override public Type getValidatedValueType(Type valueType) &#123; return Gear.class; &#125;&#125;Car car = Car();car.setGearBox( new GearBox&lt;&gt;( new Gear.AcmeGear() ) );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;Gear is not providing enough torque.&quot;, constraintViolations.iterator().next().getMessage() );assertEquals( &quot;gearBox&quot;, constraintViolations.iterator().next().getPropertyPath().toString() ); 2.1.4. Class-level constraintsLast but not least, a constraint can also be placed on the class level. In this case not a single property is subject of the validation but the complete object. Class-level constraints are useful if the validation depends on a correlation between several properties of an object. 最后但并非不重要的是，约束也可以放在类级别上。 在这种情况下，单个属性不是验证的主体，而是完整的对象。 如果验证取决于对象的几个属性之间的相关性，则类级别约束很有用。 The Car class in Example 2.7, “Class-level constraint” has the two attributes seatCount and passengers and it should be ensured that the list of passengers has not more entries than seats are available. For that purpose the @ValidPassengerCount constraint is added on the class level. The validator of that constraint has access to the complete Car object, allowing to compare the numbers of seats and passengers. 例2.7中的Car类，“类级约束”具有座位数和乘客的两个属性，并且应该确保乘客没有多余座位。 为此，在类级别上添加@ValidPassengerCount约束。 该约束的验证器可以访问完整的Car对象，允许比较座位和乘客的数量。 Refer to Section 6.2, “Class-level constraints” to learn in detail how to implement this custom constraint. 请参见第6.2节“类级约束”以详细了解如何实现此自定义约束。12345678910111213Example 2.7. Class-level constraintpackage org.hibernate.validator.referenceguide.chapter02.classlevel;@ValidPassengerCountpublic class Car &#123; private int seatCount; private List&lt;Person&gt; passengers; //...&#125; 2.1.5. Constraint inheritanceWhen a class implements an interface or extends another class, all constraint annotations declared on the super-type apply in the same manner as the constraints specified on the class itself. To make things clearer let’s have a look at the following example: 当类实现接口或扩展另一个类时，在超类上声明的所有约束注释都以与在类本身指定约束相同的方式应用。 为了使事情更清楚，让我们看看下面的例子：1234567891011121314151617181920212223242526272829Example 2.8. Constraint inheritancepackage org.hibernate.validator.referenceguide.chapter02.inheritance;public class Car &#123; private String manufacturer; @NotNull public String getManufacturer() &#123; return manufacturer; &#125; //...&#125;package org.hibernate.validator.referenceguide.chapter02.inheritance;public class RentalCar extends Car &#123; private String rentalStation; @NotNull public String getRentalStation() &#123; return rentalStation; &#125; //...&#125; Here the class RentalCar is a subclass of Car and adds the property rentalStation. If an instance of RentalCar is validated, not only the @NotNull constraint on rentalStation is evaluated, but also the constraint on manufacturer from the parent class. 这里类RentalCar是Car的子类，并添加了属性rentalStation。 如果验证RentalCar的实例，则不仅评估rentalStation上的@NotNull约束，而且评估父类对manufacturer的约束。 The same would be true, if Car was not a superclass but an interface implemented by RentalCar. 如果Car不是一个超类，而是一个由RentalCar实现的接口,同样的情况也是如此。 Constraint annotations are aggregated if methods are overridden. So if RentalCar overrode the getManufacturer() method from Car, any constraints annotated at the overriding method would be evaluated in addition to the @NotNull constraint from the superclass. 如果方法被覆盖，则会聚合约束注释。 因此，如果RentalCar从Car上覆盖了getManufacturer()方法，那么除了来自超类的@NotNull约束之外，还将评估在重写方法中注释的任何约束。 2.1.6. Object graphsThe Bean Validation API does not only allow to validate single class instances but also complete object graphs (cascaded validation). To do so, just annotate a field or property representing a reference to another object with @Valid as demonstrated in Example 2.9, “Cascaded validation”. Bean验证API不仅允许验证单个类实例，还允许完成对象图(级联验证)。 为此，只需使用@Valid注释表示对另一个对象的引用的字段或属性，如示例2.9“级联验证”中所示。1234567891011121314151617181920212223Example 2.9. Cascaded validationpackage org.hibernate.validator.referenceguide.chapter02.objectgraph;public class Car &#123; @NotNull @Valid private Person driver; //...&#125;package org.hibernate.validator.referenceguide.chapter02.objectgraph;public class Person &#123; @NotNull private String name; //...&#125; If an instance of Car is validated, the referenced Person object will be validated as well, as the driver field is annotated with @Valid. Therefore the validation of a Car will fail if the name field of the referenced Person instance is null. 如果Car的实例被验证，因为driver字段用@Valid注释，所以引用的Person对象也将被验证。 因此，如果引用的Person实例的名称字段为null，那么Car的验证将失败。 The validation of object graphs is recursive, i.e. if a reference marked for cascaded validation points to an object which itself has properties annotated with @Valid, these references will be followed up by the validation engine as well. The validation engine will ensure that no infinite loops occur during cascaded validation, for example if two objects hold references to each other. 对象图的验证是递归的，即如果标记为级联验证的引用指向用@Valid注释属性的对象，则验证引擎也将跟随这些引用。 验证引擎将确保在级联验证期间不发生无限循环，例如，如果两个对象保存对彼此的引用。 Note that null values are getting ignored during cascaded validation. 请注意，级联验证期间忽略空值。 Object graph validation also works for collection-typed fields. That means any attributes that 对象图验证也适用于集合类型的字段。 这意味着任何属性： are arrays implement java.lang.Iterable (especially Collection, List and Set) implement java.util.Mapcan be annotated with @Valid, which will cause each contained element to be validated, when the parent object is validated. 可以用@Valid注释，这将在验证父对象时验证每个包含的元素。123456789101112Example 2.10. Cascaded validation of a collectionpackage org.hibernate.validator.referenceguide.chapter02.objectgraph.list;public class Car &#123; @NotNull @Valid private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;(); //...&#125; So when validating an instance of the Car class shown in Example 2.10, “Cascaded validation of a collection”, a ConstraintViolation will be created, if any of the Person objects contained in the passengers list has a null name. 因此，在验证示例2.10“集合的级联验证”中显示的Car类的实例时，如果乘客列表中包含的任何Person对象具有空名称，则将创建ConstraintViolation。 2.2. Validating bean constraintsThe Validator interface is the most important object in Bean Validation. The next section shows how to obtain an Validator instance. Afterwards you’ll learn how to use the different methods of the Validator interface. Validator接口是Bean验证中最重要的对象。 下一节将介绍如何获取Validator实例。 之后，您将学习如何使用Validator接口的不同方法。 2.2.1. Obtaining a Validator instanceThe first step towards validating an entity instance is to get hold of a Validator instance. The road to this instance leads via the Validation class and a ValidatorFactory. The easiest way is to use the static method Validation#buildDefaultValidatorFactory(): 验证实体实例的第一步是获取Validator实例。 获取这个实例的路径是通过Validation类和ValidatorFactory。 最简单的方法是使用静态方法Validation＃buildDefaultValidatorFactory()：1234Example 2.11. Validation#buildDefaultValidatorFactory()ValidatorFactory factory = Validation.buildDefaultValidatorFactory();Validator validator = factory.getValidator(); This bootstraps a validator in the default configuration. Refer to Chapter 8, Bootstrapping to learn more about the different bootstrapping methods and how to obtain a specifically configured Validator instance. 这将在默认配置中引导验证程序。 有关详细信息，请参阅第8章“引导”，了解不同的引导方法以及如何获取特殊配置的Validator实例。 2.2.2. Validator methodsThe Validator interface contains three methods that can be used to either validate entire entities or just single properties of the entity. All three methods return a Set&lt;ConstraintViolation&gt;. The set is empty, if the validation succeeds. Otherwise a ConstraintViolation instance is added for each violated constraint. All the validation methods have a var-args parameter which can be used to specify, which validation groups shall be considered when performing the validation. If the parameter is not specified the default validation group (javax.validation.groups.Default) is used. The topic of validation groups is discussed in detail in Chapter 5, Grouping constraints. Validator接口包含三个方法，可用于验证整个实体或仅验证实体的单个属性。 所有三个方法都返回一个Set&lt;ConstraintViolation&gt;。 如果验证成功，则该集合为空。 否则，为每个违反的约束添加一个约束违例实例。 所有验证方法都有一个var-args参数，可用于指定在执行验证时应考虑哪些验证组。 如果未指定参数，则使用缺省验证组(javax.validation.groups.Default)。 第5章“分组约束”中详细讨论了验证组的主题。 2.2.2.1. Validator#validate()Use the validate() method to perform validation of all constraints of a given bean. Example 2.12, “Using Validator#validate()” shows the validation of an instance of the Car class from Example 2.2, “Property-level constraints” which fails to satisfy the @NotNull constraint on the manufacturer property. The validation call therefore returns one ConstraintViolation object. 使用validate()方法来执行给定bean的所有约束的验证。 例2.12，“使用Validator＃validate()”显示来自例2.2“属性级别约束”的Car类的实例的验证，它不能满足制造商属性的@NotNull约束。 验证调用因此返回一个ConstraintViolation对象。12345678Example 2.12. Using Validator#validate()Car car = new Car( null, true );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;may not be null&quot;, constraintViolations.iterator().next().getMessage() ); 2.2.2.2. Validator#validateProperty()With help of the validateProperty() you can validate a single named property of a given object. The property name is the JavaBeans property name. 在validateProperty()的帮助下，您可以验证给定对象的单个命名属性。 属性名称是JavaBeans属性名称。 1234567891011Example 2.13. Using Validator#validateProperty()Car car = new Car( null, true );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty( car, &quot;manufacturer&quot;);assertEquals( 1, constraintViolations.size() );assertEquals( &quot;may not be null&quot;, constraintViolations.iterator().next().getMessage() ); 2.2.2.3. Validator#validateValue()By using the validateValue() method you can check whether a single property of a given class can be validated successfully, if the property had the specified value: 通过使用validateValue()方法，您可以检查给定类的单个属性是否可以成功验证，如果属性具有指定的值：12345678910Example 2.14. Using Validator#validateValue()Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue( Car.class, &quot;manufacturer&quot;, null);assertEquals( 1, constraintViolations.size() );assertEquals( &quot;may not be null&quot;, constraintViolations.iterator().next().getMessage() );--- Note:@Valid is not honored by validateProperty() or validateValue(). 注意：@Valid不受validateProperty()或validateValue()支持。 Validator#validateProperty() is for example used in the integration of Bean Validation into JSF 2 (see Section 10.2, “JSF &amp; Seam”) to perform a validation of the values entered into a form before they are propagated to the model. Validator＃validateProperty()例如用于将Bean验证集成到JSF 2(参见第10.2节“JSF和Seam”)中，以便在将输入到表单中的值传播到模型之前对其进行验证。 2.2.3. ConstraintViolation methodsNow it is time to have a closer look at what a ConstraintViolation is. Using the different methods of ConstraintViolation a lot of useful information about the cause of the validation failure can be determined. Table 2.1, “The various ConstraintViolation methods” gives an overview of these methods. The values in the “Example” column refer to Example 2.12, “Using Validator#validate()”. 现在是时候仔细观察一下ConstraintViolation是什么。 使用ConstraintViolation的不同方法，可以确定关于验证失败的原因的许多有用信息。 表2.1，“各种约束违背方法”给出了这些方法的概述。 “示例”列中的值引用示例2.12，“Using Validator＃validate()”。Table 2.1. The various ConstraintViolation methods Method Usage Example getMessage() The interpolated error message “may not be null” getMessageTemplate() The non-interpolated error message “{…​ NotNull.message}” getRootBean() The root bean being validated car getRootBeanClass() The class of the root bean being validated Car.class getLeafBean() If a bean constraint, the bean instance the constraint is applied on; If a property constraint, the bean instance hosting the property the constraint is applied on car getPropertyPath() The property path to the validated value from root bean contains one node with kind PROPERTY and name “manufacturer” getInvalidValue() The value failing to pass the constraint null getConstraintDescriptor() Constraint metadata reported to fail descriptor for @NotNull 2.3. Built-in constraintsHibernate Validator comprises a basic set of commonly used constraints. These are foremost the constraints defined by the Bean Validation specification (see Table 2.2, “Bean Validation constraints”). Additionally, Hibernate Validator provides useful custom constraints (see Table 2.3, “Custom constraints” and Table 2.4, “Custom country specific constraints”). Hibernate Validator包含一组基本的常用约束。 这些首先是Bean验证规范定义的约束(见表2.2“Bean验证约束”)。 此外，Hibernate Validator提供了有用的自定义约束(见表2.3“自定义约束”和表2.4“自定义国家特定约束”)。 2.3.1. Bean Validation constraintsTable 2.2, “Bean Validation constraints” shows purpose and supported data types of all constraints specified in the Bean Validation API. All these constraints apply to the field/property level, there are no class-level constraints defined in the Bean Validation specification. If you are using the Hibernate object-relational mapper, some of the constraints are taken into account when creating the DDL for your model (see column “Hibernate metadata impact”). 表2.2“Bean验证约束”显示了Bean验证API中指定的所有约束的目的和受支持的数据类型。 所有这些约束适用于字段/属性级别，没有在Bean验证规范中定义的类级别约束。 如果使用Hibernate对象关系映射器，在为模型创建DDL时会考虑一些约束(请参阅“Hibernate元数据影响”一栏)。 Note:Hibernate Validator allows some constraints to be applied to more data types than required by the Bean Validation specification (e.g. @Max can be applied to strings). Relying on this feature can impact portability of your application between Bean Validation providers. 注意:Hibernate Validator允许将一些约束应用于Bean验证规范所要求的更多数据类型(例如@Max可以应用于字符串)。 依赖此功能可能会影响应用程序与Bean验证提供程序之间的可移植性。 Annotation Supported data types Use Hibernate metadata impact @AssertFalse Boolean, boolean Checks that the annotated element is false None @AssertTrue Boolean, boolean Checks that the annotated element is true None @DecimalMax(value=,inclusive=) BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of Number Checks whether the annotated value is less than the specified maximum, when inclusive=false. Otherwise whether the value is less than or equal to the specified maximum. The parameter value is the string representation of the max value according to the BigDecimal string representation. None @DecimalMin(value=,inclusive=) BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of Number Checks whether the annotated value is larger than the specified minimum, when inclusive=false. Otherwise whether the value is larger than or equal to the specified minimum. The parameter value is the string representation of the min value according to the BigDecimal string representation. None @Digits(integer=,fraction=) BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of Number Checks whether the annotated value is a number having up to integer digits and fraction fractional digits Defines column precision and scale @Future java.util.Date, java.util.Calendar, java.time.chrono.ChronoZonedDateTime, java.time.Instant, java.time.OffsetDateTime; Additionally supported by HV, if the Joda Time date/time API is on the class path: any implementations of ReadablePartial and ReadableInstant Checks whether the annotated date is in the future None @Max(value=) BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the character sequence is evaluated), any sub-type of Number Checks whether the annotated value is less than or equal to the specified maximum Adds a check constraint on the column @Min(value=) BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the char sequence is evaluated), any sub-type of Number Checks whether the annotated value is higher than or equal to the specified minimum Adds a check constraint on the column @NotNull Any type Checks that the annotated value is not null. Column(s) are not nullable @Null Any type Checks that the annotated value is null None @Past java.util.Date, java.util.Calendar, java.time.chrono.ChronoZonedDateTime, java.time.Instant, java.time.OffsetDateTime; Additionally supported by HV, if the Joda Time date/time API is on the class path: any implementations of ReadablePartial and ReadableInstant Checks whether the annotated date is in the past None @Pattern(regex=,flag=) CharSequence Checks if the annotated string matches the regular expression regex considering the given flag match None @Size(min=, max=) CharSequence, Collection, Map and arrays Checks if the annotated element’s size is between min and max (inclusive) Column length will be set to max @Valid Any non-primitive type Performs validation recursively on the associated object. If the object is a collection or an array, the elements are validated recursively. If the object is a map, the value elements are validated recursively. None Note:On top of the parameters indicated in Table 2.2, “Bean Validation constraints” each constraint has the parameters message, groups and payload. This is a requirement of the Bean Validation specification. 注意：除了表2.2“Bean验证约束”中指示的参数之外，每个约束都有参数message，groups和payload。 这是Bean验证规范的要求。 2.3.2. Additional constraintsIn addition to the constraints defined by the Bean Validation API Hibernate Validator provides several useful custom constraints which are listed in Table 2.3, “Custom constraints”. With one exception also these constraints apply to the field/property level, only @ScriptAssert is a class- level constraint. 除了Bean Validation API定义的约束外，Hibernate Validator还提供了几个有用的自定义约束，如表2.3“自定义约束”中所列。 有一个例外，这些约束适用于字段/属性级别，只有@ScriptAssert是类级别约束。 Table 2.3. Custom constraints Annotation Supported data types Use Hibernate metadata impact @CreditCardNumber(ignoreNonDigitCharacters=) CharSequence Checks that the annotated character sequence passes the Luhn checksum test. Note, this validation aims to check for user mistakes, not credit card validity! See also Anatomy of Credit Card Numbers. ignoreNonDigitCharacters allows to ignore non digit characters. The default is false. None @EAN CharSequence Checks that the annotated character sequence is a valid EAN barcode. type determines the type of barcode. The default is EAN-13. None @Email CharSequence Checks whether the specified character sequence is a valid email address. The optional parameters regexp and flags allow to specify an additional regular expression (including regular expression flags) which the email must match. None @Length(min=,max=) CharSequence Validates that the annotated character sequence is between min and max included Column length will be set to max @LuhnCheck(startIndex= ,endIndex=,checkDigitIndex=,ignoreNonDigitCharacters=) CharSequence Checks that the digits within the annotated character sequence pass the Luhn checksum algorithm (see also Luhn algorithm). startIndex and endIndex allow to only run the algorithm on the specified sub-string. checkDigitIndex allows to use an arbitrary digit within the character sequence as the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, ignoreNonDigitCharacters allows to ignore non digit characters. None @Mod10Check(multiplier=,weight=,startIndex=,endIndex=,checkDigitIndex=,ignoreNonDigitCharacters=) CharSequence Checks that the digits within the annotated character sequence pass the generic mod 10 checksum algorithm. multiplier determines the multiplier for odd numbers (defaults to 3), weight the weight for even numbers (defaults to 1). startIndex and endIndex allow to only run the algorithm on the specified sub-string. checkDigitIndex allows to use an arbitrary digit within the character sequence as the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, ignoreNonDigitCharacters allows to ignore non digit characters. None @Mod11Check(threshold=,startIndex=,endIndex=,checkDigitIndex=,ignoreNonDigitCharacters=,treatCheck10As=,treatCheck11As=) CharSequence Checks that the digits within the annotated character sequence pass the mod 11 checksum algorithm. threshold specifies the threshold for the mod11 multiplier growth; if no value is specified the multiplier will grow indefinitely. treatCheck10As and treatCheck11As specify the check digits to be used when the mod 11 checksum equals 10 or 11, respectively. Default to X and 0, respectively. startIndex, endIndex checkDigitIndex and ignoreNonDigitCharacters carry the same semantics as in @Mod10Check. None @NotBlank CharSequence Checks that the annotated character sequence is not null and the trimmed length is greater than 0. The difference to @NotEmpty is that this constraint can only be applied on strings and that trailing white-spaces are ignored. None @NotEmpty CharSequence, Collection, Map and arrays Checks whether the annotated element is not null nor empty None @Range(min=,max=) BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types Checks whether the annotated value lies between (inclusive) the specified minimum and maximum None @SafeHtml(whitelistType= ,additionalTags=,additionalTagsWithAttributes=) CharSequence Checks whether the annotated value contains potentially malicious fragments such as &lt;script/&gt;. In order to use this constraint, the jsoup library must be part of the class path. With the whitelistType attribute a predefined whitelist type can be chosen which can be refined via additionalTags or additionalTagsWithAttributes. The former allows to add tags without any attributes, whereas the latter allows to specify tags and optionally allowed attributes using the annotation @SafeHtml.Tag. None @ScriptAssert(lang=,script=,alias=) Any type Checks whether the given script can successfully be evaluated against the annotated element. In order to use this constraint, an implementation of the Java Scripting API as defined by JSR 223 (“Scripting for the JavaTM Platform”) must part of the class path. The expressions to be evaluated can be written in any scripting or expression language, for which a JSR 223 compatible engine can be found in the class path. None @URL(protocol=,host=,port=,regexp=,flags=) CharSequence Checks if the annotated character sequence is a valid URL according to RFC2396. If any of the optional parameters protocol, host or port are specified, the corresponding URL fragments must match the specified values. The optional parameters regexp and flags allow to specify an additional regular expression (including regular expression flags) which the URL must match. Per default this constraint used the java.net.URL constructor to verify whether a given string represents a valid URL. A regular expression based version is also available - RegexpURLValidator - which can be configured via XML (see Section 7.2, “Mapping constraints via constraint-mappings”) or the programmatic API (see Section 11.14.2, “Adding constraint definitions programmatically”). None 2.3.2.1. Country specific constraintsHibernate Validator offers also some country specific constraints, e.g. for the validation of social security numbers. Hibernate验证器还提供一些国家特定的约束，例如。 用于验证社会保障号码。 Note:If you have to implement a country specific constraint, consider making it a contribution to Hibernate Validator! 注意：如果你必须实现一个国家特定的约束，考虑使它成为Hibernate验证器的一个贡献！ Table 2.4. Custom country specific constraints Annotation Supported data types Use Country Hibernate metadata impact @CNPJ CharSequence Checks that the annotated character sequence represents a Brazilian corporate tax payer registry number (Cadastro de Pessoa Juríeddica) Brazil None @CPF CharSequence Checks that the annotated character sequence represents a Brazilian individual taxpayer registry number (Cadastro de Pessoa Fídsica) Brazil None @TituloEleitoral CharSequence Checks that the annotated character sequence represents a Brazilian voter ID card number (Título Eleitoral) Brazil None Tip:In some cases neither the Bean Validation constraints nor the custom constraints provided by Hibernate Validator will fulfill your requirements. In this case you can easily write your own constraint. You can find more information in Chapter 6, Creating custom constraints. 提示：在某些情况下，Bean验证约束和Hibernate Validator提供的自定义约束都不能满足您的要求。 在这种情况下，您可以轻松地编写自己的约束。 您可以在第6章“创建自定义约束”中找到更多信息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate Validator官方文档 -- 第1章]]></title>
      <url>%2F2016%2F11%2F10%2FHibernate%20Validator%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3--%E7%AC%AC1%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[Hibernate Validator官方文档 – 第1章 入门 1. Getting started1.1. Project set upIn order to use Hibernate Validator within a Maven project, simply add the following dependency to your pom.xml:12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.2.Final&lt;/version&gt;&lt;/dependency&gt; 1.1.1. Unified ELHibernate Validator requires an implementation of the Unified Expression Language (JSR 341) for evaluating dynamic expressions in constraint violation messages (see Section 4.1, “Default message interpolation”). When your application runs in a Java EE container such as JBoss AS, an EL implementation is already provided by the container. In a Java SE environment, however, you have to add an implementation as dependency to your POM file. For instance you can add the following two dependencies to use the JSR 341 reference implementation: Hibernate Validator需要实现统一表达式语言(JSR 341)来评估约束违反消息中的动态表达式(参见第4.1节“默认消息插值”)。 当应用程序在Java EE容器(如JBoss AS)中运行时，容器已经提供了EL实现。 但在Java SE环境中，您必须将实现作为依赖关系添加到POM文件中。 例如，您可以添加以下两个依赖关系来使用JSR 341参考实现：12345678910&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt; 1.1.2. CDIBean Validation defines integration points with CDI (Contexts and Dependency Injection for Java TM EE, JSR 346). If your application runs in an environment which does not provide this integration out of the box, you may use the Hibernate Validator CDI portable extension by adding the following Maven dependency to your POM: Bean验证使用CDI(Java TM EE，JSR 346的上下文和依赖注入)定义集成点。 如果您的应用程序在一个不提供此集成的环境中运行，您可通过添Maven依赖使用Hibernate Validator CDI便携式扩展:12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-cdi&lt;/artifactId&gt; &lt;version&gt;5.3.2.Final&lt;/version&gt;&lt;/dependency&gt; Note that adding this dependency is usually not required for applications running on a Java EE application server. You can learn more about the integration of Bean Validation and CDI in Section 10.3, “CDI”. 请注意，通常不需要在Java EE应用程序服务器上运行的应用程序添加此依赖关系。 您可以在第10.3节“CDI”中了解有关Bean验证和CDI的集成的更多信息。1.1.3. Running with a security managerHibernate Validator supports running with a security manager being enabled. To do so, you must assign several permissions to the Hibernate Validator and the Bean Validation API code bases. The following shows how to do this via a policy file as processed by the Java default policy implementation: Hibernate Validator支持在启用安全管理器的情况下运行。 为此，您必须为Hibernate验证器和Bean验证API代码库分配多个权限。 下面显示了如何通过Java默认策略实现处理的策略文件执行此操作：1234567891011grant codeBase &quot;file:path/to/hibernate-validator-5.3.2.Final.jar&quot; &#123; permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;; permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;; // Only needed when working with XML descriptors (validation.xml or XML constraint mappings) permission java.util.PropertyPermission &quot;mapAnyUriToUri&quot;, &quot;read&quot;;&#125;;grant codeBase &quot;file:path/to/validation-api-1.1.0.Final.jar&quot; &#123; permission java.io.FilePermission &quot;path/to/hibernate-validator-5.3.2.Final.jar&quot;, &quot;read&quot;;&#125;; 1.2. Applying constraint 应用约束Lets dive directly into an example to see how to apply constraints. 让我们直接实现一个例子，看看如何应用约束。1234567891011121314151617181920212223242526package org.hibernate.validator.referenceguide.chapter01;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;public class Car &#123; @NotNull private String manufacturer; @NotNull @Size(min = 2, max = 14) private String licensePlate; @Min(2) private int seatCount; public Car(String manufacturer, String licencePlate, int seatCount) &#123; this.manufacturer = manufacturer; this.licensePlate = licencePlate; this.seatCount = seatCount; &#125; //getters and setters ...&#125; The @NotNull, @Size and @Min annotations are used to declare the constraints which should be applied to the fields of a Car instance: @NotNull，@Size和@Min注释用于声明应该应用于Car实例的字段的约束： manufacturer must never be null 制造商不能为空 licensePlate must never be null and must be between 2 and 14 characters long 车牌照不为长度在2~14之间 seatCount must be at least 2 座位至少有两个1.3. Validating constraints 验证约束To perform a validation of these constraints, you use a Validator instance. Let’s have a look at a unit test for Car: 要执行这些约束的验证，您需要使用一个Validator实例。 让我们来看看汽车的单元测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.hibernate.validator.referenceguide.chapter01;import java.util.Set;import javax.validation.ConstraintViolation;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.ValidatorFactory;import org.junit.BeforeClass;import org.junit.Test;import static org.junit.Assert.assertEquals;public class CarTest &#123; private static Validator validator; @BeforeClass public static void setUpValidator() &#123; ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); validator = factory.getValidator(); &#125; @Test public void manufacturerIsNull() &#123; Car car = new Car( null, &quot;DD-AB-123&quot;, 4 ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car ); assertEquals( 1, constraintViolations.size() ); assertEquals( &quot;may not be null&quot;, constraintViolations.iterator().next().getMessage() ); &#125; @Test public void licensePlateTooShort() &#123; Car car = new Car( &quot;Morris&quot;, &quot;D&quot;, 4 ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car ); assertEquals( 1, constraintViolations.size() ); assertEquals( &quot;size must be between 2 and 14&quot;, constraintViolations.iterator().next().getMessage() ); &#125; @Test public void seatCountTooLow() &#123; Car car = new Car( &quot;Morris&quot;, &quot;DD-AB-123&quot;, 1 ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car ); assertEquals( 1, constraintViolations.size() ); assertEquals( &quot;must be greater than or equal to 2&quot;, constraintViolations.iterator().next().getMessage() ); &#125; @Test public void carIsValid() &#123; Car car = new Car( &quot;Morris&quot;, &quot;DD-AB-123&quot;, 2 ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car ); assertEquals( 0, constraintViolations.size() ); &#125;&#125; In the setUp() method a Validator object is retrieved from the ValidatorFactory. A Validator instance is thread-safe and may be reused multiple times. It thus can safely be stored in a static field and be used in the test methods to validate the different Car instances. The validate() method returns a set of ConstraintViolation instances, which you can iterate over in order to see which validation errors occurred. The first three test methods show some expected constraint violations: The @NotNull constraint on manufacturer is violated in manufacturerIsNull() The @Size constraint on licensePlate is violated in licensePlateTooShort() The @Min constraint on seatCount is violated in seatCountTooLow() If the object validates successfully, validate() returns an empty set as you can see in carIsValid().Note that only classes from the package javax.validation are used. These are provided from the Bean Validation API. No classes from Hibernate Validator are directly referenced, resulting in portable code. 在setUp()方法中，从ValidatorFactory取出Validator对象。 Validator实例是线程安全的，可以重复使用多次。 因此它可以安全地存储在静态字段中，并在测试方法中用于验证不同的Car实例。 validate()方法返回一组ConstraintViolation实例，您可以迭代它们以查看发生了哪些验证错误。 前三个测试方法显示一些预期的约束违反： The @NotNull constraint on manufacturer is violated in manufacturerIsNull() The @Size constraint on licensePlate is violated in licensePlateTooShort() The @Min constraint on seatCount is violated in seatCountTooLow() 如果对象验证成功，validate()返回一个空的set集合，你可以在carIsValid()中看到。注意，这我们只使用包javax.validation中的类。 他们是Bean Validation API提供的。没有直接引用来自Hibernate Validator的类，所以可移植代码。 1.4. Java 8 supportJava 8 introduces several enhancements which are valuable from a Hibernate Validator point of view. This section briefly introduces the Hibernate Validator features based on Java 8. They are only available in Hibernate Validator 5.2 and later. Java 8引入了几个从Hibernate Validator的角度来看有价值的增功能。 本节简要介绍基于Java 8的Hibernate Validator功能。它们仅在Hibernate Validator 5.2和更高版本中可用。 1.4.1. Type arguments constraintsIn Java 8 it is possible to use annotations in any location a type is used. This includes type arguments. Hibernate Validator supports the validation of constraints defined on type arguments of collections, maps, and custom parameterized types. The Section 2.1.3, “Type argument constraints” chapter provides further information on how to apply and use type argument constraints. 在Java 8中，可以在使用类型的任何位置使用注释。 这包括类型参数。 Hibernate Validator支持对集合，Map和自定义参数化类型等类型参数的约束验证。 第2.1.3节“类型参数约束”一章提供了有关如何应用和使用类型参数约束的更多信息。 1.4.2. Actual parameter namesThe Java 8 Reflection API can now retrieve the actual parameter names of a method or constructor. Hibernate Validator uses this ability to report the actual parameter names instead of arg0, arg1, etc. The Section 8.2.4, “ParameterNameProvider” chapter explains how to use the new reflection based parameter name provider. Java 8反射API可以检索方法或构造函数的实际参数名称。 Hibernate Validator可使用此功能显示实际的参数名称而不是arg0，arg1等。第8.2.4节“ParameterNameProvider”一章解释了如何使用基于新反射提供的参数名称提供程序。 1.4.3. New date/time APIJava 8 introduces a new date/time API. Hibernate Validator provides full support for the new API where @Future and @Past constraints can be applied on the new types. The table Table 2.2, “Bean Validation constraints” shows the types supported for @Future and @Past, including the types from the new API. Java 8引入了一个新的日期/时间API。 Hibernate Validator提供对新API的完全支持，其中@Future和@Past约束可以应用于新类型。 表2.2“Bean验证约束”显示了@Future和@Past支持的类型，包括来自新API的类型。 1.4.4. Optional typeHibernate Validator provides also support for Java 8 Optional type, by unwrapping the Optional instance and validating the internal value. Section 11.13.1, “Optional unwrapper” provides examples and a further discussion. Hibernate Validator还通过解包可选实例并验证内部值提供对Java 8可选类型的支持。 第11.13.1节“可选解包器”提供了示例和进一步讨论。 1.5. Where to go next?That concludes the 5 minute tour through the world of Hibernate Validator and Bean Validation. Continue exploring the code examples or look at further examples referenced in Chapter 13, Further reading. To learn more about the validation of beans and properties, just continue reading Chapter 2, Declaring and validating bean constraints. If you are interested in using Bean Validation for the validation of method pre- and postcondition refer to Chapter 3, Declaring and validating method constraints. In case your application has specific validation requirements have a look at Chapter 6, Creating custom constraints. 至此Hibernate Validator和Bean Validation世界的5分钟旅游结束。可继续探索代码示例或进一步阅读第13章中提及的更多示例。 要了解有关bean和属性验证的更多信息，只需继续阅读第2章声明和验证bean约束。 如果您有兴趣使用Bean验证来验证方法的前后条件，请参考第3章声明和验证方法约束。 如果您的应用程序有特定的验证要求，请参阅第6章创建自定义约束。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Velocity用户手册]]></title>
      <url>%2F2016%2F11%2F06%2FVelocity%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C%2F</url>
      <content type="text"><![CDATA[Velocity用户手册 (Version:1.7) 原文 What is Velocity? 什么是Velocity?Velocity is a Java-based template engine. It permits web page designers to reference methods defined in Java code. Web designers can work in parallel with Java programmers to develop web sites according to the Model-View-Controller (MVC) model, meaning that web page designers can focus solely on creating a well-designed site, and programmers can focus solely on writing top-notch code. Velocity separates Java code from the web pages, making the web site more maintainable over the long run and providing a viable alternative to Java Server Pages (JSPs) or PHP. Velocity是一个基于Java的模板引擎。 它允许网页设计者引用在Java代码中定义的方法。 网页设计师可以与Java程序员根据MVC模型同时开发网站，这意味着网页设计者可以专注于精心设计网站，程序员可以专注于写top-notch代码。 Velocity将Java代码与网页分离，使网站更易于维护，并为Java Server Pages（JSP）或PHP提供了替代方案。 Velocity can be used to generate web pages, SQL, PostScript and other output from templates. It can be used either as a standalone utility for generating source code and reports, or as an integrated component of other systems. When complete, Velocity will provide template services for the Turbine web application framework. Velocity+Turbine will provide a template service that will allow web applications to be developed according to a true MVC model. Velocity可以使用模板生成网页，SQL，PostScript等。 它可以用作生成源代码和报告的独立实用程序，也可以用作其他系统的集成组件。 完成后，Velocity将为Turbine Web应用程序框架提供模板服务。 Velocity + Turbine将提供一个模板服务，允许根据MVC模型开发Web应用程序。 What can Velocity do for me? Velocity能做什么The Mud Store Example Mud 商店实例Velocity Template Language (VTL): An Introduction Velocity模板语言 (VTL): 简介VTL uses references to embed dynamic content in a web site, and a variable is one type of reference. Variables are one type of reference that can refer to something defined in the Java code, or it can get its value from a VTL statement in the web page itself. Here is an example of a VTL statement that could be embedded in an HTML document: VTL使用引用动态将内容嵌入到网站中，变量也是一种类型的引用，它可以引用在Java代码中定义的东西，也可以从网页本身的VTL语句获得值。 下面是可以嵌入到HTML文档中的VTL语句的示例：1#set( $a = &quot;Velocity&quot; ) This VTL statement, like all VTL statements, begins with the # character and contains a directive: set. When an online visitor requests your web page, the Velocity Templating Engine will search through your web page to find all # characters, then determine which mark the beginning of VTL statements, and which of the # characters that have nothing to do with VTL. 这个VTL语句和所有VTL语句一样，以＃字符开头，并包含一条指令：set。 当在线访问者请求您的网页时，Velocity模板引擎将搜索您的网页查找所有＃个字符，然后确定哪个标记是VTL语句的开头，哪个是与VTL无关的＃个字符。 The # character is followed by a directive, set. The set directive uses an expression (enclosed in brackets) – an equation that assigns a value to a variable. The variable is listed on the left hand side and its value on the right hand side; the two are separated by an = character. ＃字符后面是一个指令，set。 set指令使用一个表达式（括在括号中） – 一个变量的赋值语句。 变量在左侧列出，其值在右侧; 两个用=字符分隔。 The following rule of thumb may be useful to better understand how Velocity works: References begin with $ and are used to get something. Directives begin with # and are used to do something. 下面的规则可能有助于更好地理解Velocity的工作：引用以$开头，用于获取值。 指令以＃开头，用于设置值。 In the example above, #set is used to assign a value to a variable. The variable, $a, can then be used in the template to output “Velocity”. 在上面的示例中，#set用于为变量赋值。 然后可以在模板中使用$a输出“Velocity”。 Hello Velocity World! Velocity简单实例:Hello Velocity World123456&lt;html&gt; &lt;body&gt; #set( $foo = &quot;Velocity&quot; ) Hello $foo World! &lt;/body&gt;&lt;/html&gt; The result is a web page that prints “Hello Velocity World!”. 网页将会输出”Hello Velocity World!” To make statements containing VTL directives more readable, we encourage you to start each VTL statement on a new line, although you are not required to do so. The set directive will be revisited in greater detail later on. 为了使包含VTL指令的语句更具可读性，建议在新行上写每个VTL语句。 稍后将更详细地重新讨论set指令。 Comments 注释1## This is a single line comment. A single line comment begins with ## and finishes at the end of the line. If you’re going to write a few lines of commentary, there’s no need to have numerous single line comments. Multi-line comments, which begin with # and end with #, are available to handle this scenario. 单行注释以##开头，并在行末尾结束。 如果你要写几行评论，没有必要写大量的单行注释。 多行注释以＃开始，以＃结束。12345678910This is text that is outside the multi-line comment.Online visitors can see it.#* Thus begins a multi-line comment. Online visitors won&apos;t see this text because the Velocity Templating Engine will ignore it.*#Here is text outside the multi-line comment; it is visible. Here are a few examples to clarify how single line and multi-line comments work: 可以用下面几个例子来说明单行和多行注释的工作：1234567This text is visible. ## This text is not.This text is visible.This text is visible. #* This text, as part of a multi-linecomment, is not visible. This text is not visible; it is alsopart of the multi-line comment. This text still notvisible. *# This text is outside the comment, so it is visible.## This text is not visible. There is a third type of comment, the VTL comment block, which may be used to store any sort of extra information you want to track in the template (e.g. javadoc-style author and versioning information): 还有第三种注释类型，VTL注释块，用于存储您要在模板中跟踪的任何类型的额外信息（例如javadoc样式的作者和版本控制信息）：12345678#** This is a VTL comment block and may be used to store such information as the document author and versioning information: @author John Doe @version 5*# References 引用There are three types of references in the VTL: variables, properties and methods. As a designer using the VTL, you and your engineers must come to an agreement on the specific names of references so you can use them correctly in your templates. 在VTL中有三种类型的引用：变量，属性和方法。 作为使用VTL的设计人员，您和您的工程师必须就引用的名称达成一致，以便您可以在模板中正确使用它们。 Variables 变量The shorthand notation of a variable consists of a leading “$” character followed by a VTL Identifier. A VTL Identifier must start with an alphabetic character (a .. z or A .. Z). The rest of the characters are limited to the following types of characters: 变量由一个前导的“$”字符和一个VTL标识符组成。 VTL标识符必须以字母字符（a .. z或A .. Z）开头。 其余字符限于以下类型的字符： 字母 (a .. z, A .. Z) 数字 (0 .. 9) 下划线Properties 属性The second flavor of VTL references are properties, and properties have a distinctive format. The shorthand notation consists of a leading $ character followed a VTL Identifier, followed by a dot character (“.”) and another VTL Identifier. These are examples of valid property references in the VTL: VTL引用的第二种类型是属性,并且属性具有不同的格式。 由$字符后的VTL标识符,后跟一个点字符(“.”)和另一个VTL标识符。 例如： 12$customer.Address$purchase.Total Take the first example, $customer.Address. It can have two meanings. It can mean, Look in the hashtable identified as customer and return the value associated with the key Address. But $customer.Address can also be referring to a method (references that refer to methods will be discussed in the next section); $customer.Address could be an abbreviated way of writing $customer.getAddress(). When your page is requested, Velocity will determine which of these two possibilities makes sense, and then return the appropriate value. 第一个例子,$customer.Address,可以有两种含义： 查找标识为customer的散列表,并返回与key ‘Address’相关联的值。 也可以是引用一个方法, $customer.Address可以是$customer.getAddress()的缩写。 当请求您的页面时,Velocity将确定这两种可能性中的哪一种是有意义的,然后返回适当的值。 Methods 方法A method is defined in the Java code and is capable of doing something useful, like running a calculation or arriving at a decision. Methods are references that consist of a leading “$” character followed a VTL Identifier, followed by a VTL Method Body. A VTL Method Body consists of a VTL Identifier followed by an left parenthesis character (“(“), followed by an optional parameter list, followed by right parenthesis character (“)”). These are examples of valid method references in the VTL: 在Java中,定义一个方法,它能够做一些有用的事情,比如运行计算或者做出决定。VTL中,方法由“$”字符加VTL标识符,后跟VTL方法体组成。 VTL方法体包括一个VTL标识符,后跟一对括号”()”,括号中是可选参数列表。例如：1234$customer.getAddress()$purchase.getTotal()$page.setTitle( &quot;My Home Page&quot; )$person.setAttributes( [&quot;Strange&quot;, &quot;Weird&quot;, &quot;Excited&quot;] ) The first two examples – $customer.getAddress() and $purchase.getTotal() – may look similar to those used in the Properties section above, $customer.Address and $purchase.Total. If you guessed that these examples must be related some in some fashion, you are correct! 前两个示例–$customer.getAddress()和$purchase.getTotal(),可能类似于上面的Properties(属性)部分中使用的$customer.Address和$ purchase.Total。 VTL Properties can be used as a shorthand notation for VTL Methods. The Property $customer.Address has the exact same effect as using the Method $customer.getAddress(). It is generally preferable to use a Property when available. The main difference between Properties and Methods is that you can specify a parameter list to a Method. VTL属性可以用作VTL方法的缩写。 属性$customer.Address与使用方法$customer.getAddress()有完全相同的效果。一般情况下,属性可用时建议使用属性。 属性和方法之间的主要区别是您可以为方法指定参数列表。 We might expect these methods to return the names of planets belonging to the sun, feed our earthworm, or get a photograph from an album. Only the long notation works for the following Methods. 如果我们期望一些方法返回属于太阳系的行星的名称,喂我们的蚯蚓,或者从相册中获取照片。12345678$sun.getPlanet( [&quot;Earth&quot;, &quot;Mars&quot;, &quot;Neptune&quot;] )## Can&apos;t pass a parameter list with $sun.Planets$sisyphus.pushRock()## Velocity assumes I mean $sisyphus.getRock()$book.setTitle( &quot;Homage to Catalonia&quot; )## Can&apos;t pass a parameter All array references are treated as if they are fixed-length lists. This means that you can call java.util.List methods and properties on array references. So, if you have a reference to an array (let’s say this one is a String[] with three values), you can do: 所有数组引用都被看作固定长度的列表。这意味着你可以在数组引用中调用java.util.List的方法和属性。 所以,如果你有一个数组的引用myarray(我们约定这是个有三个值String[]),你可以：1234567$myarray.isEmpty() or $myarray.empty$myarray.size()$myarray.get(2)$myarray.set(1, &apos;test&apos;) Velocity also supports vararg methods. A method like azpublic void setPlanets(String... planets) or even just public void setPlanets(String[] planets) can now accept any number of arguments when called in a template. Velocity还支持可变参数的方法。例如azpublic void setPlanets(String... planets)或者public void setPlanets(String[] planets)方法可以在调用时接受任意数量的参数。1234567$sun.setPlanets(&apos;Earth&apos;, &apos;Mars&apos;, &apos;Neptune&apos;)$sun.setPlanets(&apos;Mercury&apos;)$sun.setPlanets()## Will just pass in an empty, zero-length array## 仅传入一个空的,零长度的数组 As of Velocity 2.0, method calls now provides implicit conversions between all Java basic builtin types: numbers, booleans and strings. 从Velocity 2.0开始,方法调用提供所有Java基本内置类型之间的隐式转换：数字,布尔值和字符串。 Property Lookup Rules 属性查找规则As was mentioned earlier, properties often refer to methods of the parent object. Velocity is quite clever when figuring out which method corresponds to a requested property. It tries out different alternatives based on several established naming conventions. The exact lookup sequence depends on whether or not the property name starts with an upper-case letter. For lower-case names, such as $customer.address, the sequence is 前面说过,属性通常引用父对象的方法。当找出哪个方法对应请求的属性时,Velocity是相当聪明的。它基于几种命名约定尝试不同的替代方案。确切的查找顺序取决于属性名称是否以大写字母开头。 对于小写的名称,例如$customer.address,顺序是 getaddress() getAddress() get(“address”) isAddress() For upper-case property names like $customer.Address, it is slightly different: 对于大写的属性名称,如$customer.Address,它稍有不同： getAddress() getaddress() get(“Address”) isAddress()Rendering 展示The final value resulting from each and every reference (whether variable, property, or method) is converted to a String object when it is rendered into the final output. If there is an object that represents $foo (such as an Integer object), then Velocity will call its .toString() method to resolve the object into a String. 每个引用(无论是变量,属性或方法),它们的值在最终输出展示时都将转换为String对象。 如果有一个$foo的对象(如Integer对象),Velocity将调用它的.toString()方法来将对象解析成一个String。 Index Notation 索引符号Using the notation of the form $foo[0] can be used to access a given index of an object. This form is synonymous with calling the get(Object) method on a given object i.e, $foo.get(0), and provides essentially a syntactic shorthand for such operations. Since this simply calls the get method all of the following are valid uses: 使用$foo[0]形式的符号可以用来访问对象给定的索引。这种形式与在给定对象(即$foo.get(0))上调用get(Object)方法同义,且为这样的操作提供了基本的句法简写。由于这只是调用get方法,所以下面的都是有效的用法：123$foo[0] ## $foo takes in an Integer look up$foo[$i] ## Using another reference as the index $foo[&quot;bar&quot;] ## Passing a string where $foo may be a Map The bracketed syntax also works with Java arrays since Velocity wraps arrays in an access object that provides a get(Integer) method which returns the specified element. 括号式语法也适用于Java数组,因为Velocity在访问提供了get(Integer)方法来返回指定元素的对象时会包装数组。 The bracketed syntax is valid anywhere .get is valid, for example: 括号式语法在任何.get有效的地方都是有效的,例如：123$foo.bar[1].junk$foo.callMethod()[1]$foo[&quot;apple&quot;][4] A reference can also be set using index notation, for example: 引用赋值也可以使用索引符号,例如：123#set($foo[0] = 1)#set($foo.bar[1] = 3)#set($map[&quot;apple&quot;] = &quot;orange&quot;) The specified element is set with the given value. Velocity tries first the ‘set’ method on the element, then ‘put’ to make the assignment. 使用给定的值对指定的元素赋值。Velocity首先尝试元素上的“set”方法,然后“put”进行赋值。 Formal Reference Notation 正式引用标识符Shorthand notation for references was used for the examples listed above, but there is also a formal notation for references, which is demonstrated below: 上面列出的示例使用了简写符号,但是还存在正式符号,如下所示：123$&#123;mudSlinger&#125;$&#123;customer.Address&#125;$&#123;purchase.getTotal()&#125; In almost all cases you will use the shorthand notation for references, but in some cases the formal notation is required for correct processing. 几乎在所有情况下,您都可以使用简写符号的引用,但在某些情况下,需要正式符号才能进行正确处理。 Suppose you were constructing a sentence on the fly where $vice was to be used as the base word in the noun of a sentence. The goal is to allow someone to choose the base word and produce one of the two following results: “Jack is a pyromaniac.” or “Jack is a kleptomaniac.”. Using the shorthand notation would be inadequate for this task. Consider the following example: 假设你使用$vice作为句子名词中的基本单词来动态的构造一个句子。目标是允许选择基本词,并产生以下两个结果之一：“杰克是一个pyromaniac,或“杰克是kleptomaniac”。使用简写符号将不足以完成这项任务。考虑下面的例子：1Jack is a $vicemaniac. There is ambiguity here, and Velocity assumes that $vicemaniac, not $vice, is the Identifier that you mean to use. Finding no value for $vicemaniac, it will return $vicemaniac. Using formal notation can resolve this problem. 这里有歧义,Velocity假定您要使用的标识符是$vicemaniac,而不是$vice。发现没有为$vicemaniac找到值,它将返回$vicemaniac。使用正式符号可以解决这个问题。1Jack is a $&#123;vice&#125;maniac. Now Velocity knows that $vice, not $vicemaniac, is the reference. Formal notation is often useful when references are directly adjacent to text in a template. 现在Velocity知道引用$vice,不是$vicemaniac。 当引用与模板中的文本直接相邻时,正式符号通常很有用。 Quiet Reference Notation 静态引用标识符When Velocity encounters an undefined reference, its normal behavior is to output the image of the reference. For example, suppose the following reference appears as part of a VTL template. 当Velocity遇到没有定义的引用时,它通常会输出引用的镜像。例如,假设以下引用显示是VTL模板的一部分。 1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$email&quot;/&gt; When the form initially loads, the variable reference $email has no value, but you prefer a blank text field to one with a value of “$email”. Using the quiet reference notation circumvents Velocity’s normal behavior; instead of using $email in the VTL you would use $!email. So the above example would look like the following: 当表单初始加载时,变量引用$email没有值,如果你更喜欢使用空值作为“$email”的值,那么可以使用静态引用符来规避Velocity的正常行为;在VTL中使用$!email替代$email。所以上面的例子看起来像下面这样：1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$!email&quot;/&gt; Now when the form is initially loaded and $email still has no value, an empty string will be output instead of “$email”. 现在,当表单初始加载并且$email仍然没有值时,将输出一个空字符串,而不是“$email”。 Formal and quiet reference notation can be used together, as demonstrated below. 正式和静态的引用符可以一起使用,如下所示。1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$!&#123;email&#125;&quot;/&gt; Strict Reference Mode 严格引用模式Velocity 1.6 introduces the concept of strict reference mode which is activated by setting the velocity configuration property ‘runtime.references.strict’ to true. The general intent of this setting is to make Velocity behave more strictly in cases that are undefined or ambiguous, similar to a programming language, which may be more appropriate for some uses of Velocity. In such undefined or ambiguous cases Velocity will throw an exception. The following discussion outlines the cases in which strict behavior is different from traditional behavior. Velocity 1.6引入了严格引用模式的概念,可以通过将velocity配置属性“runtime.references.strict”设置为true来激活它。 这个设置一般是使Velocity在未定义或不明确的情况下类似于编程语言一样严格地运行,这可能使Velocity在一些用途下更适合。在未定义或不明确的情况下,Velocity将抛出异常。以下讨论概述了严格行为不同于传统行为的情况。 With this setting references are required to be either placed explicitly into the context or defined with a #set directive or Velocity will throw an exception. References that are in the context with a value of null will not produce an exception. Additionally, if an attempt is made to call a method or a property on an object within a reference that does not define the specified method or property then Velocity will throw an exception. This is also true if there is an attempt to call a method or property on a null value. 使用此设置,引用需要显式地放置到上下文中或使用#set指令定义,否则Velocity将抛出异常。在上下文中值为null的引用不会产生异常。此外,如果试图调用未定义指定方法或属性的对象引用上的方法或属性,那么Velocity将抛出异常。如果试图在空值上调用方法或属性,这也是正确的。 In the following examples $bar is defined but $foo is not, and all these statements will throw an exception: 在下面的例子中,定义了$bar,但$foo未定义,所以下面这些语句都会抛出异常： 1234$foo ## Exception#set($bar = $foo) ## Exception#if($foo == $bar)#end ## Exception#foreach($item in $foo)#end ## Exception Also, The following statements show examples in which Velocity will throw an exception when attempting to call methods or properties that do not exist. In these examples $bar contains an object that defines a property ‘foo’ which returns a string, and ‘retnull’ which returns null. 另外,以下语句是Velocity在尝试调用不存在的方法或属性时抛出异常的示例。在这些示例中,$bar包含一个对象,该对象定义了返回字符串的属性“foo”和返回null的“retnull”。123$bar.bogus ## $bar does not provide property bogus, Exception$bar.foo.bogus ## $bar.foo does not provide property bogus, Exception$bar.retnull.bogus ## cannot call a property on null, Exception&lt;/pre&gt; In general strict reference behavior is true for all situations in which references are used except for a special case within the #if directive. If a reference is used within a #if or #elseif directive without any methods or properties, and if it is not being compared to another value, then undefined references are allowed. This behavior provides an easy way to test if a reference is defined before using it in a template. In the following example where $foo is not defined the statements will not throw an exception. 一般来说,严格引用模式对使用引用的所有情况都是正确的,除了#if指令中的特殊情况。如果在#if或#elseif指令中使用没有任何方法或属性的引用,并且没有与另一个值进行比较,则允许使用未定义的引用。这种行为提供了一种简单的方法来测试在模板中使用引用之前是否定义了引用。在下面的例子中,$foo未定义,但语句不会抛出异常。12345#if ($foo)#end ## False#if ( ! $foo)#end ## True#if ($foo &amp;&amp; $foo.bar)#end ## False and $foo.bar will not be evaluated#if ($foo &amp;&amp; $foo == &quot;bar&quot;)#end ## False and $foo == &quot;bar&quot; wil not be evaluated#if ($foo1 || $foo2)#end ## False $foo1 and $foo2 are not defined Strict mode requires that comparisons of &gt;, &lt;, &gt;= or &lt;= within an #if directive makes sense. Also, the argument to #foreach must be iterable (this behavior can be modified with the property directive.foreach.skip.invalid). Finally, undefined macro references will also throw an exception in strict mode. 严格模式要求在#if指令内比较&gt;,&lt;,&gt; =或&lt;=是有意义的。 另外,#foreach的参数必须是可迭代的(这个行为可以用属性directive.foreach.skip.invalid修改)。最后,未定义的micro引用也将在严格模式中抛出异常。 References that Velocity attempts to render but evaluate to null will cause an Exception. To simply render nothing in this case the reference can be preceded by ‘$!’ instead of ‘$’, similar to non strict mode. Keep in mind this is different from the reference not existing in the context which will always throw an exception when attempting to render it in strict mode. For example, below $foo has a value of null in the context 当Velocity尝试呈现求值为null的引用时将导致异常。为了在这种情况下简单地不呈现,引用可以类似于非严格模式在“$!”之前,而不是’$’。请记住,这不同于上下文中不存在的引用,当尝试以严格模式呈现它时,它将总是引发异常。 例如,下面的$foo在上下文中的值为null123this is $foo ## throws an exception because $foo is nullthis is $!foo ## renders to &quot;this is &quot; without an exceptionthis is $!bogus ## bogus is not in the context so throws an exception Quiet Reference Notation 可替换情况Now that you are familiar with references, you can begin to apply them effectively in your templates. Velocity references take advantage of some Java principles that template designers will find easy to use. For example: 现在您已经熟悉了引用,可以开始在模板中有效地应用它们了。 Velocity引用利用了一些Java的原则,模板设计者会发现它们易于使用。 例如：123456789101112131415$foo$foo.getBar()## is the same as$foo.Bar$data.setUser(&quot;jon&quot;)## is the same as#set( $data.User = &quot;jon&quot; )$data.getRequest().getServerName()## is the same as$data.Request.ServerName## is the same as$&#123;data.Request.ServerName&#125; These examples illustrate alternative uses for the same references. Velocity takes advantage of Java’s introspection and bean features to resolve the reference names to both objects in the Context as well as the objects methods. It is possible to embed and evaluate references almost anywhere in your template. 这些示例说明了相同引用可以互相替代的使用方式。Velocity利用Java的introspection和bean特性来解析上下文中的两个对象的引用名称以及对象方法。 可以在模板的任何位置嵌入和评估引用。 Velocity, which is modelled on the Bean specifications defined by Sun Microsystems, is case sensitive; however, its developers have strove to catch and correct user errors wherever possible. When the method getFoo() is referred to in a template by $bar.foo, Velocity will first try $getfoo. If this fails, it will then try $getFoo. Similarly, when a template refers to $bar.Foo, Velocity will try $getFoo() first and then try getfoo(). Velocity,是由Sun Microsystems定义的Bean规范建模的,区分大小写; 然而,它的开发人员尽力捕获并纠正用户错误。 当方法getFoo()在模板中由$ bar.foo引用时,Velocity将首先尝试$getfoo。如果失败,它将尝试$getFoo。 同样,当模板引用$bar.Foo时,Velocity首先尝试$getFoo(),然后尝试getfoo()。 Note: References to instance variables in a template are not resolved. Only references to the attribute equivalents of JavaBean getter/setter methods are resolved (i.e. $foo.Name does resolve to the class Foo’s getName() instance method, but not to a public Name instance variable of Foo). 注意：不会解析模板中对实例变量的引用。 只有与JavaBean getter/setter方法等价属性的引用被解析(即$foo.Name解析为Foo的getName()实例方法,而不是Foo的public Name实例变量)。 Directives 指令References allow template designers to generate dynamic content for web sites, while directives – easy to use script elements that can be used to creatively manipulate the output of Java code – permit web designers to truly take charge of the appearance and content of the web site. 引用允许模板设计者为网站生成动态内容,而指令 – 易于使用的脚本元素,可用于创造性地操纵Java代码的输出 – 允许网页设计师真正的掌控网站的外观和内容。 Directives always begin with a #. Like references, the name of the directive may be bracketed by a { and a } symbol. This is useful with directives that are immediately followed by text. For example the following produces an error: 指令始终以＃开头。像引用一样,指令的名称可以用{和}符号括起来。这对于紧接着紧跟文本的指令很有用。例如,以下产生错误：1#if($a==1)true enough#elseno way!#end In such a case, use the brackets to separate #else from the rest of the line. 在这种情况下,使用括号将#else与行的其余部分分开。1#if($a==1)true enough#&#123;else&#125;no way!#end SetThe #set directive is used for setting the value of a reference. A value can be assigned to either a variable reference or a property reference, and this occurs in brackets, as demonstrated: #set指令用于设置引用的值。在括号中出现的值可以分配给变量引用或属性引用,如下所示：12#set( $primate = &quot;monkey&quot; )#set( $customer.Behavior = $primate ) The left hand side (LHS) of the assignment must be a variable reference or a property reference. The right hand side (RHS) can be one of the following types: 赋值的左侧(LHS)必须是变量引用或属性引用。 右侧(RHS)可以是以下类型之一： Variable reference String literal Property reference Method reference Number literal ArrayList Map These examples demonstrate each of the aforementioned types: 这些示例说明了上述每种类型：1234567#set( $monkey = $bill ) ## variable reference#set( $monkey.Friend = &quot;monica&quot; ) ## string literal#set( $monkey.Blame = $whitehouse.Leak ) ## property reference#set( $monkey.Plan = $spindoctor.weave($web) ) ## method reference#set( $monkey.Number = 123 ) ##number literal#set( $monkey.Say = [&quot;Not&quot;, $my, &quot;fault&quot;] ) ## ArrayList#set( $monkey.Map = &#123;&quot;banana&quot; : &quot;good&quot;, &quot;roast beef&quot; : &quot;bad&quot;&#125;) ## Map NOTE: For the ArrayList example the elements defined with the [..] operator are accessible using the methods defined in the ArrayList class. So, for example, you could access the first element above using $monkey.Say.get(0). 注意：对于ArrayList示例,使用[..]运算符定义的元素可以使用ArrayList类中定义的方法访问。 因此,例如,您可以访问上面的第一个元素使用$ monkey.Say.get(0)。 Similarly, for the Map example, the elements defined within the { } operator are accessible using the methods defined in the Map class. So, for example, you could access the first element above using $monkey.Map.get(“banana”) to return a String ‘good’, or even $monkey.Map.banana to return the same value. 类似地,对于Map示例,在{}运算符中定义的元素可以使用Map类中定义的方法访问。例如,您可以使用$monkey.Map.get(“banana”)访问上面的第一个元素,返回一个String’good’,或者使用$monkey.Map.banana返回相同的值。 The RHS can also be a simple arithmetic expression: RHS也可以是一个简单的算术表达式：1234#set( $value = $foo + 1 )#set( $value = $bar - 1 )#set( $value = $foo * $bar )#set( $value = $foo / $bar ) If the RHS is a property or method reference that evaluates to null, it will not be assigned to the LHS. Depending on how Velocity is configured, it is usually not possible to remove an existing reference from the context via this mechanism. (Note that this can be permitted by changing one of the Velocity configuration properties). This can be confusing for newcomers to Velocity. For example: 如果RHS是一个计算为null的属性或方法引用,则不会将其分配给LHS。根据Velocity的配置方式,通常不可能通过此机制从上下文中删除现有的引用。 (注意,这可以通过更改Velocity配置属性之一来允许)。 这对于Velocity的新人来说可能很困惑。 例如：12345#set( $result = $query.criteria(&quot;name&quot;) )The result of the first query is $result#set( $result = $query.criteria(&quot;address&quot;) )The result of the second query is $result If $query.criteria(“name”) returns the string “bill”, and $query.criteria(“address”) returns null, the above VTL will render as the following: 如果$query.criteria(“name”)返回字符串“bill”,并且$query.criteria(“address”)返回null,上述VTL将呈现如下：123The result of the first query is billThe result of the second query is bill This tends to confuse newcomers who construct #foreach loops that attempt to #set a reference via a property or method reference, then immediately test that reference with an #if directive. For example: 这往往会混淆新手构造#foreach循环时,尝试通过#set设置属性或方法引用后,立即使用#if指令测试这个引用。 例如：1234567891011#set( $criteria = [&quot;name&quot;, &quot;address&quot;] )#foreach( $criterion in $criteria ) #set( $result = $query.criteria($criterion) ) #if( $result ) Query was successful #end#end In the above example, it would not be wise to rely on the evaluation of $result to determine if a query was successful. After $result has been #set (added to the context), it cannot be set back to null (removed from the context). The details of the #if and #foreach directives are covered later in this document. 在上面的例子中,使用$result的求值来确定查询是否成功是不明智的。 $result已经#set(添加到上下文)后,它不能设置为null(从上下文中删除)。 #if和#foreach指令的详细信息将在本文档的后面部分介绍。 One solution to this would be to pre-set $result to false. Then if the $query.criteria() call fails, you can check. 一个解决方案是将$result设置为false。 然后如果$query.criteria()调用失败,你可以检查。123456789101112#set( $criteria = [&quot;name&quot;, &quot;address&quot;] )#foreach( $criterion in $criteria ) #set( $result = false ) #set( $result = $query.criteria($criterion) ) #if( $result ) Query was successful #end#end Unlike some of the other Velocity directives, the #set directive does not have an #end statement. 与其他一些Velocity指令不同,#set指令没有#end语句。 Literals 字面量When using the #set directive, string literals that are enclosed in double quote characters will be parsed and rendered, as shown: 当使用#set指令时,括在双引号中的字符串将被解析和呈现,如下所示：1234#set( $directoryRoot = &quot;www&quot; )#set( $templateName = &quot;index.vm&quot; )#set( $template = &quot;$directoryRoot/$templateName&quot; )$template The output will be1www/index.vm However, when the string literal is enclosed in single quote characters, it will not be parsed: 但是,当字符串文字在单引号中时,不会被解析：1234#set( $foo = &quot;bar&quot; )$foo#set( $blargh = &apos;$foo&apos; )$blargh This renders as:12bar$foo By default, this feature of using single quotes to render unparsed text is available in Velocity. This default can be changed by editing velocity.properties such that stringliterals.interpolate=false. 默认情况下,使用单引号来呈现解析的文本的功能在Velocity中是可用的。 可以通过编辑velocity.properties使stringliterals.interpolate = false来更改此默认值。 Alternately, the #[[don’t parse me!]]# syntax allows the template designer to easily use large chunks of uninterpreted and unparsed content in VTL code. This can be especially useful in place of escaping multiple directives or escaping sections which have content that would otherwise be invalid (and thus unparseable) VTL. 或者,模板设计者可以在VTL代码中通过＃[[不解析我！]]语法轻松地使用大块未解释和未解析的内容。 这在代替转义多个指令或转义部分具有无效(不可解析)的VTL内容时特别有用。12345#[[#foreach ($woogie in $boogie) nothing will happen to $woogie#end]]# Renders as:123#foreach ($woogie in $boogie) nothing will happen to $woogie#end Conditionals 条件语句If / ElseIf / ElseThe #if directive in Velocity allows for text to be included when the web page is generated, on the conditional that the if statement is true. For example: Velocity中的#if指令允许在生成网页时,在if语句为真的条件下包含文本。 例如：123#if( $foo ) &lt;strong&gt;Velocity!&lt;/strong&gt;#end The variable $foo is evaluated to determine whether it is true, which will happen under one of three circumstances: 在以下三种情况之一下发生时将评估变量$foo以确定其是否为真： $foo is a boolean (true/false) which has a true value $foo是值为true的布尔值 $foo is a string or a collection which is not null and not empty $foo是是一个非null字符串或者非空集合 $foo is an object (other than a string or a collection) which is not null $foo是一个非null对象 Remember that the Velocity context only contains Objects, so when we say ‘boolean’, it will be represented as a Boolean (the class). This is true even for methods that return boolean - the introspection infrastructure will return a Boolean of the same logical value. 记住,Velocity上下文只包含对象,所以当我们说’boolean’时,它将被表示为一个Boolean(类),即使返回boolean的方法 - introspection基础设施也将返回相同的逻辑值的Boolean。 The content between the #if and the #end statements become the output if the evaluation is true. In this case, if $foo is true, the output will be: “Velocity!”. Conversely, if $foo has a null value, or if it is a boolean false, the statement evaluates as false, and there is no output. 如果值为true,#if和#end语句之间的内容将会输出。在这种情况下,如果$foo为true,输出将是：“Velocity！”。相反,如果$foo有一个null,或者如果它是一个布尔值false,语句计算结果为false,没有输出。 An #elseif or #else element can be used with an #if element. Note that the Velocity Templating Engine will stop at the first expression that is found to be true. In the following example, suppose that $foo has a value of 15 and $bar has a value of 6. #elseif或#else元素可以与#if元素一起使用。 注意,Velocity模板引擎将停在第一个为真的表达式那里。 在以下示例中,假设$foo的值为15,$bar的值为6。123456789#if( $foo &lt; 10 ) **Go North**#elseif( $foo == 10 ) **Go East**#elseif( $bar == 6 ) **Go South**#else **Go West**#end In this example, $foo is greater than 10, so the first two comparisons fail. Next $bar is compared to 6, which is true, so the output is Go South. 在此示例中,$foo大于10,因此前两个比较失败。 下一个$bar比较为6,这是真的,所以输出是Go South。 Relational and Logical Operators 关系和逻辑运算符Velocity uses the equivalent operator to determine the relationships between variables. Here is a simple example to illustrate how the equivalent operator is used. Velocity使用等效运算符来确定变量之间的关系。 这里是一个简单的例子来说明如何使用等效运算符。12345678#set ($foo = &quot;deoxyribonucleic acid&quot;)#set ($bar = &quot;ribonucleic acid&quot;)#if ($foo == $bar) In this case it&apos;s clear they aren&apos;t equivalent. So...#else They are not equivalent and this will be the output.#end Note that the semantics of == are slightly different than Java where == can only be used to test object equality. In Velocity the equivalent operator can be used to directly compare numbers, strings, or objects. When the objects are of different classes, the string representations are obtained by calling toString() for each object and then compared. 注意==的语义与Java略有不同,Java中==只能用于测试对象的相等性。 而在Velocity中,等效运算符可以用于直接比较数字,字符串或对象。 当对象是不同的类时,通过调用每个对象的toString()然后比较获得的字符串。 Velocity has logical AND, OR and NOT operators as well. Below are examples demonstrating the use of the logical AND, OR and NOT operators. Velocity具有逻辑AND,OR和NOT运算符。 下面是演示使用逻辑AND,OR和NOT运算符的示例。12345## logical AND#if( $foo &amp;&amp; $bar ) ** This AND that**#end The #if() directive will only evaluate to true if both $foo and $bar are true. If $foo is false, the expression will evaluate to false; $bar will not be evaluated. If $foo is true, the Velocity Templating Engine will then check the value of $bar; if $bar is true, then the entire expression is true and This AND that becomes the output. If $bar is false, then there will be no output as the entire expression is false. 如果$foo和$bar都为true,#if()指令计算为true。 如果$foo为false,表达式将计算为false,不会评估$bar。如果$foo为true,Velocity模板引擎将检查$bar的值; 如果$bar为true,则整个表达式为true,这个AND将成为输出。如果$bar是false,那么将没有输出,因为整个表达式是false。 Logical OR operators work the same way, except only one of the references need evaluate to true in order for the entire expression to be considered true. Consider the following example. 逻辑OR运算符的工作方式相同,但只要有一个引用值为true,表达式的值就是true。 请考虑以下示例。12345## logical OR#if( $foo || $bar ) **This OR That**#end If $foo is true, the Velocity Templating Engine has no need to look at $bar; whether $bar is true or false, the expression will be true, and This OR That will be output. If $foo is false, however, $bar must be checked. In this case, if $bar is also false, the expression evaluates to false and there is no output. On the other hand, if $bar is true, then the entire expression is true, and the output is This OR That 如果$foo为true,Velocity模板引擎不需要查看$bar; 无论$bar是true还是false,表达式都将为true,并且将输出此OR。如果$foo为false,则必须检查$bar。在这种情况下,如果$bar也为false,那么表达式将计算为false,并且没有输出。 另一方面,如果$bar为true,则整个表达式为true,输出为This OR That With logical NOT operators, there is only one argument : 使用逻辑NOT运算符,只有一个参数：12345##logical NOT#if( !$foo ) **NOT that**#end Here, the if $foo is true, then !$foo evaluates to false, and there is no output. If $foo is false, then !$foo evaluates to true and NOT that will be output. Be careful not to confuse this with the quiet reference $!foo which is something altogether different. 这里,如果$foo为true,那么!$foo计算结果为false,没有输出。 如果$foo为false,那么！$ foo计算结果为true,否则输出NOT。 小心不要混淆它与静态引用$!foo,它们是完全不同的东西。 There are text versions of all logical operators, including eq, ne, and, or, not, gt, ge, lt, and le. 有所有逻辑运算符的文本版本,包括eq,ne,and,or,not,gt,ge,lt和le。 One more useful note. When you wish to include text immediately following a #else directive you will need to use curly brackets immediately surrounding the directive to differentiate it from the following text. (Any directive can be delimited by curly brackets, although this is most useful for #else). 一个更有用的注释,当你希望包含紧跟在#else指令之后的文本时,你需要使用直接围绕指令的大括号来区分它和下面的文本。 (任何指令可以用大括号分隔,虽然这对#else最有用)。1#if( $foo == $bar)it&apos;s true!#&#123;else&#125;it&apos;s not!#end Loops 循环Foreach LoopThe #foreach element allows for looping. For example: #foreach元素允许循环。 例如：12345&lt;ul&gt;#foreach( $product in $allProducts ) &lt;li&gt;$product&lt;/li&gt;#end&lt;/ul&gt; This #foreach loop causes the $allProducts list (the object) to be looped over for all of the products (targets) in the list. Each time through the loop, the value from $allProducts is placed into the $product variable. 这个#foreach循环遍历$allProducts列表(对象)中的所有产品(目标)。每次循环,将$allProducts的值将放入$product变量中。 The contents of the $allProducts variable is a Vector, a Hashtable or an Array. The value assigned to the $product variable is a Java Object and can be referenced from a variable as such. For example, if $product was really a Product class in Java, its name could be retrieved by referencing the $product.Name method (ie: $Product.getName()). $allProducts变量的内容是Vector,Hashtable或Array。 分配给$product变量的值是一个Java对象,可以从变量中引用。例如,如果$product实际上是Java中的Product类,则可以通过引用$product.Name方法(即：$Product.getName())来检索其名称。 Lets say that $allProducts is a Hashtable. If you wanted to retrieve the key values for the Hashtable as well as the objects within the Hashtable, you can use code like this: $allProducts是一个Hashtable。如果要检索Hashtable的键值以及Hashtable中的对象,可以使用如下代码：12345&lt;ul&gt;#foreach( $key in $allProducts.keySet() ) &lt;li&gt;Key: $key -&gt; Value: $allProducts.get($key)&lt;/li&gt;#end&lt;/ul&gt; Velocity provides an easy way to get the loop counter so that you can do something like the following: Velocity提供了一种简单的方法来获取循环计数器,以便您可以执行以下操作：12345&lt;table&gt;#foreach( $customer in $customerList ) &lt;tr&gt;&lt;td&gt;$foreach.count&lt;/td&gt;&lt;td&gt;$customer.Name&lt;/td&gt;&lt;/tr&gt;#end&lt;/table&gt; Velocity also now provides an easy way to tell if you are on the last iteration of a loop: Velocity现在还提供了一种简单的方法来判断你是否在循环的最后一次迭代：123#foreach( $customer in $customerList ) $customer.Name#if( $foreach.hasNext ),#end#end If you want a zero-based index of the #foreach loop, you can just use $foreach.index instead of $foreach.count. Likewise, $foreach.first and $foreach.last are provided to compliment $foreach.hasNext. If you want to access these properties for an outer #foreach loop, you can reference them directly through the $foreach.parent or $foreach.topmost properties (e.g. $foreach.parent.index or $foreach.topmost.hasNext). 如果你想要一个从零开始的#foreach循环的索引,你可以使用$foreach.index而不是$foreach.count。同样,提供$foreach.first和$foreach.last来补充$foreach.hasNext。如果要访问外部#foreach循环的这些属性,可以通过$foreach.parent或$foreach.topmost属性(例如$foreach.parent.index或$foreach.topmost.hasNext)直接引用它们。 It’s possible to set a maximum allowed number of times that a loop may be executed. By default there is no max (indicated by a value of 0 or less), but this can be set to an arbitrary number in the velocity.properties file. This is useful as a fail-safe. 可以设置循环可执行的最大允许次数。默认情况下没有max(由0或更小的值指示),但是可以将其设置为velocity.properties文件中的任意数字。这可用作故障安全。12# The maximum allowed number of loops.directive.foreach.maxloops = -1 If you want to stop looping in a foreach from within your template, you can now use the #break directive to stop looping at any time: 如果想要在模板中停止循环,可以随时使用#break指令停止循环：1234567## list first 5 customers only#foreach( $customer in $customerList ) #if( $foreach.count &gt; 5 ) #break #end $customer.Name#end Include 包含The #include script element allows the template designer to import a local file, which is then inserted into the location where the #include directive is defined. The contents of the file are not rendered through the template engine. For security reasons, the file to be included may only be under TEMPLATE_ROOT. #include脚本元素允许模板设计器导入本地文件,然后将其插入到定义#include指令的位置。文件的内容不通过模板引擎呈现。出于安全考虑,要包含的文件只能处于TEMPLATE_ROOT下。1#include( &quot;one.txt&quot; ) The file to which the #include directive refers is enclosed in quotes. If more than one file will be included, they should be separated by commas. #include指令引用的文件用引号括起来。 如果包含多个文件,它们应该用逗号分隔。1#include( &quot;one.gif&quot;,&quot;two.txt&quot;,&quot;three.htm&quot; ) The file being included need not be referenced by name; in fact, it is often preferable to use a variable instead of a filename. This could be useful for targeting output according to criteria determined when the page request is submitted. Here is an example showing both a filename and a variable. 所包含的文件不需要通过名称引用; 实际上,通常优先使用变量而不是文件名。 这可能有助于根据在提交页面请求时确定的标准定位输出。 这里是一个显示文件名和变量的例子。1#include( &quot;greetings.txt&quot;, $seasonalstock ) Parse 解析The #parse script element allows the template designer to import a local file that contains VTL. Velocity will parse the VTL and render the template specified. #parse脚本元素允许模板设计器导入包含VTL的本地文件。 Velocity将解析VTL并渲染指定的模板。1#parse( &quot;me.vm&quot; ) Like the #include directive, #parse can take a variable rather than a template. Any templates to which #parse refers must be included under TEMPLATE_ROOT. Unlike the #include directive, #parse will only take a single argument. 像#include指令一样,#parse可以接受一个变量而不是一个模板。 #parse引用的任何模板必须包含在TEMPLATE_ROOT下。 与#include指令不同,#parse只接受一个参数。 VTL templates can have #parse statements referring to templates that in turn have #parse statements. By default set to 10, the directive.parse.max.depth line of the velocity.properties allows users to customize maximum number of #parse referrals that can occur from a single template. (Note: If the directive.parse.max.depth property is absent from the velocity.properties file, Velocity will set this default to 10.) Recursion is permitted, for example, if the template dofoo.vm contains the following lines: VTL模板使用#parse语句引用的模板中可以有#parse语句。 默认设置为10,velocity.properties文件中的directive.parse.max.depth允许用户自定义可从单个模板发生的#parse引用的最大数量。 (注意：如果velocity.properties文件中缺少directive.parse.max.depth属性,则Velocity会将此默认值设置为10.)允许递归,例如,如果模板dofoo.vm包含以下行：1234Count down.#set( $count = 8 )#parse( &quot;parsefoo.vm&quot; )All done with dofoo.vm! It would reference the template parsefoo.vm, which might contain the following VTL: 它将引用模板parsefoo.vm,它可能包含以下VTL：1234567$count#set( $count = $count - 1 )#if( $count &gt; 0 ) #parse( &quot;parsefoo.vm&quot; )#else All done with parsefoo.vm!#end After “Count down.” is displayed, Velocity passes through parsefoo.vm, counting down from 8. When the count reaches 0, it will display the “All done with parsefoo.vm!” message. At this point, Velocity will return to dofoo.vm and output the “All done with dofoo.vm!” message. “Count down.”之后,Velocity从8开始计数，通过parsefoo.vm显示。当计数达到0时,它将显示“All done with parsefoo.vm！”信息，此时,Velocity将返回dofoo.vm并输出“All done with dofoo.vm！”信息。 Break 中止The #break directive stops any further rendering of the current execution scope. An “execution scope” is essentially any directive with content (i.e. #foreach, #parse, #evaluate, #define, #macro, or #@somebodymacro) or any “root” scope (i.e. template.merge(…), Velocity.evaluate(…) or velocityEngine.evaluate(…)). Unlike #stop, #break will only stop the innermost, immediate scope, not all of them. #break指令停止对当前执行范围的任何进一步呈现。“执行范围”基本上是任何带有内容的指令(即#foreach,#parse,#evaluate,#define,#macro或＃@somebodymacro)或任何“根”范围(即template.merge Velocity.evaluate(…)或velocityEngine.evaluate(…))。与#stop不同,#break只会停止最里面的,立即的范围,而不是所有的。 If you wish to break out of a specific execution scope that is not necessarily the most immediate one, then you can pass the scope control reference (i.e. $foreach, $template, $evaluate, $define, $macro, or $somebodymacro) as an argument to #break. (e.g. #break($macro)). This will stop rendering of all scopes up to the specified one. When within nested scopes of the same type, remember that you can always access the parent(s) via $.parent or $.topmost and pass those to #break instead (e.g. #break($foreach.parent) or #break($macro.topmost)). 如果你希望跳出一个不一定是最直接的特定执行范围,那么你可以通过范围控制引用(即$foreach,$template,$evaluate,$define,$macro或$somebodymacro)#break的参数。(例如#break($macro))。这将停止渲染所有范围直到指定的范围。当在同一类型的嵌套作用域内时,记住你可以随时通过$.parent或$.topmost访问父类,并将它们传递给#break(例如#break($foreach.parent)或#break($macro.topmost)))。 Stop 停止he #stop directive stops any further rendering and execution of the template. This is true even when the directive is nested within another template accessed through #parse or located in a velocity macro. The resulting merged output will contain all the content up to the point the #stop directive was encountered. This is handy as an early exit from a template. For debugging purposes, you may provide a message argument (e.g. #stop(‘$foo was not in context’) ) that will be written to the logs (DEBUG level, of course) upon completion of the stop command. #stop指令停止任何进一步的模板渲染和执行。即使当指令嵌套在通过#parse访问或位于velocity macro中的另一个模板中时,也是如此。生成的合并输出将包含遇到#stop指令之前的所有内容。这是方便的作为早期退出模板。为了调试,可以在完成停止命令后提供一个消息参数(例如#stop(‘$foo不在上下文中’))将被写入日志(当然是DEBUG级别)。 Evaluate 计算The #evaluate directive can be used to dynamically evaluate VTL. This allows the template to evaluate a string that is created at render time. Such a string might be used to internationalize the template or to include parts of a template from a database. #evaluate指令可用于动态评估VTL。这允许模板评估在渲染时创建的字符串。这样的字符串可以用于国际化模板或包括来自数据库的模板的部分。 The example below will display abc.12345#set($source1 = &quot;abc&quot;)#set($select = &quot;1&quot;)#set($dynamicsource = &quot;$source$select&quot;)## $dynamicsource is now the string &apos;$source1&apos;#evaluate($dynamicsource) Define 定义The #define directive lets one assign a block of VTL to a reference. #define指令允许将一个VTL块分配给一个引用。 The example below will display Hello World!.123#define( $block )Hello $who#end#set( $who = &apos;World!&apos; )$block Velocimacros 宏The #macro script element allows template designers to define a repeated segment of a VTL template. Velocimacros are very useful in a wide range of scenarios both simple and complex. This Velocimacro, created for the sole purpose of saving keystrokes and minimizing typographic errors, provides an introduction to the concept of Velocimacros. #macro脚本元素允许模板设计者定义VTL模板的重复段。 Velocimacros在广泛的简单和复杂场景是非常有用的。 创造Velocimacro的唯一目的是保存按键和最小化印刷错误,提供Velocimacros的概念介绍。123#macro( d )&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;#end The Velocimacro being defined in this example is d, and it can be called in a manner analogous to any other VTL directive: 在本例中定义的Velocimacro是d,它可以以类似于任何其他VTL指令的方式调用：1#d() When this template is called, Velocity would replace #d() with a row containing a single, empty data cell. If we want to put something in that cell, we can alter the macro to allow for a body: 当调用此模板时,Velocity将用包含单个空数据单元的行替换#d()。 如果我们想在该单元格中放置某些东西,我们可以改变该macro以允许一个body：123#macro( d )&lt;tr&gt;&lt;td&gt;$!bodyContent&lt;/td&gt;&lt;/tr&gt;#end Now, if we call the macro just a bit differently, using #@ before the name and providing a body and #end to the call, then Velocity will render the body when it gets to the $!bodyContent: 现在,如果我们调用macro有点不同,名称之前使用＃@,并在调用里提供一个body和#end,然后当Velocity得到$!bodyContent将渲染body：1#@d()Hello!#end You can still call the macro as you did before, and since we used the silent reference notation for the body reference ($!bodyContent instead of $bodyContent), it will still render a row with a single, empty data cell. 你仍然可以像以前一样调用macro,因为我们使用静态引用符号为body引用($!bodyContent而不是$bodyContent),它仍然将渲染一个具有单个空数据单元格的行。 A Velocimacro can also take any number of arguments – even zero arguments, as demonstrated in the first example, is an option – but when the Velocimacro is invoked, it must be called with the same number of arguments with which it was defined. Many Velocimacros are more involved than the one defined above. Here is a Velocimacro that takes two arguments, a color and an array. Velocimacro也可以采用任意数量的参数 - 即使是零参数,如第一个示例中所示,是一个选项 - 但是当Velocimacro被调用时,必须使用与它定义的参数相同的参数来调用它。 许多Velocimacros比上面定义的更多参与。 这里是一个Velocimacro,它接受两个参数,一个颜色和一个数组。12345#macro( tablerows $color $somelist )#foreach( $something in $somelist ) &lt;tr&gt;&lt;td bgcolor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt;#end#end The Velocimacro being defined in this example, tablerows, takes two arguments. The first argument takes the place of $color, and the second argument takes the place of $somelist. 在本例中定义的Velocimacro tablerows,有两个参数。第一个参数代替$color,第二个参数代替$somelist。 Anything that can be put into a VTL template can go into the body of a Velocimacro. The tablerows Velocimacro is a foreach statement. There are two #end statements in the definition of the #tablerows Velocimacro; the first belongs to the #foreach, the second ends the Velocimacro definition. 任何可以放入VTL模板的东西都可以进入Velocimacro的body。 Tablocows Velocimacro是一个foreach语句。 #tablerows Velocimacro的定义中有两个#end语句：第一个属于#foreach,第二个结束Velocimacro定义。12345#set( $greatlakes = [&quot;Superior&quot;,&quot;Michigan&quot;,&quot;Huron&quot;,&quot;Erie&quot;,&quot;Ontario&quot;] )#set( $color = &quot;blue&quot; )&lt;table&gt; #tablerows( $color $greatlakes )&lt;/table&gt; Notice that $greatlakes takes the place of $somelist. When the #tablerows Velocimacro is called in this situation, the following output is generated: 注意$greatlakes代替$somelist。 当在这种情况下调用#tablerows Velocimacro时,会生成以下输出：1234567&lt;table&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Superior&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Michigan&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Huron&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Erie&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Ontario&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Velocimacros can be defined inline in a Velocity template, meaning that it is unavailable to other Velocity templates on the same web site. Defining a Velocimacro such that it can be shared by all templates has obvious advantages: it reduces the need to redefine the Velocimacro on numerous templates, saving work and reducing the chance of error, and ensures that a single change to a macro available to more than one template. Velocimacros可以在Velocity模板中内联定义,这意味着它在同一网站上的其他Velocity模板不可用。 定义一个Velocimacro,以便它可以被所有模板共享有明显的优势：它减少了需要重新定义Velocimacro在许多模板,节省工作和减少错误的机会,并确保对单个更改可用的大于 一个模板。 Were the #tablerows($color $list) Velocimacro defined in a Velocimacros template library, this macro could be used on any of the regular templates. It could be used many times and for many different purposes. In the template mushroom.vm devoted to all things fungi, the #tablerows Velocimacro could be invoked to list the parts of a typical mushroom: 在Velocimacros模板库中定义的#tablerows($color $list)Velocimacro,这个macro可以用于任何常规模板。它可以为许多不同的目的被使用许多次。在模板mushroom.vm致力于所有的真菌,#tablerows Velocimacro可以调用列出典型的蘑菇的部分：…12345#set( $parts = [&quot;volva&quot;,&quot;stipe&quot;,&quot;annulus&quot;,&quot;gills&quot;,&quot;pileus&quot;] )#set( $cellbgcol = &quot;#CC00FF&quot; )&lt;table&gt;#tablerows( $cellbgcol $parts )&lt;/table&gt; When fulfilling a request for mushroom.vm, Velocity would find the #tablerows Velocimacro in the template library (defined in the velocity.properties file) and generate the following output: 当满足对mushroom.vm的请求时,Velocity将在模板库(在velocity.properties文件中定义)中找到#tablerows Velocimacro并生成以下输出：1234567&lt;table&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;volva&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;stipe&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;annulus&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;gills&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;pileus&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Velocimacro ArgumentsVelocimacros can take as arguments any of the following VTL elements : Velocimacro可以接受任何以下VTL元素作为参数： Reference : anything that starts with ‘$’ String literal : something like “$foo” or ‘hello’ Number literal : 1, 2 etc IntegerRange : [ 1..2] or [$foo .. $bar] ObjectArray : [ “a”, “b”, “c”] boolean value true boolean value false When passing references as arguments to Velocimacros, please note that references are passed ‘by name’. This means that their value is ‘generated’ at each use inside the Velocimacro. This feature allows you to pass references with method calls and have the method called at each use. For example, when calling the following Velocimacro as shown 当引用作为参数传递到Velocimacros时,请注意引用是通过名称传递的。 这意味着它们的值是在Velocimacro内部每次使用时产生的。 此功能允许您使用方法调用传递引用,并在每次使用时调用该方法。 例如,当调用以下Velocimacro时,所示12345#macro( callme $a ) $a $a $a#end#callme( $foo.bar() ) results in the method bar() of the reference $foo being called 3 times. 导致$foo引用的bar()方法被调用3次。 At first glance, this feature appears surprising, but when you take into consideration the original motivation behind Velocimacros – to eliminate cut’n’paste duplication of commonly used VTL – it makes sense. It allows you to do things like pass stateful objects, such as an object that generates colors in a repeating sequence for coloring table rows, into the Velocimacro. 乍一看,这个功能看起来令人惊讶,但是当你考虑到Velocimacros的原始动机 – 以消除常用的VTL的cut’n’paste重复 – 这是有道理的。 它允许你做一些事情,比如传递一个在重复的序列中生成着色表行颜色的有状态的对象,进入Velocimacro。 If you need to circumvent this feature, you can always just get the value from the method as a new reference and pass that : 如果你需要规避这个功能,你可以通过把该方法的值作为一个新的引用：12#set( $myval = $foo.bar() )#callme( $myval ) Velocimacro PropertiesSeveral lines in the velocity.properties file allow for flexible implementation of Velocimacros. Note that these are also documented in the Developer Guide. velocity.properties文件中的几行允许灵活实现Velocimacros。 请注意,这些内容也记录在“开发人员指南”中。 velocimacro.library - A comma-separated list of all Velocimacro template libraries. By default, Velocity looks for a single library: VM_global_library.vm. The configured template path is used to find the Velocimacro libraries. velocimacro.library - 所有Velocimacro模板库的逗号分隔列表。 默认情况下,Velocity查找单个库：VM_global_library.vm。 配置的模板路径用于查找Velocimacro库。 velocimacro.permissions.allow.inline - This property, which has possible values of true or false, determines whether Velocimacros can be defined in regular templates. The default, true, allows template designers to define Velocimacros in the templates themselves. velocimacro.permissions.allow.inline - 此属性的可能值为true或false,用于确定Velocimacros是否可在常规模板中定义。 默认值为true,允许模板设计者在模板自身中定义Velocimacros。 velocimacro.permissions.allow.inline.to.replace.global - With possible values of true or false, this property allows the user to specify if a Velocimacro defined inline in a template can replace a globally defined template, one that was loaded on startup via the velocimacro.library property. The default, false, prevents Velocimacros defined inline in a template from replacing those defined in the template libraries loaded at startup. velocimacro.permissions.allow.inline.to.replace.global - 使用可能的值true或false,此属性允许用户指定是否在模板中定义的Velocimacro可以替换全局定义的模板,启动时通过velocimacro.library属性加载模板。 默认值为false,可防止模板中定义的Velocimacros替换在启动时加载的模板库中定义的那些。 velocimacro.permissions.allow.inline.local.scope - This property, with possible values of true or false, defaulting to false, controls if Velocimacros defined inline are ‘visible’ only to the defining template. In other words, with this property set to true, a template can define inline VMs that are usable only by the defining template. You can use this for fancy VM tricks - if a global VM calls another global VM, with inline scope, a template can define a private implementation of the second VM that will be called by the first VM when invoked by that template. All other templates are unaffected. velocimacro.permissions.allow.inline.local.scope - 此属性的可能值为true或false，默认为false，控制Velocimacros定义内联是否仅对定义模板可见。 换句话说，将此属性设置为true时，模板可以定义只能由定义模板使用的内联VM。 您可以使用这个虚拟的技巧 - 如果一个全局虚拟机调用另一个全局虚拟机，使用内联作用域，一个模板可以定义第二个虚拟机的私有实现，当被该模板调用时，第一个虚拟机将调用它。 所有其他模板不受影响。 velocimacro.library.autoreload - This property controls Velocimacro library autoloading. The default value is false. When set to true the source Velocimacro library for an invoked Velocimacro will be checked for changes, and reloaded if necessary. This allows you to change and test Velocimacro libraries without having to restart your application or servlet container, just like you can with regular templates. This mode only works when caching is off in the resource loaders (e.g. file.resource.loader.cache = false ). This feature is intended for development, not for production. velocimacro.library.autoreload - 此属性控制Velocimacro库自动加载。 默认值为false。 设置为true时,将调用Velocimacro的源Velocimacro库检查更改,如有必要,将重新加载。 这允许您更改和测试Velocimacro库,而不必重新启动应用程序或servlet容器,就像使用常规模板一样。 此模式仅在资源加载程序中的缓存关闭时有效(例如file.resource.loader.cache = false)。 此功能用于开发,而不是用于生产。 Please note than when two templates each define a macro with the same name, you either need velocimacro.permissions.allow.inline.local.scope or velocimacro.permissions.allow.inline.to.replace.global to be set to true for each template to use its own macro version. 请注意,当两个模板各自定义一个具有相同名称的micro时,您需要velocimacro.permissions.allow.inline.local.scope或velocimacro.permissions.allow.inline.to.replace.global为每个micro设置为true,使模板使用自己的micro版本。 Getting Literal 获取字面量VTL uses special characters, such as $ and #, to do its work, so some added care should be taken where using these characters in your templates. This section deals with escaping these characters. VTL使用特殊字符(例如$和＃)来完成其工作,因此在模板中使用这些字符时应该格外小心。 本节介绍转义这些字符。 Currency 并发There is no problem writing “I bought a 4 lb. sack of potatoes at the farmer’s market for only $2.50!” As mentioned, a VTL identifier always begins with an upper- or lowercase letter, so $2.50 would not be mistaken for a reference. 写”我在农民的市场上买了一块4磅的土豆,只需$2.50!”没有问题,如上所述,VTL标识符总是以大写或小写字母开头,因此$2.50不会被误认为是引用。 Escaping Valid VTL References 转义VTL引用Cases may arise where you do not want to have a reference rendered by Velocity. Escaping special characters is the best way to output VTL’s special characters in these situations, and this can be done using the backslash ( ** ) character when those special characters are part of a valid VTL reference. 当你不想有由Velocity提供的引用时,可能会出现一些情况。在这些情况下,转义特殊字符是输出VTL的特殊字符的最佳方法,当这些特殊字符是有效VTL引用的一部分时,可以使用反斜杠( ** )字符来完成。12#set( $email = &quot;foo&quot; )$email If Velocity encounters a reference in your VTL template to $email, it will search the Context for a corresponding value. Here the output will be foo, because $email is defined. If $email is not defined, the output will be $email. 如果Velocity遇到VTL模板中的引用到$email,它将搜索Context以获取相应的值。因为$email是定义的,这里的输出将是foo。如果没有定义$email,输出将是$email。 Suppose that $email is defined (for example, if it has the value foo), and that you want to output $email. There are a few ways of doing this, but the simplest is to use the escape character. Here is a demonstration: 假设定义了$email(例如,如果它具有值foo),并且您想输出$email。有几种方法可以做到这一点,但最简单的是使用转义字符。这里是一个示范： Suppose that $email is defined (for example, if it has the value foo), and that you want to output $email. There are a few ways of doing this, but the simplest is to use the escape character. Here is a demonstration: 假设定义了$email(例如,如果它具有值foo),并且您想输出$email。有几种方法可以做到这一点,但最简单的是使用转义字符。这里是一个示范：1234## The following line defines $email in this template:#set( $email = &quot;foo&quot; )$email\$email renders as12foo$email If, for some reason, you need a backslash before either line above, you can do the following: 如果因为某些原因,在上面的任一行之前需要反斜杠,您可以执行以下操作：1234## The following line defines $email in this template:#set( $email = &quot;foo&quot; )\\$email\\\$email which renders as12\foo\$email Note that the character bind to the $ from the left. The bind-from-left rule causes \\$email to render as \$email. Compare these examples to those in which `$email` is not defined. 注意, 字符绑定到左边的$。 左侧带从规则导致\\$email呈现为\$email。 将这些示例与未定义$email 的示例进行比较。1234$email\$email\\$email\\\$email renders as1234$email\$email\\$email\\\$email Notice Velocity handles references that are defined differently from those that have not been defined. Here is a set directive that gives $foo the value gibbous. 注意Velocity处理的引用定义与未定义的引用的定义不同。 这里是一个set指令,给出$foo的值gibbous。12#set( $foo = &quot;gibbous&quot; )$moon = $foo The output will be: $moon = gibbous – where $moon is output as a literal because it is undefined and gibbous is output in place of $foo. 输出将是：$moon = gibbous – 其中$moon输出为文字,因为它是未定义的,并且输出gibbous代替$foo。 Escaping Invalid VTL References 转义不可用VTL引用Sometimes Velocity has trouble parsing your template when it encounters an “invalid reference” that you never intended to be a reference at all. Escaping special characters is, again, the best way to handle these situations, but in these situations, the backslash will likely fail you. Instead of simply trying to escape the problematic $ or #, you should probably just replace this: 有时Velocity遇到解析你的模板时遇到一个“无效的引用”,你从来没有打算作为一个引用。转义特殊字符同样是处理这些情况的最佳方式,但在这些情况下,反斜杠可能会失败。不能简单地试图逃避有问题的$或＃,你应该替换为：1$&#123;my:invalid:non:reference&#125; with something like this12#set( $D = &apos;$&apos; )$&#123;D&#125;&#123;my:invalid:non:reference&#125; You can, of course, put your $ or # string directly into the context from your java code (e.g. context.put(“D”,”$”);) to avoid the extra #set() directive in your template(s). Or, if you are using VelocityTools, you can just use the EscapeTool like this: 当然，你可以把你的$或＃字符串直接从你的java代码放入上下文(例如context.put(“D”,“$”);),以避免额外的#set()指令在你的模板。或者,如果你使用VelocityTools,你可以使用EscapeTool像这样：1$&#123;esc.d&#125;&#123;my:invalid:non:reference&#125; Escaping of both valid and invalid VTL directives is handled in much the same manner; this is described in more detail in the Directives section. 有效和无效的VTL指令的转义以同样的方式处理; 这在“指令”部分中有更详细的描述。 Escaping VTL Directives 转义VTL指令VTL directives can be escaped with the backslash character (“\”) in a manner similar to valid VTL references. VTL指令可以使用反斜杠字符(“\”)以类似于有效VTL引用的方式转义。12345678## #include( &quot;a.txt&quot; ) renders as &lt;contents of a.txt&gt;#include( &quot;a.txt&quot; )## \#include( &quot;a.txt&quot; ) renders as #include( &quot;a.txt&quot; )\#include( &quot;a.txt&quot; )## \\#include ( &quot;a.txt&quot; ) renders as \&lt;contents of a.txt&gt;\\#include ( &quot;a.txt&quot; ) Extra care should be taken when escaping VTL directives that contain multiple script elements in a single directive (such as in an if-else-end statements). Here is a typical VTL if-statement: 当转义单个指令中包含多个脚本元素的VTL指令时(如if-else-end语句中),应格外小心。 这里是一个典型的VTL if语句：123#if( $jazz ) Vyacheslav Ganelin#end If $jazz is true, the output is1Vyacheslav Ganelin If $jazz is false, there is no output. Escaping script elements alters the output. Consider the following case: 如果$ jazz为false,则没有输出。 转义脚本元素会更改输出。 考虑以下情况：123\#if( $jazz ) Vyacheslav Ganelin\#end This causes the directives to be escaped, but the rendering of $jazz proceeds as normal. So, if $jazz is true, the output is 这将导致指令被转义,但$jazz的正常显示。 所以,如果$jazz为true,输出为123#if( true ) Vyacheslav Ganelin #end Suppose backslashes precede script elements that are legitimately escaped: 假设在合法转义的脚本元素前面有反斜杠：123v\\#if( $jazz ) Vyacheslav Ganelin\\#end In this case, if $jazz is true, the output is 在这种情况下,$jazz是true,输出为12\ Vyacheslav Ganelin\ To understand this, note that the #if( arg ) when ended by a newline (return) will omit the newline from the output. Therefore, the body of the #if() block follows the first ‘\’, rendered from the ‘\’ preceding the #if(). The last \ is on a different line than the text because there is a newline after ‘Ganelin’, so the final \, preceding the #end is part of the body of the block. 要理解这一点,请注意如果#if(arg)在新的一行结束时,输出时将省略这一行。 因此,#if()的语句块跟在第一个’\’之后,从#if()之前的’\’开始。 最后一个\在与文本不同的行上,因为在’Ganelin’之后有一个换行符,因此#end之前的最后一个\是块的主体的一部分。 If $jazz is false, the output is1\ Note that things start to break if script elements are not properly escaped. 请注意,如果脚本元素未正确转义,事情就会开始中断。123\\\#if( $jazz ) Vyacheslave Ganelin\\#end Here the #if is escaped, but there is an #end remaining; having too many endings will cause a parsing error. 这里#if被转义,但是还有一个#end标签; 多余的标签将导致解析错误. VTL: Formatting Issues 格式化问题Although VTL in this user guide is often displayed with newlines and whitespaces, the VTL shown below 虽然本用户指南中的VTL经常显示换行符和空格,但它们的VTL如下所示1234#set( $imperial = [&quot;Munetaka&quot;,&quot;Koreyasu&quot;,&quot;Hisakira&quot;,&quot;Morikune&quot;] )#foreach( $shogun in $imperial ) $shogun#end is equally valid as the following snippet that Geir Magnusson Jr. posted to the Velocity user mailing list to illustrate a completely unrelated point: 同样有效,如下面的代码片段Geir Magnusson Jr.发布到Velocity用户邮件列表来说明一个完全不相关的点：1Send me #set($foo=[&quot;$10 and &quot;,&quot;a pie&quot;])#foreach($a in $foo)$a#end please. Velocity’s default behaviour is to gobble up excess whitespace. The preceding directive can be written as: Velocity的默认行为是吞噬多余的空格。 前面的指令可以写成：123456Send me#set( $foo = [&quot;$10 and &quot;,&quot;a pie&quot;] )#foreach( $a in $foo )$a#endplease. or as12345Send me#set($foo = [&quot;$10 and &quot;,&quot;a pie&quot;]) #foreach ($a in $foo )$a #end please. In each case the output will be the same. Please note that it&apos;s possible to configure Velocity with other space gobbling behaviors. In each case the output will be the same. Please note that it’s possible to configure Velocity with other space gobbling behaviors. 在每种情况下,输出将是相同的。 请注意,可以配置Velocity与其他空间gobbling行为。 Other Features and Miscellany 其它特征和功能Math 算术Velocity has a handful of built-in mathematical functions that can be used in templates with the set directive. The following equations are examples of addition, subtraction, multiplication and division, respectively: Velocity有一些内置的数学函数,可以在模板中使用set指令。 以下等式分别是加法,减法,乘法和除法的示例：1234#set( $foo = $bar + 3 )#set( $foo = $bar - 4 )#set( $foo = $bar * 6 )#set( $foo = $bar / 2 ) When a division operation is performed between two integers, the result will be an integer, as the fractional portion is discarded. Any remainder can be obtained by using the modulus (%) operator. 当在两个整数之间执行除法运算时,结果将是一个整数,因为会舍去小数部分。 任何余数可以通过使用模量(％)运算符获得。1#set( $foo = $bar % 5 ) Range Operator 范围操作符The range operator can be used in conjunction with #set and #foreach statements. Useful for its ability to produce an object array containing integers, the range operator has the following construction: 范围运算符可以与#set和#foreach语句结合使用。 对于生成包含整数的对象数组时非常有用,范围运算符具有以下结构：1[n..m] Both n and m must either be or produce integers. Whether m is greater than or less than n will not matter; in this case the range will simply count down. Examples showing the use of the range operator as provided below: n和m必须是或者产生整数。 m大于或小于n无关紧要; 在这种情况下,范围将只是倒置的。 下面提供了示范使用范围运算符的示例：123456789101112131415161718First example:#foreach( $foo in [1..5] )$foo#endSecond example:#foreach( $bar in [2..-2] )$bar#endThird example:#set( $arr = [0..1] )#foreach( $i in $arr )$i#endFourth example:[1..3] Produces the following output:1234567891011First example:1 2 3 4 5Second example:2 1 0 -1 -2Third example:0 1Fourth example:[1..3] Note that the range operator only produces the array when used in conjunction with #set and #foreach directives, as demonstrated in the fourth example. 请注意,范围运算符仅在与#set和#foreach指令结合使用时才会生成数组,如第四个示例中所示。 Web page designers concerned with making tables a standard size, but where some will not have enough data to fill the table, will find the range operator particularly useful. 网页设计师希望表格成为标准尺寸,但是有些人没有足够的数据填充表格,这时会发现范围操作符特别有用。 Advanced Issues: Escaping and ! 高级问题:转义和!When a reference is silenced with the ! character and the ! character preceded by an escape character, the reference is handled in a special way. Note the differences between regular escaping, and the special case where precedes ! follows it: 当一个引用前面加上！ 字符和！ 字符前面带有转义字符,则引用以特殊方式处理。 注意常规转义和特殊情况之间的区别,其中先于！ 遵循：12345#set( $foo = &quot;bar&quot; )$\!foo$\!&#123;foo&#125;$\\!foo$\\\!foo This renders as:1234$!foo$!&#123;foo&#125;$\!foo$\\!foo Contrast this with regular escaping, where precedes $ :1234\$foo\$!foo\$!&#123;foo&#125;\\$!&#123;foo&#125; This renders as:1234$foo$!foo$!&#123;foo&#125;\bar Velocimacro Miscellany Velocimacro杂谈Can I use a directive or another VM as an argument to a VM?Can I register Velocimacros via #parse() ?What is Velocimacro Autoreloading?There is a property, meant to be used in development, not production : 有一个属性,意味着用于开发,而不是生产：1`velocimacro.library.autoreload` which defaults to false. When set to true along with1`&lt;type&gt;.resource.loader.cache = false` (where is the name of the resource loader that you are using, such as ‘file’) then the Velocity engine will automatically reload changes to your Velocimacro library files when you make them, so you do not have to dump the servlet engine (or application) or do other tricks to have your Velocimacros reloaded. (其中是您正在使用的资源加载程序的名称,例如’file’),则Velocity引擎将自动重新加载更改Velocimacro库文件,当你使它们,所以你不必转储servlet引擎(或 应用程序)或做其他的技巧,让你的Velocimacros重新加载。 Here is what a simple set of configuration properties would look like. 这里是一个简单的配置属性的集合。123file.resource.loader.path = templatesfile.resource.loader.cache = falsevelocimacro.library.autoreload = true Don’t keep this on in production. 不要把它保留在生产中。 String Concatenation 字符串拼接A common question that developers ask is How do I do String concatenation? Is there any analogue to the ‘+’ operator in Java?. 开发人员问的一个常见问题是如何做字符串连接？ 在Java中是否有’+’运算符的模拟？ To do concatenation of references in VTL, you just have to ‘put them together’. The context of where you want to put them together does matter, so we will illustrate with some examples. In the regular ‘schmoo’ of a template (when you are mixing it in with regular content) : 在模板的常规“shmoo”中(当您将其与常规内容混合时)：1234#set( $size = &quot;Big&quot; )#set( $name = &quot;Ben&quot; )The clock is $size$name. and the output will render as ‘The clock is BigBen’. For more interesting cases, such as when you want to concatenate strings to pass to a method, or to set a new reference, just do 并且输出将呈现为“时钟是大本钟”。 对于更有趣的情况,例如当你想要连接字符串传递给一个方法,或者设置一个新的引用,只是做123456#set( $size = &quot;Big&quot; )#set( $name = &quot;Ben&quot; )#set($clock = &quot;$size$name&quot; )The clock is $clock. Which will result in the same output. As a final example, when you want to mix in ‘static’ strings with your references, you may need to use ‘formal references’ : 这将导致相同的输出。 作为最后一个例子,当你想混合静态字符串和你的引用,你可能需要使用’正式引用’：123456#set( $size = &quot;Big&quot; )#set( $name = &quot;Ben&quot; )#set($clock = &quot;$&#123;size&#125;Tall$name&quot; )The clock is $clock. Now the output is ‘The clock is BigTallBen’. The formal notation is needed so the parser knows you mean to use the reference ‘$size’ versus ‘$sizeTall’ which it would if the ‘{}’ weren’t there. 现在的输出是’The clock is BigTallBen’。 正式符号是需要的,所以解析器知道你的意思是使用引用’$ size’对’$sizeTall’,如果’{}“不在那里。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[springSecurity快速指南]]></title>
      <url>%2F2016%2F11%2F02%2FspringSecurity%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Spring Security Security是什么?Security配置方式 application using Java-based Spring Boot application Xml-based configuration Spring MVC application security使用版本：4.1.3.RELEASE引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; XML方式新建配置文件security.xmlweb.xml设置引入配置文件123456&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:security.xml &lt;/param-value&gt;&lt;/context-param&gt; 配置过滤器12345678&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; security.xml配置引入name space123456&lt;b:beans xmlns=&quot;http://www.springframework.org/schema/security&quot; xmlns:b=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt;&lt;/b:beans&gt; NameSpace 可划分为以下几块: Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。 业务对象或者方法的安全：控制方法访问权限的。 AuthenticationManager：处理来自于框架其他部分的认证请求。 AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。 AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。 UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。 元素http 元素用于定义 Web 相关权限控制123&lt;http&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&apos;USER&apos;)&quot;/&gt;&lt;/http&gt; intercept-url配置指定拦截的 url通过 pattern 指定当前 intercept-url 定义应当作用于哪些 url1&lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&apos;USER&apos;)&quot;/&gt; 指定访问权限通过 access 属性来指定 intercept-url 对应 URL 访问所应当具有的权限。access 的值是一个字符串，其可以直接是一个权限的定义，也可以是一个表达式。例如: hasRole(‘ROLE_USER’) or hasRole(‘ROLE_ADMIN’) hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)指定访问协议指定 intercept-url 的 requires-channel 属性来指定访问协议。requires-channel 支持三个值：http、https 和 any。any 表示 http 和 https 都可以访问。例如:1&lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; requires-channel=&quot;http&quot;/&gt; 注意:当试图使用 http 请求那些限制了只能通过 https 访问的资源时会自动跳转到对应的 https 通道重新请求。如果所使用的 http 或者 https 协议不是监听在标准的端口上（http 默认是 80，https 默认是 443），则需要我们通过 port-mapping 元素定义好它们的对应关系。1234&lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; requires-channel=&quot;http&quot;/&gt;&lt;port-mappings&gt; &lt;port-mapping http=&quot;8888&quot; https=&quot;9999&quot;/&gt;&lt;/port-mappings&gt; 指定请求方法如果我们要求某些 URL 只能通过 POST 请求，某些 URL 只能通过 GET 请求，可以通过指定 intercept-url 的 method 属性限制当前 intercept-url 适用的请求方式，默认为所有的方式都可以。method 的可选值有 GET、POST、DELETE、PUT、HEAD、OPTIONS 和 TRACE。1&lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; method=&quot;GET&quot;/&gt; 元素认证是由 AuthenticationManager 来管理的，但是真正进行认证的是 AuthenticationManager 中定义的 AuthenticationProvider。AuthenticationManager 中可以定义有多个 AuthenticationProvider。当我们使用 authentication-provider 元素来定义一个 AuthenticationProvider 时，如果没有指定对应关联的 AuthenticationProvider 对象，Spring Security 默认会使用 DaoAuthenticationProvider。DaoAuthenticationProvider 在进行认证的时候需要一个 UserDetailsService 来获取用户的信息 UserDetails，其中包括用户名、密码和所拥有的权限等。所以如果我们需要改变认证的方式，我们可以实现自己的 AuthenticationProvider；如果需要改变认证的用户信息来源，我们可以实现 UserDetailsService。 实现了自己的 AuthenticationProvider 之后，我们可以在配置文件中这样配置来使用我们自己的 AuthenticationProvider。其中 myAuthenticationProvider 就是我们自己的 AuthenticationProvider 实现类对应的 bean。123&lt;authentication-manager&gt; &lt;authentication-provider ref=&quot;myAuthenticationProvider&quot;/&gt;&lt;/authentication-manager&gt; 实现了自己的 UserDetailsService 之后，我们可以在配置文件中这样配置来使用我们自己的 UserDetailsService。其中的 myUserDetailsService 就是我们自己的 UserDetailsService 实现类对应的 bean。123&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;myUserDetailsService&quot;/&gt;&lt;/authentication-manager&gt; 用户信息从数据库获取通常我们的用户信息都不会向第一节示例中那样简单的写在配置文件中，而是从其它存储位置获取，比如数据库。根据之前的介绍我们知道用户信息是通过 UserDetailsService 获取的，要从数据库获取用户信息，我们就需要实现自己的 UserDetailsService。幸运的是像这种常用的方式 Spring Security 已经为我们做了实现了。 使用 jdbc-user-service 获取在 Spring Security 的命名空间中在 authentication-provider 下定义了一个 jdbc-user-service 元素，通过该元素我们可以定义一个从数据库获取 UserDetails 的 UserDetailsService。jdbc-user-service 需要接收一个数据源的引用。12345&lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot;/&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; 上述配置中 dataSource 是对应数据源配置的 bean 引用。 因为默认情况下 jdbc-user-service 将使用 SQL 语句 “select username, password, enabled from users where username = ?” 来获取用户信息；使用 SQL 语句 “select username, authority from authorities where username = ?” 来获取用户对应的权限；使用 SQL 语句 “select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id” 来获取用户所属组的权限。需要注意的是 jdbc-user-service 定义是不支持用户组权限的，所以使用 jdbc-user-service 时用户组相关表也是可以不定义的。如果需要使用用户组权限请使用 JdbcDaoImpl。 当然这只是默认配置及默认的表结构。如果我们的表名或者表结构跟 Spring Security 默认的不一样，我们可以通过以下几个属性来定义我们自己查询用户信息、用户权限和用户组权限的 SQL: users-by-username-query 指定查询用户信息的 SQL authorities-by-username-query 指定查询用户权限的 SQL group-authorities-by-username-query 指定查询用户组权限的 SQL例如:1234567&lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot; users-by-username-query=&quot;select username, password, enabled from account where username = ?&quot; /&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; role-prefix 属性:jdbc-user-service 还有一个属性 role-prefix 可以用来指定角色的前缀。这是什么意思呢？这表示我们从库里面查询出来的权限需要加上什么样的前缀。举个例子，假设我们库里面存放的权限都是 “USER”，而我们指定了某个 URL 的访问权限 access=”ROLEUSER”，显然这是不匹配的，Spring Security 不会给我们放行，通过指定 jdbc-user-service 的 role-prefix=”ROLE\” 之后就会满足了。当 role-prefix 的值为 “none” 时表示没有前缀，当然默认也是没有的。 直接使用 JdbcDaoImplJdbcDaoImpl 是 UserDetailsService 的一个实现。其用法和 jdbc-user-service 类似，只是我们需要把它定义为一个 bean，然后通过 authentication-provider 的 user-service-ref 进行引用。1234567&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot;/&gt;&lt;/authentication-manager&gt;&lt;bean id=&quot;userDetailsService&quot; class=&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; JdbcDaoImpl 同样需要一个 dataSource 的引用。如果就是上面这样配置的话我们数据库表结构也需要是标准的表结构。当然，如果我们的表结构和标准的不一样，可以通过 usersByUsernameQuery、authoritiesByUsernameQuery 和 groupAuthoritiesByUsernameQuery 属性来指定对应的查询 SQL。 JdbcDaoImpl 使用 enableAuthorities 和 enableGroups 两个属性来控制权限的启用。默认启用的是 enableAuthorities，即用户权限，而 enableGroups 默认是不启用的。如果需要启用用户组权限，需要指定 enableGroups 属性值为 true。当然这两种权限是可以同时启用的。需要注意的是使用 jdbc-user-service 定义的 UserDetailsService 是不支持用户组权限的，如果需要支持用户组权限的话需要我们使用 JdbcDaoImpl。12345678&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot;/&gt;&lt;/authentication-manager&gt;&lt;bean id=&quot;userDetailsService&quot; class=&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;enableGroups&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt; PasswordEncoder通常我们保存的密码都不会像之前介绍的那样，保存的明文，而是加密之后的结果。为此，我们的 AuthenticationProvider 在做认证时也需要将传递的明文密码使用对应的算法加密后再与保存好的密码做比较。Spring Security 对这方面也有支持。通过在 authentication-provider 下定义一个 password-encoder 我们可以定义当前 AuthenticationProvider 需要在进行认证时需要使用的 password-encoder。password-encoder 是一个 PasswordEncoder 的实例，我们可以直接使用它，如：12345&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot;&gt; &lt;password-encoder hash=&quot;md5&quot;/&gt; &lt;/authentication-provider&gt;&lt;/authentication-manager&gt; 其属性hash表示我们将用来进行加密的哈希算法，系统已经为我们实现的有plaintext、sha、sha-256、md4、md5、{sha}和{ssha}。 认证简介认证过程 用户使用用户名和密码进行登录。 Spring Security 将获取到的用户名和密码封装成一个实现了 Authentication 接口的 UsernamePasswordAuthenticationToken。 将上述产生的 token 对象传递给 AuthenticationManager 进行登录认证。 AuthenticationManager 认证成功后将会返回一个封装了用户权限等信息的 Authentication 对象。 通过调用 SecurityContextHolder.getContext().setAuthentication(…) 将 AuthenticationManager 返回的 Authentication 对象赋予给当前的 SecurityContext。 在认证成功后，用户就可以继续操作去访问其它受保护的资源了，但是在访问的时候将会使用保存在 SecurityContext 中的 Authentication 对象进行相关的权限鉴定。 Web 应用的认证过程如果用户直接访问登录页面，那么认证过程跟上节描述的基本一致，只是在认证完成后将跳转到指定的成功页面，默认是应用的根路径。如果用户直接访问一个受保护的资源，那么认证过程将如下： 引导用户进行登录，通常是重定向到一个基于 form 表单进行登录的页面，具体视配置而定。 用户输入用户名和密码后请求认证，后台还是会像上节描述的那样获取用户名和密码封装成一个 UsernamePasswordAuthenticationToken 对象，然后把它传递给 AuthenticationManager 进行认证。 如果认证失败将继续执行步骤 1，如果认证成功则会保存返回的 Authentication 到 SecurityContext，然后默认会将用户重定向到之前访问的页面。 用户登录认证成功后再次访问之前受保护的资源时就会对用户进行权限鉴定，如不存在对应的访问权限，则会返回 403 错误码。在上述步骤中将有很多不同的类参与，但其中主要的参与者是 ExceptionTranslationFilter。ExceptionTranslationFilterExceptionTranslationFilter 是用来处理来自 AbstractSecurityInterceptor 抛出的 AuthenticationException 和 AccessDeniedException 的。AbstractSecurityInterceptor 是 Spring Security 用于拦截请求进行权限鉴定的，其拥有两个具体的子类，拦截方法调用的 MethodSecurityInterceptor 和拦截 URL 请求的 FilterSecurityInterceptor。当 ExceptionTranslationFilter 捕获到的是 AuthenticationException 时将调用 AuthenticationEntryPoint 引导用户进行登录；如果捕获的是 AccessDeniedException，但是用户还没有通过认证，则调用 AuthenticationEntryPoint 引导用户进行登录认证，否则将返回一个表示不存在对应权限的 403 错误码。在 request 之间共享 SecurityContext既然 SecurityContext 是存放在 ThreadLocal 中的，而且在每次权限鉴定的时候都是从 ThreadLocal 中获取 SecurityContext 中对应的 Authentication 所拥有的权限，并且不同的 request 是不同的线程，为什么每次都可以从 ThreadLocal 中获取到当前用户对应的 SecurityContext 呢？在 Web 应用中这是通过 SecurityContextPersistentFilter 实现的，默认情况下其会在每次请求开始的时候从 session 中获取 SecurityContext，然后把它设置给 SecurityContextHolder，在请求结束后又会将 SecurityContextHolder 所持有的 SecurityContext 保存在 session 中，并且清除 SecurityContextHolder 所持有的 SecurityContext。这样当我们第一次访问系统的时候，SecurityContextHolder 所持有的 SecurityContext 肯定是空的，待我们登录成功后，SecurityContextHolder 所持有的 SecurityContext 就不是空的了，且包含有认证成功的 Authentication 对象，待请求结束后我们就会将 SecurityContext 存在 session 中，等到下次请求的时候就可以从 session 中获取到该 SecurityContext 并把它赋予给 SecurityContextHolder 了，由于 SecurityContextHolder 已经持有认证过的 Authentication 对象了，所以下次访问的时候也就不再需要进行登录认证了。 核心类简介 Authentication Authentication 是一个接口，用来表示用户认证信息的，在用户登录认证之前相关信息会封装为一个 Authentication 具体实现类的对象，在登录认证成功之后又会生成一个信息更全面，包含用户权限等信息的 Authentication 对象，然后把它保存在 SecurityContextHolder 所持有的 SecurityContext 中，供后续的程序进行调用，如访问权限的鉴定等。 SecurityContextHolder SecurityContextHolder 是用来保存 SecurityContext 的。SecurityContext 中含有当前正在访问系统的用户的详细信息。默认情况下，SecurityContextHolder 将使用 ThreadLocal 来保存 SecurityContext，这也就意味着在处于同一线程中的方法中我们可以从 ThreadLocal 中获取到当前的 SecurityContext。因为线程池的原因，如果我们每次在请求完成后都将 ThreadLocal 进行清除的话，那么我们把 SecurityContext 存放在 ThreadLocal 中还是比较安全的。这些工作 Spring Security 已经自动为我们做了，即在每一次 request 结束后都将清除当前线程的 ThreadLocal。 SecurityContextHolder 中定义了一系列的静态方法，而这些静态方法内部逻辑基本上都是通过 SecurityContextHolder 持有的 SecurityContextHolderStrategy 来实现的，如 getContext()、setContext()、clearContext()等。而默认使用的 strategy 就是基于 ThreadLocal 的 ThreadLocalSecurityContextHolderStrategy。另外，Spring Security 还提供了两种类型的 strategy 实现，GlobalSecurityContextHolderStrategy 和 InheritableThreadLocalSecurityContextHolderStrategy，前者表示全局使用同一个 SecurityContext，如 C/S 结构的客户端；后者使用 InheritableThreadLocal 来存放 SecurityContext，即子线程可以使用父线程中存放的变量。 一般而言，我们使用默认的 strategy 就可以了，但是如果要改变默认的 strategy，Spring Security 为我们提供了两种方法，这两种方式都是通过改变 strategyName 来实现的。SecurityContextHolder 中为三种不同类型的 strategy 分别命名为 MODE_THREADLOCAL、MODE_INHERITABLETHREADLOCAL 和 MODE_GLOBAL。第一种方式是通过 SecurityContextHolder 的静态方法 setStrategyName() 来指定需要使用的 strategy；第二种方式是通过系统属性进行指定，其中属性名默认为 “spring.security.strategy”，属性值为对应 strategy 的名称。 Spring Security 使用一个 Authentication 对象来描述当前用户的相关信息。SecurityContextHolder 中持有的是当前用户的 SecurityContext，而 SecurityContext 持有的是代表当前用户相关信息的 Authentication 的引用。这个 Authentication 对象不需要我们自己去创建，在与系统交互的过程中，Spring Security 会自动为我们创建相应的 Authentication 对象，然后赋值给当前的 SecurityContext。但是往往我们需要在程序中获取当前用户的相关信息，比如最常见的是获取当前登录用户的用户名。在程序的任何地方，通过如下方式我们可以获取到当前用户的用户名。 12345678910public String getCurrentUsername() &#123; Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); if (principal instanceof UserDetails) &#123; return ((UserDetails) principal).getUsername(); &#125; if (principal instanceof Principal) &#123; return ((Principal) principal).getName(); &#125; return String.valueOf(principal);&#125; 通过 Authentication.getPrincipal() 可以获取到代表当前用户的信息，这个对象通常是 UserDetails 的实例。获取当前用户的用户名是一种比较常见的需求，关于上述代码其实 Spring Security 在 Authentication 中的实现类中已经为我们做了相关实现，所以获取当前用户的用户名最简单的方式应当如下。 123public String getCurrentUsername() &#123; return SecurityContextHolder.getContext().getAuthentication().getName();&#125; 此外，调用 SecurityContextHolder.getContext() 获取 SecurityContext 时，如果对应的 SecurityContext 不存在，则 Spring Security 将为我们建立一个空的 SecurityContext 并进行返回。 AuthenticationManager 和 AuthenticationProvider AuthenticationManager 是一个用来处理认证（Authentication）请求的接口。在其中只定义了一个方法 authenticate()，该方法只接收一个代表认证请求的 Authentication 对象作为参数，如果认证成功，则会返回一个封装了当前用户权限等信息的 Authentication 对象进行返回。 1Authentication authenticate(Authentication authentication) throws AuthenticationException; 在 Spring Security 中，AuthenticationManager 的默认实现是 ProviderManager，而且它不直接自己处理认证请求，而是委托给其所配置的 AuthenticationProvider 列表，然后会依次使用每一个 AuthenticationProvider 进行认证，如果有一个 AuthenticationProvider 认证后的结果不为 null，则表示该 AuthenticationProvider 已经认证成功，之后的 AuthenticationProvider 将不再继续认证。然后直接以该 AuthenticationProvider 的认证结果作为 ProviderManager 的认证结果。如果所有的 AuthenticationProvider 的认证结果都为 null，则表示认证失败，将抛出一个 ProviderNotFoundException。校验认证请求最常用的方法是根据请求的用户名加载对应的 UserDetails，然后比对 UserDetails 的密码与认证请求的密码是否一致，一致则表示认证通过。Spring Security 内部的 DaoAuthenticationProvider 就是使用的这种方式。其内部使用 UserDetailsService 来负责加载 UserDetails，UserDetailsService 将在下节讲解。在认证成功以后会使用加载的 UserDetails 来封装要返回的 Authentication 对象，加载的 UserDetails 对象是包含用户权限等信息的。认证成功返回的 Authentication 对象将会保存在当前的 SecurityContext 中。 当我们在使用 NameSpace 时， authentication-manager 元素的使用会使 Spring Security 在内部创建一个 ProviderManager，然后可以通过 authentication-provider 元素往其中添加 AuthenticationProvider。当定义 authentication-provider 元素时，如果没有通过 ref 属性指定关联哪个 AuthenticationProvider，Spring Security 默认就会使用 DaoAuthenticationProvider。使用了 NameSpace 后我们就不要再声明 ProviderManager 了。 1234&lt;authentication-manager alias=&quot;authenticationManager&quot;&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot;/&gt;&lt;/authentication-manager&gt; 如果我们没有使用 NameSpace，那么我们就应该在 ApplicationContext 中声明一个 ProviderManager。 认证成功后清除凭证 默认情况下，在认证成功后 ProviderManager 将清除返回的 Authentication 中的凭证信息，如密码。所以如果你在无状态的应用中将返回的 Authentication 信息缓存起来了，那么以后你再利用缓存的信息去认证将会失败，因为它已经不存在密码这样的凭证信息了。所以在使用缓存的时候你应该考虑到这个问题。一种解决办法是设置 ProviderManager 的 eraseCredentialsAfterAuthentication 属性为 false，或者想办法在缓存时将凭证信息一起缓存。 UserDetailsService 通过 Authentication.getPrincipal() 的返回类型是 Object，但很多情况下其返回的其实是一个 UserDetails 的实例。UserDetails 是 Spring Security 中一个核心的接口。其中定义了一些可以获取用户名、密码、权限等与认证相关的信息的方法。Spring Security 内部使用的 UserDetails 实现类大都是内置的 User 类，我们如果要使用 UserDetails 时也可以直接使用该类。在 Spring Security 内部很多地方需要使用用户信息的时候基本上都是使用的 UserDetails，比如在登录认证的时候。登录认证的时候 Spring Security 会通过 UserDetailsService 的 loadUserByUsername() 方法获取对应的 UserDetails 进行认证，认证通过后会将该 UserDetails 赋给认证通过的 Authentication 的 principal，然后再把该 Authentication 存入到 SecurityContext 中。之后如果需要使用用户信息的时候就是通过 SecurityContextHolder 获取存放在 SecurityContext 中的 Authentication 的 principal。 通常我们需要在应用中获取当前用户的其它信息，如 Email、电话等。这时存放在 Authentication 的 principal 中只包含有认证相关信息的 UserDetails 对象可能就不能满足我们的要求了。这时我们可以实现自己的 UserDetails，在该实现类中我们可以定义一些获取用户其它信息的方法，这样将来我们就可以直接从当前 SecurityContext 的 Authentication 的 principal 中获取这些信息了。上文已经提到了 UserDetails 是通过 UserDetailsService 的 loadUserByUsername() 方法进行加载的。UserDetailsService 也是一个接口，我们也需要实现自己的 UserDetailsService 来加载我们自定义的 UserDetails 信息。然后把它指定给 AuthenticationProvider 即可。如下是一个配置 UserDetailsService 的示例。 12345678910&lt;!-- 用于认证的 AuthenticationManager --&gt;&lt;authentication-manager alias=&quot;authenticationManager&quot;&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot; /&gt;&lt;/authentication-manager&gt;&lt;bean id=&quot;userDetailsService&quot; class=&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 上述代码中我们使用的 JdbcDaoImpl 是 Spring Security 为我们提供的 UserDetailsService 的实现，另外 Spring Security 还为我们提供了 UserDetailsService 另外一个实现，InMemoryDaoImpl。 其作用是从数据库中加载 UserDetails 信息。其中已经定义好了加载相关信息的默认脚本，这些脚本也可以通过 JdbcDaoImpl 的相关属性进行指定。 JdbcDaoImpl JdbcDaoImpl 允许我们从数据库来加载 UserDetails，其底层使用的是 Spring 的 JdbcTemplate 进行操作，所以我们需要给其指定一个数据源。此外，我们需要通过 usersByUsernameQuery 属性指定通过 username 查询用户信息的 SQL 语句；通过 authoritiesByUsernameQuery 属性指定通过 username 查询用户所拥有的权限的 SQL 语句；如果我们通过设置 JdbcDaoImpl 的 enableGroups 为 true 启用了用户组权限的支持，则我们还需要通过 groupAuthoritiesByUsernameQuery 属性指定根据 username 查询用户组权限的 SQL 语句。当这些信息都没有指定时，将使用默认的 SQL 语句，默认的 SQL 语句如下所示。 123select username, password, enabled from users where username=? -- 根据 username 查询用户信息select username, authority from authorities where username=? -- 根据 username 查询用户权限信息select g.id, g.group_name, ga.authority from groups g, groups_members gm, groups_authorities ga where gm.username=? and g.id=ga.group_id and g.id=gm.group_id -- 根据 username 查询用户组权限 使用默认的 SQL 语句进行查询时意味着我们对应的数据库中应该有对应的表和表结构，Spring Security 为我们提供的默认表的创建脚本如下。 12345678910111213141516171819202122232425create table users( username varchar_ignorecase(50) not null primary key, password varchar_ignorecase(50) not null, enabled boolean not null);create table authorities ( username varchar_ignorecase(50) not null, authority varchar_ignorecase(50) not null, constraint fk_authorities_users foreign key(username) references users(username)); create unique index ix_auth_username on authorities (username,authority);create table groups (id bigint generated by default as identity(start with 0) primary key,group_name varchar_ignorecase(50) notnull);create table group_authorities (group_id bigint notnull,authority varchar(50) notnull,constraint fk_group_authorities_group foreign key(group_id) references groups(id));create table group_members (id bigint generated by default as identity(start with 0) primary key,username varchar(50) notnull,group_id bigint notnull,constraint fk_group_members_group foreign key(group_id) references groups(id)); 此外，使用 jdbc-user-service 元素时在底层 Spring Security 默认使用的就是 JdbcDaoImpl。 123456&lt;authentication-manager alias=&quot;authenticationManager&quot;&gt; &lt;authentication-provider&gt; &lt;!-- 基于 Jdbc 的 UserDetailsService 实现，JdbcDaoImpl --&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot;/&gt; &lt;/authentication-provider&gt;&lt;/authentication-manager&gt; InMemoryDaoImpl InMemoryDaoImpl 主要是测试用的，其只是简单的将用户信息保存在内存中。使用 NameSpace 时，使用 user-service 元素 Spring Security 底层使用的 UserDetailsService 就是 InMemoryDaoImpl。此时，我们可以简单的使用 user 元素来定义一个 UserDetails。 123&lt;user-service&gt; &lt;user name=&quot;user&quot; password=&quot;user&quot; authorities=&quot;ROLE_USER&quot;/&gt;&lt;/user-service&gt; 如上配置表示我们定义了一个用户 user，其对应的密码为 user，拥有 ROLE_USER 的权限。此外，user-service 还支持通过 properties 文件来指定用户信息，如： 1&lt;user-service properties=&quot;/WEB-INF/config/users.properties&quot;/&gt; 其中属性文件应遵循如下格式： 1username=password,grantedAuthority[,grantedAuthority][,enabled|disabled] 所以，对应上面的配置文件，我们的 users.properties 文件的内容应该如下所示： 12#username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]user=user,ROLE_USER GrantedAuthority Authentication 的 getAuthorities() 可以返回当前 Authentication 对象拥有的权限，即当前用户拥有的权限。其返回值是一个 GrantedAuthority 类型的数组，每一个 GrantedAuthority 对象代表赋予给当前用户的一种权限。GrantedAuthority 是一个接口，其通常是通过 UserDetailsService 进行加载，然后赋予给 UserDetails 的。 GrantedAuthority 中只定义了一个 getAuthority() 方法，该方法返回一个字符串，表示对应权限的字符串表示，如果对应权限不能用字符串表示，则应当返回 null。 Spring Security 针对 GrantedAuthority 有一个简单实现 SimpleGrantedAuthority。该类只是简单的接收一个表示权限的字符串。Spring Security 内部的所有 AuthenticationProvider 都是使用 SimpleGrantedAuthority 来封装 Authentication 对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyBatis官方文档 -- 入门]]></title>
      <url>%2F2016%2F10%2F17%2FMyBatis%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3--%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[MyBatis官方文档 – 入门 Introduction 简介What is MyBatis? 什么是 MyBatis ？MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records. MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Getting started 入门Installation 安装To use MyBatis you just need to include the mybatis-x.x.x.jar file in the classpath. If you are using Maven just add the following dependency to your pom.xml: 要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于 classpath 中即可。 如果使用 Maven 来构建项目，则需将下面的 dependency 代码置于 pom.xml 文件中：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; Building SqlSessionFactory from XML 从 XML 中构建 SqlSessionFactoryEvery MyBatis application centers around an instance of SqlSessionFactory. A SqlSessionFactory instance can be acquired by using the SqlSessionFactoryBuilder. SqlSessionFactoryBuilder can build a SqlSessionFactory instance from an XML configuration file, or from a custom prepared instance of the Configuration class. 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 Building a SqlSessionFactory instance from an XML file is very simple. It is recommended that you use a classpath resource for this configuration, but you could use any InputStream instance, including one created from a literal file path or a file:// URL. MyBatis includes a utility class, called Resources, that contains a number of methods that make it simpler to load resources from the classpath and other locations. 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。123String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); The configuration XML file contains settings for the core of the MyBatis system, including a DataSource for acquiring database Connection instances, as well as a TransactionManager for determining how transactions should be scoped and controlled. The full details of the XML configuration file can be found later in this document, but here is a simple example: XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务范围和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例：1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; While there is a lot more to the XML configuration file, the above example points out the most critical parts. Notice the XML header, required to validate the XML document. The body of the environment element contains the environment configuration for transaction management and connection pooling. The mappers element contains a list of mappers – the XML files and/or annotated Java interface classes that contain the SQL code and mapping definitions. 当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。 Building SqlSessionFactory without XML 不使用 XML 构建 SqlSessionFactoryIf you prefer to directly build the configuration from Java, rather than XML, or create your own configuration builder, MyBatis provides a complete Configuration class that provides all of the same configuration options as the XML file. 如果你更愿意直接从 Java 程序而不是 XML 文件中创建 configuration，或者创建你自己的 configuration 构建器，MyBatis 也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项。123456DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); Notice in this case the configuration is adding a mapper class. Mapper classes are Java classes that contain SQL Mapping Annotations that avoid the need for XML. However, due to some limitations of Java Annotations and the complexity of some MyBatis mappings, XML mapping is still required for the most advanced mappings (e.g. Nested Join Mapping). For this reason, MyBatis will automatically look for and load a peer XML file if it exists (in this case, BlogMapper.xml would be loaded based on the classpath and name of BlogMapper.class). More on this later. 注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射语句的注解从而避免了 XML 文件的依赖。不过，由于 Java 注解的一些限制加之某些 MyBatis 映射的复杂性，XML 映射对于大多数高级映射（比如：嵌套 Join 映射）来说仍然是必须的。有鉴于此，如果存在一个对等的 XML 配置文件的话，MyBatis 会自动查找并加载它（这种情况下， BlogMapper.xml 将会基于类路径和 BlogMapper.class 的类名被加载进来）。具体细节稍后讨论。 Acquiring a SqlSession from SqlSessionFactory 从 SqlSessionFactory 中获取 SqlSessionNow that you have a SqlSessionFactory, as the name suggests, you can acquire an instance of SqlSession. The SqlSession contains absolutely every method needed to execute SQL commands against the database. You can execute mapped SQL statements directly against the SqlSession instance. For example: 既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：123456SqlSession session = sqlSessionFactory.openSession();try &#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125; finally &#123; session.close();&#125; While this approach works, and is familiar to users of previous versions of MyBatis, there is now a cleaner approach. Using an interface (e.g. BlogMapper.class) that properly describes the parameter and return value for a given statement, you can now execute cleaner and more type safe code, without error prone string literals and casting. 诚然这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉，不过现在有了一种更直白的方式。使用对于给定语句能够合理描述参数和返回值的接口（比如说BlogMapper.class），你现在不但可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。 For example:1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; finally &#123; session.close();&#125; Now let’s explore what exactly is being executed here. 现在我们来探究一下这里到底是怎么执行的。 Exploring Mapped SQL Statements 探究已映射的 SQL 语句At this point you may be wondering what exactly is being executed by the SqlSession or Mapper class. The topic of Mapped SQL Statements is a big one, and that topic will likely dominate the majority of this documentation. But to give you an idea of what exactly is being run, here are a couple of examples. 现在，或许你很想知道 SqlSession 和 Mapper 到底执行了什么操作，而 SQL 语句映射是个相当大的话题，可能会占去文档的大部分篇幅。不过为了让你能够了解个大概，这里会给出几个例子。 In either of the examples above, the statements could have been defined by either XML or Annotations. Let’s take a look at XML first. The full set of features provided by MyBatis can be realized by using the XML based mapping language that has made MyBatis popular over the years. If you’ve used MyBatis before, the concept will be familiar to you, but there have been numerous improvements to the XML mapping documents that will become clear later. Here is an example of an XML based mapped statement that would satisfy the above SqlSession calls. 在上面提到的两个例子中，一个语句应该是通过 XML 定义，而另外一个则是通过注解定义。先看 XML 定义这个，事实上 MyBatis 提供的全部特性可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你以前用过 MyBatis，这个概念应该会比较熟悉。不过 XML 映射文件已经有了很多的改进，随着文档的进行会愈发清晰。这里给出一个基于 XML 映射语句的示例，它应该可以满足上述示例中 SqlSession 的调用。123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; While this looks like a lot of overhead for this simple example, it is actually very light. You can define as many mapped statements in a single mapper XML file as you like, so you get a lot of mileage out of the XML header and doctype declaration. The rest of the file is pretty self explanatory. It defines a name for the mapped statement “selectBlog”, in the namespace “org.mybatis.example.BlogMapper”, which would allow you to call it by specifying the fully qualified name of “org.mybatis.example.BlogMapper.selectBlog”, as we did above in the following example: 对于这个简单的例子来说似乎有点小题大做了，但实际上它是非常轻量级的。在一个 XML 映射文件中，你想定义多少个映射语句都是可以的，这样下来，XML 头部和文档类型声明占去的部分就显得微不足道了。文件的剩余部分具有很好的自解释性。在命名空间“org.mybatis.example.BlogMapper”中定义了一个名为“selectBlog”的映射语句，这样它就允许你使用指定的完全限定名“org.mybatis.example.BlogMapper.selectBlog”来调用映射语句，就像上面的例子中做的那样：1Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101); Notice how similar this is to calling a method on a fully qualified Java class, and there’s a reason for that. This name can be directly mapped to a Mapper class of the same name as the namespace, with a method that matches the name, parameter, and return type as the mapped select statement. This allows you to very simply call the method against the Mapper interface as you saw above, but here it is again in the following example: 你可能注意到这和使用完全限定名调用 Java 对象的方法是相似的，之所以这样做是有原因的。这个命名可以直接映射到在命名空间中同名的 Mapper 类，并在已映射的 select 语句中的名字、参数和返回类型匹配成方法。这样你就可以向上面那样很容易地调用这个对应 Mapper 接口的方法。不过让我们再看一遍下面的例子：12BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101); The second approach has a lot of advantages. First, it doesn’t depend on a string literal, so it’s much safer. Second, if your IDE has code completion, you can leverage that when navigating your mapped SQL statements. 第二种方法有很多优势，首先它不是基于字符串常量的，就会更安全；其次，如果你的 IDE 有代码补全功能，那么你可以在有了已映射 SQL 语句的基础之上利用这个功能。 NOTE A note about namespaces. Namespaces were optional in previous versions of MyBatis, which was confusing and unhelpful. Namespaces are now required and have a purpose beyond simply isolating statements with longer, fully-qualified names. Namespaces enable the interface bindings as you see here, and even if you don’t think you’ll use them today, you should follow these practices laid out here in case you change your mind. Using the namespace once, and putting it in a proper Java package namespace will clean up your code and improve the usability of MyBatis in the long term. Name Resolution: To reduce the amount of typing, MyBatis uses the following name resolution rules for all named configuration elements, including statements, result maps, caches, etc. Fully qualified names (e.g. “com.mypackage.MyMapper.selectAllThings”) are looked up directly and used if found. Short names (e.g. “selectAllThings”) can be used to reference any unambiguous entry. However if there are two or more (e.g. “com.foo.selectAllThings and com.bar.selectAllThings”), then you will receive an error reporting that the short name is ambiguous and therefore must be fully qualified. 提示 命名空间的一点注释 命名空间（Namespaces）在之前版本的 MyBatis 中是可选的，容易引起混淆因此是没有益处的。现在的命名空间则是必须的，目的是希望能比只是简单的使用更长的完全限定名来区分语句更进一步。 命名空间使得你所见到的接口绑定成为可能，尽管你觉得这些东西未必用得上，你还是应该遵循这里的规定以防哪天你改变了主意。出于长远考虑，使用命名空间，并将它置于合适的 Java 包命名空间之下，你将拥有一份更加整洁的代码并提高了 MyBatis 的可用性。 命名解析：为了减少输入量，MyBatis 对所有的命名配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。 完全限定名（比如“com.mypackage.MyMapper.selectAllThings”）将被直接查找并且找到即用。 短名称（比如“selectAllThings”）如果全局唯一也可以作为一个单独的引用。如果不唯一，有两个或两个以上的相同名称（比如“com.foo.selectAllThings ”和“com.bar.selectAllThings”），那么使用时就会收到错误报告说短名称是不唯一的，这种情况下就必须使用完全限定名。 There’s one more trick to Mapper classes like BlogMapper. Their mapped statements don’t need to be mapped with XML at all. Instead they can use Java Annotations. For example, the XML above could be eliminated and replaced with: 对于像 BlogMapper 这样的映射器类（Mapper class）来说，还有另一招来处理。它们的映射的语句可以不需要用 XML 来做，取而代之的是可以使用 Java 注解。比如，上面的 XML 示例可被替换如下：12345package org.mybatis.example;public interface BlogMapper &#123; @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;) Blog selectBlog(int id);&#125; The annotations are a lot cleaner for simple statements, however, Java Annotations are both limited and messier for more complicated statements. Therefore, if you have to do anything complicated, you’re better off with XML mapped statements. 对于简单语句来说，注解使代码显得更加简洁，然而 Java 注解对于稍微复杂的语句就会力不从心并且会显得更加混乱。因此，如果你需要做很复杂的事情，那么最好使用 XML 来映射语句。 It will be up to you and your project team to determine which is right for you, and how important it is to you that your mapped statements be defined in a consistent way. That said, you’re never locked into a single approach. You can very easily migrate Annotation based Mapped Statements to XML and vice versa. 选择何种方式以及映射语句的定义的一致性对你来说有多重要这些完全取决于你和你的团队。换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。 Scope and Lifecycle 范围和生命周期It’s very important to understand the various scopes and lifecycles classes we’ve discussed so far. Using them incorrectly can cause severe concurrency problems. 理解我们目前已经讨论过的不同范围和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。 NOTE Object lifecycle and Dependency Injection Frameworks Dependency Injection frameworks can create thread safe, transactional SqlSessions and mappers and inject them directly into your beans so you can just forget about their lifecycle. You may want to have a look at MyBatis-Spring or MyBatis-Guice sub-projects to know more about using MyBatis with DI frameworks. 提示 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器（mapper）并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。如果对如何通过依赖注入框架来使用 MyBatis 感兴趣可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 SqlSessionFactoryBuilderThis class can be instantiated, used and thrown away. There is no need to keep it around once you’ve created your SqlSessionFactory. Therefore the best scope for instances of SqlSessionFactoryBuilder is method scope (i.e. a local method variable). You can reuse the SqlSessionFactoryBuilder to build multiple SqlSessionFactory instances, but it’s still best not to keep it around to ensure that all of the XML parsing resources are freed up for more important things. 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。 SqlSessionFactoryOnce created, the SqlSessionFactory should exist for the duration of your application execution. There should be little or no reason to ever dispose of it or recreate it. It’s a best practice to not rebuild the SqlSessionFactory multiple times in an application run. Doing so should be considered a “bad smell”. Therefore the best scope of SqlSessionFactory is application scope. This can be achieved a number of ways. The simplest is to use a Singleton pattern or Static Singleton pattern. SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳范围是应用范围。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSessionEach thread should have its own instance of SqlSession. Instances of SqlSession are not to be shared and are not thread safe. Therefore the best scope is request or method scope. Never keep references to a SqlSession instance in a static field or even an instance field of a class. Never keep references to a SqlSession in any sort of managed scope, such as HttpSession of the Servlet framework. If you’re using a web framework of any sort, consider the SqlSession to follow a similar scope to that of an HTTP request. In other words, upon receiving an HTTP request, you can open a SqlSession, then upon returning the response, you can close it. Closing the session is very important. You should always ensure that it’s closed within a finally block. The following is the standard pattern for ensuring that SqlSessions are closed: 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理范围中，比如 Serlvet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的范围中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; Using this pattern consistently throughout your code will ensure that all database resources are properly closed. 在你的所有的代码中一致性地使用这种模式来保证所有数据库资源都能被正确地关闭。 Mapper Instances 映射器实例Mappers are interfaces that you create to bind to your mapped statements. Instances of the mapper interfaces are acquired from the SqlSession. As such, technically the broadest scope of any mapper instance is the same as the SqlSession from which they were requested. However, the best scope for mapper instances is method scope. That is, they should be requested within the method that they are used, and then be discarded. They do not need to be closed explicitly. While it’s not a problem to keep them around throughout a request, similar to the SqlSession, you might find that managing too many resources at this level will quickly get out of hand. Keep it simple, keep Mappers in the method scope. The following example demonstrates this practice. 映射器是创建用来绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，映射器实例的最大范围是和 SqlSession 相同的，因为它们都是从 SqlSession 里被请求的。尽管如此，映射器实例的最佳范围是方法范围。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求范围（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个范围上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法范围（method scope）内。下面的示例就展示了这个实践：1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); // do work&#125; finally &#123; session.close();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim速查卡]]></title>
      <url>%2F2016%2F10%2F15%2Fvim%E9%80%9F%E6%9F%A5%E5%8D%A1%2F</url>
      <content type="text"><![CDATA[vim速查卡这个速查卡来自这里。其用颜色标注了级别： Green = 存活级 Yellow = 感觉良好 Orange/Blue = 高级 Red = 专家级 你还可以下载PDF版的和Excel版的，如果你是色盲的话，还有蓝色版PDF的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>%2F2016%2F10%2F13%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Fork自Github 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 感谢 Markdown 免费编辑器 概述 宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： &amp;copy; Markdown 会保留它不动。而若你写： AT&amp;T Markdown 就会将它转为： AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue 等同于： + Red + Green + Blue 也等同于： - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： &lt;ol&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;McHale&lt;/li&gt; &lt;li&gt;Parish&lt;/li&gt; &lt;/ol&gt; 如果你的列表标记写成： 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt;标签包起来，举例来说： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;Magic&lt;/li&gt; &lt;/ul&gt; 但是这个： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： * This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： &lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt; an example&lt;/a&gt; inline link.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成： &lt;em&gt;single asterisks&lt;/em&gt; &lt;em&gt;single underscores&lt;/em&gt; &lt;strong&gt;double asterisks&lt;/strong&gt; &lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \*this text is surrounded by literal asterisks\* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（` ），例如： Use the `printf()` function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don&apos;t use any `&lt;blink&gt;` tags. 转为： &lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &lt;address@example.com&gt; Markdown 会转成： &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65; &amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111; &amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61; &amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 感谢 感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。 感谢 fenprace，addv。 Markdown 免费编辑器 Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) 高级应用 Sublime Text 2 + MarkdownEditing / 教程 *** 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown快速入门]]></title>
      <url>%2F2016%2F10%2F10%2Fmarkdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Fork自Github 段落、标题、区块代码一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;‘ 角括号。 Markdown 语法: A First Level Header ==================== A Second Level Header --------------------- Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog&apos;s back. ### Header 3 &gt; This is a blockquote. &gt; &gt; This is the second paragraph in the blockquote. &gt; &gt; ## This is an H2 in a blockquote 输出 HTML 为： &lt;h1&gt;A First Level Header&lt;/h1&gt; &lt;h2&gt;A Second Level Header&lt;/h2&gt; &lt;p&gt;Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.&lt;/p&gt; &lt;p&gt;The quick brown fox jumped over the lazy dog&apos;s back.&lt;/p&gt; &lt;h3&gt;Header 3&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;This is a blockquote.&lt;/p&gt; &lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt; &lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt; &lt;/blockquote&gt; 修辞和强调Markdown 使用星号和底线来标记需要强调的区段。 Markdown 语法: Some of these words *are emphasized*. Some of these words _are emphasized also_. Use two asterisks for **strong emphasis**. Or, if you prefer, __use two underscores instead__. 输出 HTML 为: &lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;. Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;. Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt; 列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号： * Candy. * Gum. * Booze. 加号： + Candy. + Gum. + Booze. 和减号 - Candy. - Gum. - Booze. 都会输出 HTML 为： &lt;ul&gt; &lt;li&gt;Candy.&lt;/li&gt; &lt;li&gt;Gum.&lt;/li&gt; &lt;li&gt;Booze.&lt;/li&gt; &lt;/ul&gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记： 1. Red 2. Green 3. Blue 输出 HTML 为： &lt;ol&gt; &lt;li&gt;Red&lt;/li&gt; &lt;li&gt;Green&lt;/li&gt; &lt;li&gt;Blue&lt;/li&gt; &lt;/ol&gt; 如果你在项目之间插入空行，那项目的内容会用 &lt;p&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。 * A list item. With multiple paragraphs. * Another item in the list. 输出 HTML 为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt; &lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 链接Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。 行内形式是直接在后面用括号直接接上链接： This is an [example link](http://example.com/). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 你也可以选择性的加上 title 属性： This is an [example link](http://example.com/ &quot;With a Title&quot;). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容： I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 输出 HTML 为： &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写： I start my morning with a cup of coffee and [The New York Times][NY Times]. [ny times]: http://www.nytimes.com/ 输出 HTML 为： &lt;p&gt;I start my morning with a cup of coffee and &lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt; 图片图片的语法和链接很像。 行内形式（title 是选择性的）： ![alt text](/path/to/img.jpg &quot;Title&quot;) 参考形式： ![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot; 上面两种方法都会输出 HTML 为： &lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码： I strongly recommend against using any `&lt;blink&gt;` tags. I wish SmartyPants used named entities like `&amp;mdash;` instead of decimal-encoded entites like `&amp;#8212;`. 输出 HTML 为： &lt;p&gt;I strongly recommend against using any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; &lt;p&gt;I wish SmartyPants used named entities like &lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encoded entites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt; 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。 Markdown 语法: If you want your page to validate under XHTML 1.0 Strict, you&apos;ve got to put paragraph tags in your blockquotes: &lt;blockquote&gt; &lt;p&gt;For example.&lt;/p&gt; &lt;/blockquote&gt; 输出 HTML 为： &lt;p&gt;If you want your page to validate under XHTML 1.0 Strict, you&apos;ve got to put paragraph tags in your blockquotes:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt; &amp;lt;/blockquote&amp;gt; &lt;/code&gt;&lt;/pre&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java字符串]]></title>
      <url>%2F2016%2F10%2F10%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[String在Java中是一种特殊的类型，它是不可变的。也就是说，只要一个string对象在Java Heap中被创建，就无法再修改它。如果修改它，实际上会创建一个新的String对象，而最初的String对象丝毫未变。 创建String对象 字面量形式创建例如： 1String s = &quot;abc&quot;; JVM为了减少字符串对象的重复创建，维护了一段特殊的内存，这段内存被成为字符串常量池或者字符串字面量池. 当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。 使用new关键字当我们使用了new来构造字符串对象的时候，不管字符串常量池中有没有相同内容的对象的引用，新的字符串对象都会创建。 代码： &#39;==&#39;的含义- -&gt; 基本数据类型之间应用双等号，比较的是他们的数值。复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。 1234567891011121314151617181920212223242526272829String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;; //在常量池中查找对象System.out.println(s1 == s2); //trueString s3 = &quot;abc&quot;;String s4 = new String(&quot;abc&quot;); //直接在堆内存(Java Heap)中创建一个新的对象System.out.println(s3 == s4); //falseString s5 = &quot;abc&quot;;String s6 = &quot;def&quot;;String s7 = s5 + s6; //对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。String s8 = &quot;abcdef&quot;;String s9 = &quot;abc&quot; + &quot;def&quot;; //只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。System.out.println(s7 == s8); //falseSystem.out.println(s8 == s9); //trueString ss = new String(&quot;abc&quot;);/*这条语句创建了2个对象考虑类加载阶段和实际执行时:（1）类加载对一个类只会进行一次。&quot;abc&quot;在类加载时就已经创建并驻留了（如果该类被加载之前已经有&quot;abc&quot;字符串被驻留过则不需要重复创建用于驻留的&quot;abc&quot;实例）。驻留的字符串是放在全局共享的字符串常量池中的。（2）在这段代码后续被运行的时候，&quot;abc&quot;字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给ss持有。 */String ss1 = &quot;abc&quot;;String ss2 = new String(&quot;abc&quot;);String ss3 = ss2.intern();System.out.println(ss1 == ss3); //trueSystem.out.println(ss2 == ss3); //false 为什么把String设计成不可变的？字符串常量池字符串常量池实现的前提条件就是Java中String对象是不可变的，这样可以安全保证多个变量共享同一个对象。如果Java中的String对象可变的话，一个引用操作改变了对象的值，那么其他的变量也会受到影响，显然这样是不合理的。 缓存HashcodeJava中经常会用到字符串的哈希码（hashcode）。例如，在HashMap中，字符串的不可变能保证其hashcode永远保持一致，这样就可以避免一些不必要的麻烦。这也就意味着每次在使用一个字符串的hashcode的时候不用重新计算一次，这样更加高效。 在String类中，有以下代码：1private int hash;//this is used to cache hash code. 以上代码中hash变量中就保存了一个String对象的hashcode，因为String类不可变，所以一旦对象被创建，该hash值也无法改变。所以，每次想要使用该对象的hashcode的时候，直接返回即可。 使其他类的使用更加便利在介绍这个内容之前，先看以下代码：1234567HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();set.add(new String(&quot;a&quot;));set.add(new String(&quot;b&quot;));set.add(new String(&quot;c&quot;));for(String a: set) a.value = &quot;a&quot;; 在上面的例子中，如果字符串可以被改变，那么以上用法将有可能违反Set的设计原则，因为Set要求其中的元素不可以重复。上面的代码只是为了简单说明该问题，其实String类中并没有value这个字段值。 安全性String被广泛的使用在其他Java类中充当参数。比如网络连接、打开文件等操作。如果字符串可变，那么类似操作可能导致安全问题。因为某个方法在调用连接操作的时候，他认为会连接到某台机器，但是实际上并没有（其他引用同一String对象的值修改会导致该连接中的字符串内容被修改）。可变的字符串也可能导致反射的安全问题，因为他的参数也是字符串。 代码示例：1234567boolean connect(string s)&#123; if (!isSecure(s)) &#123;throw new SecurityException();&#125; //如果s在该操作之前被其他的引用所改变，那么就可能导致问题。 causeProblem(s);&#125; 不可变对象天生就是线程安全的因为不可变对象不能被改变，所以他们可以自由地在多个线程之间共享。不需要任何同步处理。 总之，String被设计成不可变的主要目的是为了安全和高效。所以，使String是一个不可变类是一个很好的设计。 String对象作为方法参数String作为方法参数传递时，实际上传递的是引用的一个拷贝,即“值传递”，方法操作的是参数变量只是原型变量的一个拷贝而已，而非变量本身。例如：123456789private static void changeString(String s) &#123; s = &quot;def&quot;; &#125;private static void change() &#123; String s = &quot;abc&quot;; changeString(s); System.out.println(s); //输出abc&#125; StringBuilder与StringBuffer既然String对象时不可变的，那么如果频繁的改变String对象，就会频繁的创建String对象，导致执行效率低下。此时，可以改用StringBuilder或StringBuffer，它们是可变的字符串对象，区别是： StringBuilder：线程非安全的 StringBuffer：线程安全的 #问题 引用 or 对象字符串常量池中存放的时引用还是对象，这个问题是最常见的。字符串常量池存放的是对象引用，不是对象。在Java中，对象都创建在堆内存中。 优缺点字符串常量池的好处就是减少相同内容字符串的创建，节省内存空间。 如果硬要说弊端的话，就是牺牲了CPU计算时间来换空间。CPU计算时间主要用于在字符串常量池中查找是否有内容相同对象的引用。不过其内部实现为HashTable，所以计算成本较低。 GC回收？因为字符串常量池中持有了共享的字符串对象的引用，这就是说是不是会导致这些对象无法回收？ 首先问题中共享的对象一般情况下都比较小。据我查证了解，在早期的版本中确实存在这样的问题，但是随着弱引用的引入，目前这个问题应该没有了。 关于这个问题，可以具体了解这片文章interned Strings : Java Glossary 总有例外？你知道下面的代码，会创建几个字符串对象，在字符串常量池中保存几个引用么？ 1String test = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;; 答案是只创建了一个对象，在常量池中也只保存一个引用。我们使用javap反编译看一下即可得知。 123456789101112131417:02 $ javap -c TestInternedPoolGCCompiled from &quot;TestInternedPoolGC.java&quot;public class TestInternedPoolGC extends java.lang.Object&#123;public TestInternedPoolGC(); Code: 0: aload_0 1: invokespecial #1; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: returnpublic static void main(java.lang.String[]) throws java.lang.Exception; Code: 0: ldc #2; //String abc 2: astore_1 3: return 看到了么，实际上在编译期间，已经将这三个字面量合成了一个。这样做实际上是一种优化，避免了创建多余的字符串对象，也没有发生字符串拼接问题。关于字符串拼接，可以查看Java细节：字符串的拼接。 参考资料：Hollis技术小黑屋]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简明 Vim 练级攻略]]></title>
      <url>%2F2016%2F10%2F06%2F%E7%AE%80%E6%98%8Evim%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5%2F</url>
      <content type="text"><![CDATA[简明 Vim 练级攻略，转自酷壳 前言你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。 Vim the Six Billion Dollar editor1Better, Stronger, Faster. 学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。 我建议下面这四个步骤： 存活 感觉良好 觉得更好，更强，更快 使用VIM的超能力 当你走完这篇文章，你会成为一个vim的 superstar。 在开始学习以前，我需要给你一些警告： 学习vim在开始时是痛苦的。 需要时间 需要不断地练习，就像你学习一个乐器一样。 不要期望你能在3天内把vim练得比别的编辑器更有效率。 事实上，你需要2周时间的苦练，而不是3天。 第一级 – 存活 安装 vim 启动 vim 什么也别干！请先阅读当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作： 启动Vim后，vim在 Normal 模式下。 让我们进入 Insert 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了） 此时，你可以输入文本了，就像你用“记事本”一样。 如果你想返回 Normal 模式，请按 ESC 键。 现在，你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令，可以让你在 Normal 模式下幸存下来：12345678910i → Insert 模式，按 ESC 回到 Normal 模式.x → 删当前光标所在的一个字符。:wq → 存盘 + 退出 (:w 存盘, :q 退出)dd → 删除当前行，并把删除的行存到剪贴板里p → 粘贴剪贴板推荐:hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。:help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q） 你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。 当是，在你进入第二级时，需要再说一下 Normal 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 Ctrl 键，比如：Ctrl-C。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，在VIM的Normal模式下，所有的键就是功能键了。这个你需要知道。 标记: 下面的文字中，如果是 Ctrl-λ我会写成 &lt;C-λ&gt;. 以 : 开始的命令你需要输入 &lt;enter&gt;回车，例如 — 如果我写成 :q 也就是说你要输入 :q&lt;enter&gt;. 第二级 – 感觉良好上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键） 各种插入模式 a → 在光标后插入 o → 在当前行后插入一个新行 O → 在当前行前插入一个新行 cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 /pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个） 拷贝/粘贴（陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前） P → 粘贴 yy → 拷贝当前行当行于 ddP Undo/Redo u → undo &lt;C-r&gt; → redo 打开/保存/退出/改变文件(Buffer) :e &lt;path/to/file&gt; → 打开一个文件 :w → 存盘 :saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt; :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车) :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件） 花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。 第三级 – 更好，更强，更快先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。 更好下面，让我们看一下vim是怎么重复自己的： . → (小数点) 可以重复上一次的命令 N&lt;command&gt; → 重复某个命令N次下面是一个示例，找开一个文件你可以试试下面的命令：123452dd → 删除2行3p → 粘贴文本3次100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “. → 重复上一个命令—— 100 “desu “.3. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊). 更强你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。 NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行） gg → 到第一行。（陈皓注：相当于1G，或 :1） G → 到最后一行。 按单词移动 w → 到下一个单词的开头。 e → 到下一个单词的结尾。 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量） 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句） 下面，让我来说说最强的光标移动 % : 匹配括号移动，包括 (, {, [. （陈皓注：你需要把光标先移到括号上） *和#: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） 相信我，上面这三个命令对程序员来说是相当强大的。 更快你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干： &lt;start position&gt;&lt;command&gt;&lt;end position&gt; 例如 0y$ 命令意味着: 0 → 先到行头 y → 从这里开始拷贝 $ → 拷贝到本行最后一个字符 你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。 你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。 还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝： d (删除 ) v (可视化的选择) gU (变大写) gu (变小写) 等等（陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等） 第四级 – Vim 超能力你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。 在当前行上移动光标: 0 ^ $ f F t T , ; 0 → 到行头 ^ → 到本行的第一个非blank字符 $ → 到行尾 g_ → 到本行最后一个不是blank字符的位置。 fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。 t, → 到逗号前的第一个字符。逗号可以变成其它字符。 3fa → 在当前行查找第三个出现的a。 F 和 T → 和 f 和 t 一样，只不过是相反方向。 还有一个很有用的命令是 dt” → 删除所有的内容，直到遇到双引号—— “。 区域选择在visual 模式下，这些命令很强大，其命令格式为 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt; action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：”、 ‘、 )、 }、 ]。 假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。 vi” → 会选择 foo. va” → 会选择 “foo”. vi) → 会选择 “foo”. va) → 会选择(“foo”). v2i) → 会选择 map (+) (“foo”) v2a) → 会选择 (map (+) (“foo”)) 块操作: &lt;C-v&gt;块操作，典型的操作： 0 &lt;C-v&gt; &lt;C-d&gt; I– [ESC] 0 → 到行头 &lt;C-v&gt; → 开始块操作 &lt;C-d&gt; → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) I– [ESC] → I是插入，插入“–”，按ESC键来为每一行生效。在Windows下的vim，你需要使用 &lt;C-q&gt; 而不是 &lt;C-v&gt; ，&lt;C-v&gt; 是拷贝剪贴板。 自动提示： &lt;C-n&gt; 和 &lt;C-p&gt;在 Insert 模式下，你可以输入一个词的开头，然后按 &lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了…… 宏录制：qa 操作序列 q, @a, @@ qa 把你的操作记录在寄存器 a。 于是 @a 会replay被录制的宏。 @@ 是一个快捷键用来replay最新录制的宏。 示例:在一个只有一行且这一行只有“1”的文本中，键入如下命令： qaYp&lt;C-a&gt;q→ qa 开始录制 Yp 复制行. &lt;C-a&gt; 增加1. q 停止录制. @a → 在1下面写下 2 @@ → 在2 正面写下3 现在做 100@@ 会创建新的100行，并把数据增加到 103. 可视化选择： v,V,&lt;C-v&gt;前面，我们看到了 &lt;C-v&gt;的示例 （在Windows下应该是&lt;C-q&gt;），我们可以使用 v 和 V。一但被选好了，你可以做下面的事： J → 把所有的行连接起来（变成一行） &lt;或 &gt; → 左右缩进 = → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）在所有被选择的行后加上点东西： &lt;C-v&gt; 选中相关的行 (可使用 j 或 &lt;C-d&gt; 或是 /pattern 或是 % 等……) $ 到行最后 A, 输入字符串，按 ESC。 分屏::split 和 vsplit.下面是主要的命令，你可以使用VIM的帮助 :help split. 你可以参考本站以前的一篇文章VIM分屏。 :split → 创建分屏 (:vsplit创建垂直分屏) &lt;C-w&gt;&lt;dir&gt; : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。 &lt;C-w&gt;_ (或 &lt;C-w&gt;|) : 最大化尺寸 (&lt;C-w&gt;| 垂直分屏) &lt;C-w&gt;+ (或 &lt;C-w&gt;-) : 增加尺寸结束语 上面是作者最常用的90%的命令。 我建议你每天都学1到2个新的命令。 在两到三周后，你会感到vim的强大的。 有时候，学习VIM就像是在死背一些东西。 幸运的是，vim有很多很不错的工具和优秀的文档。 运行vimtutor直到你熟悉了那些基本命令。 其在线帮助文档中你应该要仔细阅读的是 :help usr_02.txt. 你会学习到诸如 !， 目录，寄存器，插件等很多其它的功能。 学习vim就像学弹钢琴一样，一旦学会，受益无穷。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装mongoDB]]></title>
      <url>%2F2016%2F10%2F03%2F%E5%AE%89%E8%A3%85mongoDB%2F</url>
      <content type="text"><![CDATA[安装mongoDB 下载安装包下载 解压 1tar -zxvf mongodb-osx-x86_64-3.2.10.tgz 移动到安装位置 12mkdir -p /usr/local/mongodbsudo mv mongodb-osx-x86_64-3.2.10/ /usr/local/mongobd 添加到环境变量 1export PATH=$PATH:/usr/local/mongodb/mongodb-osx-x86_64-3.2.10/bin 创建data文件夹 1234cd /mkdir -p /data/dbmkdir -p /data/logsudo chown -R lingyv /data 运行 1mongod 进入mongoDB shell 1mongo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java--相对路径]]></title>
      <url>%2F2016%2F10%2F01%2F%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[Java开发中的绝对路径与相对路径 基本概念绝对路径文件或目录在硬盘上真正的路径。例如D:\abc\test.txt 代表了test.txt文件的绝对路径。http://blog.lingyv.org/index.htm也代表了一个URL绝对路径。 相对路径相对与某个基准文件或目录的路径。例如：”./“ 代表当前目录, “../“代表上级目录。 JSP/Servlet中的相对路径服务器端服务器中解析相对地址是相对于web应用的地址，例如web应用为test，那么”/user/login”在浏览器中的地址就是”http://localhost:8080/test/user/login“ 客户端浏览器解析html时，相对地址是相对于服务器根目录的，例如”/user/login”地址是”http://localhost:8080/user/login“ 问题由于浏览器解析html时，相对地址是相对于服务器根目录的，所以如果我们在html文件中使用相对路径(./，../)定位js，css等，当我们通过转发forward访问该文件时，js，css等静态的url就会出错，导致定位不到这些资源。 解决既然我们想要自定义站点，那肯定不能把绝对路径写死，但又不能用相对路径，因为转发时又会出问题。那怎么办呢？写一个可以变化的绝对路径吧，jsp中使用${pageContext.request.contextPath}来获取站点信息，然后写到绝对路径里。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RIME快速指南]]></title>
      <url>%2F2016%2F09%2F25%2FRIME%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[RIME快速指南 數據文件分佈及作用共享資料夾: 【中州韻】 /usr/share/rime-data/ 【小狼毫】 “安裝目錄\data” 【鼠鬚管】 “/Library/Input Methods/Squirrel.app/Contents/SharedSupport/“ 用戶資料夾: 【中州韻】 ~/.config/ibus/rime/ （0.9.1 以下版本爲 ~/.ibus/rime/） 【小狼毫】 “%APPDATA%\Rime” 【鼠鬚管】 ~/Library/Rime/ 共享資料夾包含預設輸入方案的源文件。 這些文件屬於 Rime 所發行軟件的一部份，在訪問權限控制較嚴格的系統上對用戶是只讀的，因此謝絕軟件版本更新以外的任何修改—— 一旦用戶修改這裏的文件，很可能影響後續的軟件升級或在升級時丟失數據。 在「部署 Rime」操作時，將用到這裏的輸入方案源文件、並結合用戶定製的內容來編譯預設輸入方案。 用戶資料夾則包含爲用戶準備的內容，如： 〔全局設定〕 default.yaml 〔發行版設定〕 weasel.yaml 〔預設輸入方案副本〕 &lt;方案標識&gt;.schema.yaml ※〔安裝信息〕 installation.yaml ※〔用戶狀態信息〕 user.yaml 編譯輸入方案所產出的二進制文件： 〔Rime 棱鏡〕 &lt;方案標識&gt;.prism.bin 〔Rime 固態詞典〕 &lt;詞典名&gt;.table.bin 〔Rime 反查詞典〕 &lt;詞典名&gt;.reverse.bin 記錄用戶寫作習慣的文件： ※〔用戶詞典〕 &lt;詞典名&gt;.userdb.kct ※〔用戶詞典快照〕 &lt;詞典名&gt;.userdb.txt、&lt;詞典名&gt;.userdb.kct.snapshot 見於同步文件夾 以及用戶自己設定的： ※〔用戶對全局設定的定製信息〕 default.custom.yaml ※〔用戶對預設輸入方案的定製信息〕 &lt;方案標識&gt;.custom.yaml ※〔用戶自製輸入方案〕及配套的詞典源文件註：以上標有 ※ 號的文件，包含用戶資料，您在清理文件時要注意備份！ 修改配置文件的方式創建一個文件名的主體部份（「.」之前）與要定製的文件相同、次級擴展名（「.yaml」之前）爲 .custom 的定製文檔：123456789patch: &quot;一級設定項/二級設定項/三級設定項&quot;: 新的設定值 &quot;另一個設定項&quot;: 新的設定值 &quot;再一個設定項&quot;: 新的設定值 &quot;含列表的設定項/@n&quot;: 列表第n個元素新的設定值,从零开始计数 &quot;含列表的設定項/@last&quot;: 列表最後一個元素新的設定值 &quot;含列表的設定項/@before 0&quot;: 在列表第一個元素之前插入新的設定值（不建議在補靪中使用） &quot;含列表的設定項/@after last&quot;: 在列表最後一個元素之後插入新的設定值（不建議在補靪中使用） &quot;含列表的設定項/@next&quot;: 在列表最後一個元素之後插入新的設定值（不建議在補靪中使用） 就是這樣：patch 定義了一組「補靪」，以源文件中的設定爲基礎，寫入新的設定項、或以新的設定值取代現有設定項的值。 定制default.yaml文件新建default.custom.yaml文件 定制每页候选数12patch: &quot;menu/page_size&quot;: 9 #候选数 定制方案选单1234567patch: schema_list: # 對於列表類型，現在無有辦法指定如何添加、消除或單一修改某項，於是要在定製檔中將整個列表替換！ - schema: luna_pinyin - schema: cangjie5 - schema: luna_pinyin_fluency - schema: luna_pinyin_simp - schema: my_coolest_ever_schema # 這樣就啓用了未曾有過的高級輸入方案！其實這麼好的方案應該排在最前面哈。 左Shift键输入字符直接切换为英文上屏，输入状态变为英文12345678patch: ascii_composer/good_old_caps_lock: true ascii_composer/switch_key: Caps_Lock: noop Shift_L: commit_code #其中L指Left，左的意思。commit-提交。code－代码。当我们输入一段文字未上屏之前，按此键后字符将被将直接上屏，RIME切换为英文输入状态。再次按此键RIME切换回中文输入状态。 Shift_R: inline_ascii #其中R指Right，右的意思。inline－直接插入。ascii－字符，美国信息交换标准码。这个设置就是RIME的默认设置，在我们输入一段文字未上屏之前，按此键后，不上屏，字符转变为英文输入，按Enter键英文字符上屏，之后默认还是中文输入。 Control_L: clear #其中clear为清除的意思。在你输入一段字符后按此键，字符被清除，同时RIME输入状态切换为英文输入。在按此键，RIME输入切换回中文输入。（与clear类似但不转换输入状态的快捷键是Esc键） Control_R: commit_text #其中text为文本的意思。在你输入一段拼音字符后，按此键，文字上屏，同时RIME切换为英文输入。在按此键，切换回来。 定制weasel.yaml文件创建weasel.custom.yaml文件 定制字体字号123patch: &quot;style/font_face&quot;: &quot;明兰&quot; # 字體名稱，從記事本等處的系統字體對話框裏能看到 &quot;style/font_point&quot;: 14 # 字號，只認數字的，不認「五號」、「小五」這樣的 定制配色方案12345678910111213patch: &quot;style/color_scheme&quot;: starcraft # 這項用於選中下面定義的新方案 &quot;preset_color_schemes/starcraft&quot;: # 在配色方案列表裏加入標識爲 starcraft 的新方案 name: 星際我爭霸／StarCraft author: Contralisk &lt;contralisk@gmail.com&gt;, original artwork by Blizzard Entertainment text_color: 0xccaa88 # 編碼行文字顏色，24位色值，用十六進制書寫方便些，順序是藍綠紅0xBBGGRR candidate_text_color: 0x30bb55 # 候選項文字顏色，當與文字顏色不同時指定 back_color: 0x000000 # 底色 border_color: 0x1010a0 # 邊框顏色，與底色相同則爲無邊框的效果 hilited_text_color: 0xfecb96 # 高亮文字，即與當前高亮候選對應的那部份輸入碼 hilited_back_color: 0x000000 # 設定高亮文字的底色，可起到凸顯高亮部份的作用 hilited_candidate_text_color: 0x60ffa8 # 高亮候選項的文字顏色，要醒目！ hilited_candidate_back_color: 0x000000 # 高亮候選項的底色，若與背景色不同就會顯出光棒 外观设置1234patch: style/horizontal: true # 候選橫排 style/inline_preedit: true # 內嵌編碼（僅支持TSF） style/display_tray_icon: true # 顯示托盤圖標 个人词库配置同步打开用户文件夹中的installation.yaml文件12installation_id: &apos;MacBook&apos;sync_dir: &apos;D:\Dropbox\RimeSync&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈面对对象编程]]></title>
      <url>%2F2016%2F09%2F22%2F%E8%B0%88%E8%B0%88%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[转自:程序人生最近写了些和函数式编程的文章，有读者和我讨论函数式编程和面向对象编程的优劣。二者都是很好的编程思想，都在着力解决代码重用的问题，也彼此吸收对方的优点，所以大可不必去分个高下。然而，我面试过许多号称精通面向对象编程（比如：Python / Ruby / C++）的工程师，随便问几个问题，就可以看出这个人对面向对象的理解： 你觉得在面向对象编程中，最重要的思想是什么？ 如果有人提及「继承」，我会让她写个她在工作中使用继承的例子。 如果有人提及「多态」，我会让她解释一下多态，并让她写个她在工作中使用多态的例子。 如果有人提及「代码重用」，我会让她谈谈她对代码重用的理解，并附上一个工作中重用的例子。 对第一个问题，很多人回答继承，有些人会添上接口，多态等概念，很少人会提及代码重用。 对第二个问题，几乎 80% 的人都会写出对象继承的代码，而这里面有一大半的人写出的「工作中」使用继承的例子竟然是某著名垃圾书中的经典误人子弟的例子：Duck 继承于 Bird，Bird 继承于 Animal。 对第三个问题，几乎所有人都是写出对象继承中的多态，然后一般的人给出的还是那本著名垃圾书里的著名例子：鸟能飞，也会叫，鸭子呱呱呱但不会飞。你可以把鸭子对象赋给鸟，让它发出呱呱呱的叫声。 对于第四个问题，嗯，如果有人回答到第四个问题，并能信手拈来 Iterable，Comparable，这个人如果没看『程序人生』的文章（嘿嘿），那就是基础知识和编程思想已经八九不离十，可以聊对象以外的东西了。 面向对象编程和函数式编程中最基本，也是最重要的要素是 代码重用，或者更严格地说 代码被重用。这里为什么要严格区分代码重用和代码被重用呢？代码重用根本不是个事儿，除非使用汇编语言，否则你写十行代码，九行都是在重用别人的代码 —— 连往 console 输出这样的简单语句，你是不是都用了语言本身的库函数？就算语言将其归入核心语法，这个语言的实现也必定在底层调用了 libC 的某个函数，来获取操作系统对此的支持。所以说，干编程这一行，重用别人的代码，我们最在行不过；而让自己的代码被别人重用，我们往往底气不足。 写过半年以上 Python 的，应该都知道所谓的 magic function，如果你的类定义实现了某个 magic function，那么类就会拥有一些神奇的能力，比如： 上述的类并没有继承任何已知的类（隐式继承 object 不算），然而它可以很容易被别的代码用一种公共的方式调用： 这便是代码的被重用的能力。这种编程的方式，与其说是面向对象编程，不如说是面向接口编程。对象在这里只是一个幌子，其存在的意义更多地是满足某种接口。在面向接口编程中，接口继承要远重要于类继承。 为什么面向接口编程如此重要？因为它是一种控制反转 —— 通过抽象出一系列接口，并在这些接口上进行操作，使得控制逻辑不依赖于具体的实现；同时，具体的实现可以并不关心控制逻辑如何使用自己，它们会在需要的时候被调用。由此，使用对象的逻辑和对象本身充分解耦，由接口这座桥梁将二者联系起来。这样，代码得到了最大程度的被重用。 谈到接口继承，不得不提 Liskov substitution principle（里氏变换原则），wikipedia 这样介绍它： It states that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S. 这也是面向对象编程中常说的 Substitutability（可替换性）。这段话翻译过来说就是，在类型系统中，如果类型 S 是类型 T 的子类型，那么类型 T 的任意对象可以被类型 S 的对象替换，且不影响程序的正确性。里氏变换是面向对象编程（其实适用于任何编程思想）非常重要的一个原则，也是程序得以多态的基石。如果我们做一个系统，要注意尽一切可能满足这一原则。 什么是多态？wikipedia 是这么解释： polymorphism (from Greek πολύς, polys, “many, much” and μορφή, morphē, “form, shape”) is the provision of a single interface to entities of different types. A polymorphic type is one whose operations can also be applied to values of some other type, or types. 由此可见，多态指的是我们可以对一个操作（接口）使用多种数据类型。多态并不单单是是面向对象编程的一个概念，函数式编程里面，多态也到处可见。我们知道在 Python 里，一个数据结构可以被 map 的前提是其实现了 iter，而在 clojure 里，同样的，一个数据类型实现了 ISeq，它就可以使用 map，而在 elixir 里，Enum.map 需要实现 Enumerable protocol。可见，多态并非是面向对象的专利。 上文中我们调侃的那个「鸟能飞，也会叫，鸭子呱呱呱但不会飞」的所谓面向对象的例子实质上破坏了里氏变换原则。它让你的代码无法享受多态的好处。比如说，你围绕着「鸟」这一基类打造了一个系统，系统的后期开发者用「鸭子」继承了「鸟」，当你的代码执行「飞」这一操作时，由于鸭子不会飞，系统有可能会崩溃（或者抛出异常）。这时你不得不回过头来修改围绕基类打造的系统：当「飞」这个操作运行时，处理一切异常（有时这并不可行）。这就违反了 Open close principle，你为了上层的一个蹩脚的实现，而不得不去修改底层的代码。系统中类似的情况越多，系统的 BUG 就越多。 为了符合里氏变换，我们需要子类严格继承和实现父类的接口，这就带来了一个问题：「类」这个概念在实际使用中，往往被当成一种分类法（taxonomy），也就是 is-a。is-a 是面向对象里面的一个坑，因为我们在判断一个东西是否是 is-a 时，常常使用我们生活中的逻辑概念去判断，这是非常不可靠的，会出现很多蹩脚设计 —— 比如作为父类型的「鸟」会飞，而子类型的「鸭子」不会飞这样不符合里氏变换但符合生活逻辑的设计。使用「鸟」和「鸭子」来讲述面向对象的继承关系，虽然很直观，很形象，却让初学者陷入一个泥潭而不能自拔。 Scott Wlaschin 在他那著名的 Funtional programming patterns 中提到，types are not classes。把「类」（class）等同于「类型」（type）也是初学者常常碰上的坑。在函数式编程里面，类型实际上是一种接口，它是数据和数据可以产生的行为间的一座桥梁： 而「类」是「类型」的一种实现方式。从这个意义上讲，「会飞」（flyable） 是一个类型，「鸟」实现了 flyable，而「鸭子」无法实现 flyable，所以「鸭子」并不是「鸟」的子类型。弄明白了这一点，我们就不会傻乎乎地去根据生活经验，把「鸭子」继承在「鸟」的名下。 而弄明白了这一点，我们也就可以参悟出 java 的设计者为何煞费苦心地为 class 的类继承使用 extends，而接口继承使用 implements，同时如若 override 方法，返回类型必须是 covarient 了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git快速指南--分支]]></title>
      <url>%2F2016%2F09%2F20%2Fgit%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-%E5%88%86%E6%94%AF%2F</url>
      <content type="text"><![CDATA[Git快速指南–分支 Git分支新建分支 1git branch test 切换到其他分支 1git checkout test 新建并切换到该分支 1git checkout -b test 删除分支 1git branch -d test 分支的合并 1git merge master //将当前分支与master分支合并 列出当前所有分支 1git branch 查看各个分支最后一个提交对象的信息 1git branch -v 查看哪些分支已被并入当前分支 1git branch --merged 查看尚未合并的工作 1git branch --no-merged 推送本地分支 12//git push (远程仓库名) (分支名)git push origin serverfix 这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍 refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serverfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git快速指南--基础]]></title>
      <url>%2F2016%2F09%2F10%2Fgit%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[Git快速指南–基础 简介直接记录快照，而非差异比较 Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。如图： Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。如图： 这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。 时刻保持数据完整性 在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。 Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是： 124b9da6552252987aa493b52f8696cd6d3b00373 Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。 多数操作仅添加数据 常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。 文件的三种状态 对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。 由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。 每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone –bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。 从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。 所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改某些文件。 对修改后的文件进行快照，然后保存到暂存区域。 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。 所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。 安装在 Linux 上安装 12yum install git-coreapt-get install git 在 Mac 上安装 1brew install git 在 Windows 上安装[下载](https://git-scm.com/download/win) 初次运行 Git 前的配置用户信息 123用户名称和电子邮件地址git config --global user.name &quot;lingyv&quot;git config --global user.email lingyv@gmail.com 文本编辑器 Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置： 1git config --global core.editor emacs 差异分析工具 还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： 1git config --global merge.tool vimdiff 查看配置信息 1git config --list Git基础取得项目的 Git 仓库 在工作目录中初始化新仓库 1git init 从现有仓库克隆 1git clone [url] name 记录每次更新到仓库 检查当前文件状态 1git status 跟踪新文件 1git add README.md 忽略某些文件创建一个名为 .gitignore 的文件，列出要忽略的文件模式 1234567891011# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt 提交更新 1git commit -m &quot;......&quot; 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： 1git commit -a -m &apos;......&apos; 移除文件 从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件 1git rm README.md 把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录: 1git rm --cached README.md 递归删除当前目录及其子目录中所有 ~ 结尾的文件 1git rm \*~ 移动文件 不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么。要在 Git 中对文件改名，可以这么做： 1git mv README.txt README 其实，运行 git mv 就相当于运行了下面三条命令： 123mv README.txt READMEgit rm README.txtgit add README 查看提交历史 1git log 常用的选项及其释义: 12345678910选项 说明-p 按补丁格式显示每个更新之间的差异。--stat 显示每次更新的文件修改统计信息。--shortstat 只显示 --stat 中最后的行数修改添加移除统计。--name-only 仅在提交信息后显示已修改的文件清单。--name-status 显示新增、修改、删除的文件清单。--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。--graph 显示 ASCII 图形表示的分支合并历史。--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 常用的格式占位符写法及其代表的意义 12345678910111213141516选项 说明%H 提交对象（commit）的完整哈希字串%h 提交对象的简短哈希字串%T 树对象（tree）的完整哈希字串%t 树对象的简短哈希字串%P 父对象（parent）的完整哈希字串%p 父对象的简短哈希字串%an 作者（author）的名字%ae 作者的电子邮件地址%ad 作者修订日期（可以用 -date= 选项定制格式）%ar 作者修订日期，按多久以前的方式显示%cn 提交者(committer)的名字%ce 提交者的电子邮件地址%cd 提交日期%cr 提交日期，按多久以前的方式显示%s 提交说明 例如: 1234567891011git log --pretty=format:&quot;%h %s&quot; --graph* 2d3acf9 ignore errors from SIGCHLD on trap* 5e3ee11 Merge branch &apos;master&apos; of git://github.com/dustin/grit|\| * 420eac9 Added a method for getting the current branch.* | 30e367c timeout code and tests* | 5a09431 add timeout protection to grit* | e1193f8 support for heads with slashes in them|/* d6016bc require time for xmlschema* 11d191e Merge branch &apos;defunkt&apos; into local 撤消操作 任何时候，你都有可能需要撤消刚才所做的某些操作。接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。 修改最后一次提交 1git commit --amend 此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。 启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。 取消已经暂存的文件 1git reset HEAD &lt;file&gt;... 取消对文件的修改 1git checkout -- &lt;file&gt;... 这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用 stashing 和分支来处理，应该会更好些。 记住，任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 –amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。 远程仓库的使用查看当前的远程库 要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。加上 -v 选项（译注：此为 –verbose 的简写，取首字母），显示对应的克隆地址： 1git remote -v 添加远程仓库 1git remote add [shortname] [url] 从远程仓库抓取数据 1git fetch [remote-name] 此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。 1git pull 自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。 推送数据到远程仓库 1git push [remote-name] [branch-name] 查看远程仓库信息 通过命令 git remote show [remote-name] 查看某个远程仓库的详细信息，比如要看所克隆的 origin 仓库，可以运行： 1git remote show origin 远程仓库的删除和重命名 重命名可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行： 1git remote rename pb paul 注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。 删除碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：1git remote rm paul 打标签同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。 列出现有标签 1234git tag用特定的搜索模式列出符合条件的标签git tag -l &apos;v1.4.2.*&apos; 新建标签 轻量级轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。 含附注含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可: 1git tag -a v1.4 -m &apos;my version 1.4&apos; -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。 签署标签如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可： 1git tag -s v1.5 -m &apos;my signed 1.5 tag&apos; 轻量级标签轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可： 1git tag v1.4 验证标签可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证： 1git tag -v v1.4 后期加注标签在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可： 1git tag -a v1.2 9fceb02 分享标签默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可： 1git push origin v1.5 如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux安装JDK]]></title>
      <url>%2F2016%2F09%2F01%2Flinux%E5%AE%89%E8%A3%85JDK%2F</url>
      <content type="text"><![CDATA[linux系统安装JDK 卸载JDK 先查看系统是否已安装JDK，一般情况下linux都默认使用了开源的openJDK。 1java -version 查找名字包含java，jdk的已安装程序 12rpm -qa | grep java rpm -qa | grep jdk 单个卸载程序，使用rpm -e xxx命令 1rpm -e xxx 批量卸载所有名字包含xxx的已安装程序 1rpm -qa | grep xxx | xargs rpm -e --nodeps 安装JDK.rpm后缀格式JDK安装包 安装包添加权限 1chmod 755 jdk-xxx.rpm 使用rpm -ivh xxx命令安装JDK 1rpm -ivh jdk-xxx.rpm 安装.rpm格式后缀的JDK，会自动配置java环境变量，会在/usr/bin生成java、javac等JDK的快捷方式图标,这些图标会链接指向到/usr/java/jdkxxx中 .tar.gz后缀格式JDK安装包 在/usr目录下新建java文件夹 1mkdir /usr/java 压缩包解压 1tar -zxvf jdk-xxx.gz 设置jdk环境变量 12345678vi /etc/profileexport JAVA_HOME=/usr/java/jdkxxxexport JRE_HOME=$JAVA_HOME/jreexport PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/libsource /etc/profile]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java知识点]]></title>
      <url>%2F2016%2F08%2F27%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[Java知识点，转自Grife JAVA相关 Java GC机制(重要程度:★★★★★) 主要从三个方面回答:GC是针对什么对象进行回收(可达性分析法)，什么时候开始GC(当新生代满了会进行Minor GC，升到老年代的对象大于老年代剩余空间时会进行Major GC)，GC做什么(新生代采用复制算法，老年代采用标记-清除或标记-整理算法)，感觉回答这些就差不多了，也可以补充一下可以调优的参数(-XX:newRatio,-Xms,-Xmx等等)。详细的可以看我另一篇博客Java中的垃圾回收机制。 如何线程安全的使用HashMap(重要程度:★★★★★) 作为Java程序员还是经常和HashMap打交道的，所以HashMap的一些原理还是搞搞清除比较好。这个问题感觉主要就是问HashMap，HashTable，ConcurrentHashMap，sychronizedMap的原理和区别。具体的可以看我另一篇博客如何线程安全的使用HashMap。 HashMap是如何解决冲突的(重要程度:★★★★☆) 其实就是链接法，将索引值相同的元素存放到一个单链表里。但为了解决在频繁冲突时HashMap性能降低的问题，Java 8中做了一个小优化，在冲突的元素个数超过设定的值(默认为8)时，会使用平衡树来替代链表存储冲突的元素。具体的可以看我另一篇博客Java 8中HashMap和LinkedHashMap如何解决冲突。 Java创建对象有哪几种(重要程度:★★★★☆) 这个问题还算好回答，大概有四种—new、工厂模式、反射和克隆，不过这个问题有可能衍生出关于设计模式，反射，深克隆，浅克隆等一系列问题。。。要做好准备~ 参考资料：设计模式Java版、Java反射详解、深克隆与浅克隆的区别 注解(重要程度:★★★☆☆) 如果简历中有提到过曾自定义过注解，还是了解清楚比较好。主要是了解在自定义注解时需要使用的两个主要的元注解@Retention和@Target。@Retention用来声明注解的保留策略，有CLASS，RUNTIME,SOURCE三种，分别表示注解保存在类文件，JVM运行时刻和源代码中。@Target用来声明注解可以被添加到哪些类型的元素上，如类型，方法和域等。 参考资料：Java注解 异常(重要程度:★★★☆☆) 一道笔试题，代码如下，问返回值是什么。1234567891011int ret = 0;try&#123; throw new Exception();&#125;catch(Exception e)&#123; ret = 1; return ret;&#125;finally&#123; ret = 2;&#125; 主要的考点就是catch中的return在finally之后执行 但是会将return的值放到一个地方存起来，所以finally中的ret=2会执行，但返回值是1。 参考资料：深入理解Java异常处理机制,Java异常处理 悲观锁和乐观锁区别，乐观锁适用于什么情况(重要程度:★★★★☆) 悲观锁，就是总觉得有刁民想害朕，每次访问数据的时候都觉得会有别人修改它，所以每次拿数据时都会上锁，确保在自己使用的过程中不会被他人访问。乐观锁就是很单纯，心态好，所以每次拿数据的时候都不会上锁，只是在更新数据的时候去判断该数据是否被别人修改过。大多数的关系数据库写入操作都是基于悲观锁，缺点在于如果持有锁的客户端运行的很慢，那么等待解锁的客户端被阻塞的时间就越长。Redis的事务是基于乐观锁的机制，不会在执行WATCH命令时对数据进行加锁，只是会在数据已经被其他客户端抢先修改了的情况下，通知执行WATCH命令的客户端。乐观锁适用于读多写少的情况，因为在写操作比较频繁的时候，会不断地retry，从而降低性能。 参考资料：关于悲观锁和乐观锁的区别,乐观锁和悲观锁 单例模式找错误(重要程度:★★★★☆) 错误是没有将构造函数私有化，单例还是比较简单的，把它的饿汉式和懒汉式的两种实现方式看明白了就可以了。单例模式 Spring相关关于Spring的问题主要就是围绕着Ioc和AOP，它们真是Spring的核心啊。 Spring Bean的生命周期(重要程度:★★★★★) 就不写我那么low的回答了，直接看参考资料吧。 参考资料：Spring Bean的生命周期,Top 10 Spring Interview Questions Answers J2EE Spring中用到的设计模式(重要程度:★★★★★) 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例 只知道这四个。。。。参考资料:Design Patterns Used in Java Spring Framework 讲一讲Spring IoC和AOP(重要程度:★★★★★) IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。 AOP的应用场景(重要程度:★★★★☆) 权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。 Spring中编码统一要如何做(重要程度:★★★☆☆) 配置一个拦截器就行了12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 数据库相关 Mysql索引的内部结构(重要程度:★★★★☆) B+树，三层，真实的数据存储在叶子节点 参考资料:MySQL索引原理及慢查询优化 如果一个SQL执行时间比较长怎么办(重要程度:★★★★☆) 可以利用pt-query-digest等工具分析慢查询日志，也可以用explain查看SQL的执行计划。具体可看我的另一篇博客MySQL调优 如果一张表中有上千万条数据应该怎么做分页(重要程度:★★★☆☆) 肯定不能直接limit,offset，主要就是要想办法避免在数据量大时扫描过多的记录。具体可看我的另一篇博客【译】优化MySQL中的分页 什么样的列适合加索引，如果一个列的值只有1和2，那么它适合加索引么(重要程度:★★★☆☆) 在where从句，group by从句，order by从句，on从句中出现的列 索引的字段越小越好 在建立联合索引时，离散度大的列放大联合索引的前面 只有1和2不适合建索引 算法相关 判断一个数字是否为快乐数字(重要程度:★☆☆☆☆) leetcode第202题 给定一个乱序数组和一个目标数字 找到和为这个数字的两个数字 时间复杂度是多少(重要程度:★☆☆☆☆) leetcode第一题 如何判断一个链表有没有环(重要程度:★☆☆☆☆) 用快慢指针 删除字符串中的空格 只留一个(重要程度:★☆☆☆☆) 这个比较简单。。。。 二叉树层序遍历(重要程度:★★☆☆☆) 利用队列就可以了 地铁票价是如何计算的(重要程度:★★☆☆☆) 不知道正确答案，感觉是图的最短路径算法相关的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HotSpot虚拟机之定位对象]]></title>
      <url>%2F2016%2F08%2F23%2FHotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9A%E4%BD%8D%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记。HotSpot虚拟机定位对象过程。建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作栈上的具体对象。reference类型规定了一个指向对象的引用，这个对象引用有两种实现方式–”使用句柄”和”直接指针”。 使用句柄，Java堆中划分出一块内存来作为句柄池。reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。如图： 使用直接指针，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。如图： 各自优势： 句柄访问：reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时)时只会改变句柄中的实例数据指针，而reference本身不需要修改。 直接指针：速度更快，节省了一次指针定位的时间开销。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HotSpot虚拟机之创建对象]]></title>
      <url>%2F2016%2F08%2F20%2FHotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记。HotSpot虚拟机创建对象过程。 虚拟机遇到一条new指令时，首先将去检查这个指令的参数能否在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先执行相应的类的加载过程。 接下来虚拟机将为新生对象分配内存，对象所需内存在类加载完成后便可完全确定，为对象分配内存空间的过程等同于把一块确定大小的内存从Java堆中划分出来。分配方式有”指针碰撞”和”空闲列表”两种。 虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。这一步操作保证过了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM之内存]]></title>
      <url>%2F2016%2F08%2F15%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%2F</url>
      <content type="text"><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记。Java虚拟机在执行Java程序时，会把它管理的内存划分为不同的数据区域，根据&lt;Java虚拟机规范》的规定，Java虚拟机管理的内存包括一下几个运行时数据区域： 各内存的作用： 程序计数器 程序计数器是一块比较小的内存，可以看作是当前线程所执行字节码的行号指示器。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现，在任何一个确定的时刻，一个处理器(多核处理器是一个内核)都只会执行一条线程中的指令。所以，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器。因此，这块内存是线程私有的。 如果线程正在执行的是Native方法，这个计数器的值则为空。 Java虚拟机栈 Java虚拟机栈是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息。 每个方法从调用至执行完成的过程，对应于一个栈桢在虚拟机栈中入栈到出栈的过程。 其中，局部变量表存放了编译期可知的各种基本数据类型、对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址)。 局部变量表所需要的内存在编译期间完成分配,在运行方法期间不改变局部变量表的大小。 本地方法栈 本地方法栈的作用与虚拟机栈非常相似。 他们的区别是虚拟机栈为虚拟机执行Java方法(字节码)服务，本地方法栈为虚拟机所使用到的Native方法服务。 Java堆 Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。 Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存(Java虚拟机规范:所有的对象实例以及数组都要在堆上分配)。 Java堆是垃圾收集器管理的主要区域，因此也称作”GC堆”(Garbage Collected Heap)。 Java堆可已处于物理上不连续的内存空间中，只有逻辑上连续即可。可通过(-Xmx和-Xms控制大小)。 方法区 方法区是线程共享的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但他却又一个别名–Non-Heap(非堆),以和Java堆区分开。运行时常量池是方法区的一部分，用于存放各种字面量和符号引用。 异常信息： 程序计数器：此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域 Java虚拟机栈： 如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常 如果虚拟机栈扩展时无法申请到足够的内存，抛出OutOfMemoryError异常 本地方法栈： 如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常 如果虚拟机栈扩展时无法申请到足够的内存，抛出OutOfMemoryError异常 Java堆： 如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OutOfMemoryError异常 出现Java堆内存溢出时，异常堆栈信息”java.lang.OutOfMemoryError”会跟着进一步提示”Java heap space”。 当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim懒人福音--spf13-vim]]></title>
      <url>%2F2016%2F08%2F12%2Fspf13-vim%2F</url>
      <content type="text"><![CDATA[是不是羡慕编辑器之神–vim，却又讨厌各种繁琐的配置文件？现在好了，有了spf-13，我们不用配置各种繁琐的配置文件了。废话少说，下面来说具体怎么做： 首先，确认Git 1.7+ 和 Vim 7.3+Linux, * nix, Mac OSX系统,执行以下命令安装spf13-vim： 1curl https://j.mp/spf13-vim3 -L &gt; spf13-vim.sh &amp;&amp; sh spf13-vim.sh 安装好就可以使用了。不过，一般我们需要做一些个性化的定制。 更换主题：新建一个~/.vimrc.local文件。 123colorscheme ir_black#把ir_black换成你想要换的主题#例如ir_black、molokai、peaksea 选择加载的插件：新建~/.vimrc.before.local文件： 1let g:spf13_bundle_groups=[&apos;general&apos;,&apos;writing&apos;,&apos;programming&apos;,&apos;youcompleteme&apos;,&apos;go&apos;,&apos;javascript&apos;,&apos;html&apos;] 其中“[]”里面的可以去~/.vimrc.bundles文件里面Bundles一栏去找你需要加载的组： 添加自己的组件：新建文件~/.vimrc.bundles.local，新增你需要增加的组件：1Bundle \&apos;spf13/vim-colors\&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2的世界]]></title>
      <url>%2F2016%2F08%2F09%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
      <content type="text"><![CDATA[二进制，顾名思义，就是逢二进一的数字系统。逢二进一，也就是说，只会出现0和1两种数字。这应该是最简单的数字系统了吧。你也许听别人提过，电脑那家伙笨的很，只知道0和1。哈哈，现在的绝大多数计算机的确是基于二进制运行的。说到这，你不是不很自豪呢？我比计算机可要知道的太多了，现在，就让我们走进2的世界吧。《道德经》有云：道生一，一生二，二生三，三生万物。现在看来功能强大无比的计算机，竟是建立在一串串不起眼的0、1上，让人不得不相信纷繁复杂的世界背后，一定蕴藏着一条简洁到极致的真理。这时候聪明的你肯定会犯嘀咕了，既然计算机只认识0和1，那负数怎么表示呢？是吧，没有“-”号，怎么表示负数呢？当然也是用0或1来表示了。这里说两个新概念，比特(bit)和字节(byte)。计算机中，一位数字称为1个比特，8位数字称为1个字节。为什么要引入字节的概念呢？这是因为1个比特只能表示两种不同的事物，而1个字节有8个比特，可以表示2^8(256)种不同的事物。那为什么一个字节是8个比特而不是9个、10个呢？实际上，字节这个概念最早是IBM提出来的，而IBM使用字节的一个原因则是它们易于以BCD这种格式保存(参见《编码的奥秘》)。既然采用一个字节进行运算，那我们完全可以约定，这8个比特的其中一位，用来标识正负。而其中的一种约定就是，最高位的比特用来标识正负号，0代表正数，1代表负数。好了，现在能表示正负数了。既然数都可以表示了，那就该做运算了。现在，我们实现一个8位加法机，实现7位的加减法。1个字节能表示的数的范围是-128~127。 一. 先来做加法运算吧： 一：0000 00010000 0011———·0000 0100这个很简单，一瞅就能2看出来结果是“0000 0100”。 二0100 00000100 0000———·1000 0000咦，不对呀。两个正数相加，结果怎么是个负数？ 三1010 00011100 0010———·0110 0011这下两个负数相加，结果怎么是正数了？这就是溢出的问题了。两个正数相加得到负数，称为正溢出。两个负数相加得到正数，称为负溢出。 加法还简单，减法怎么做呢？减法就是加上一个负数。前面说了，负数就是最高位为1的数。实际上，负数在计算机内部是采用2的补码形式存储的。2的补码是什么呢？它的转换步骤如下：比如2的2进制是 0000 0010。现在看如何存储-2 逐位取反。0000 0010 –&gt; 1111 1101 加11111 11010000 0001———·1111 1110 所以，-2在计算机中存储的是1111 1110，而不是1000 0010。为什么采用2的补码呢？先看我们最习惯的10进制看吧，24 - 16 = 8，这是两位数的减法，两位数中，最大的数是99，那么，用99减去被减数肯定就不需要借位了是吧，于是24 - 16 = 8 –&gt; 24+(99-16) + 1 - 100 = 8。 接下来我们看下 4 - 2：4是0000 0100，-2是1111 11100000 01001111 1110———·0000 0010这里生了什么呢？0000 0100 + (1111 1111 - 0000 0010) + 1 - 1 0000 0000。是不是跟10进制里面的一样？取反就是拿8位数里最大的那个数–&gt;1111 1111减去当前数。最后要减去1 0000 0000，因为我们只有8位，这里溢出的1就自动舍弃了。 那如果是2 - 4呢？2是0000 0010，-4呢？0000 0100–&gt;1111 1011–&gt;1111 11000000 00101111 1100———·1111 11101111 1110是多少呢？我们以前说过是-2。结果也是对的。 -2-2呢？1111 11101111 1110———·1111 1100结果也是对的。都是一个道理。 好了，现在我们有1个字节，可以表示256种不同的事物，我们可以给符号以及字母编码来表示文本，这就是ASCII码了。最后，提一下16进制。为什么提16进制呢？因为2^4=16。4个比特的数字对应一个16进制的数字，一个字节就可以用两个16进制数字来表示，这样读起来比8个01数字串简单多了。下面是二进制、十进制、十六进制对照表： 二进制 十进制 十六进制 二进制 十进制 十六进制 0000 0 0 1000 8 8 0001 1 1 1001 9 9 0010 2 2 1010 10 A 0011 3 3 1011 11 B 0100 4 4 1100 12 C 0101 5 5 1101 13 D 0110 6 6 1110 14 E 0111 7 7 1111 15 F]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[采矿--编码与继电器]]></title>
      <url>%2F2016%2F08%2F08%2F%E9%87%87%E7%9F%BF--%E7%BC%96%E7%A0%81%E4%B8%8E%E7%BB%A7%E7%94%B5%E5%99%A8%2F</url>
      <content type="text"><![CDATA[屠龙的第一步当然是给自己锻造一把绝世好剑，而铸剑的基础则是采矿。那就从采矿开始吧！–题记追本溯源，就要从编码开始说起了。编码，听起来很高深，其实并非如此。编：编造，码：符号。顾名思义，就是给事物编造一个个的符号用来交流喽。学过外语的都知道，对于“狗”这样一个具体的动物，不同的语言有不同的称呼：“狗”、“dog”、“chien”、“собака”……这些都可以称作编码。又例如，马上又要物理考试了，你跟你舍友约好用计算器传递选择题答案，”A”、”B”、”C”、”D”分别对应”1”、”2”、”3”、”4”。然后……愉快的60分飘过。这也是一种编码，只要你和你的小伙伴能理解就成。通信，也是为了交流。在没有电报以前，想要交流，也就是通信，怎么办呢？吼呗！距离太远，吼的听不到怎么办？跑过去吼呗！要是你没空，就雇个人跑过去吼呗，就是那么简单。直到电报的横空出世！人们发现可以用电线代替人跑腿了。不过那个时候电话还没有发明出来，你要是对着电话扯开嗓子吼，吼破喉咙它也不懂你要干嘛。那电报是怎么做的呢？这涉及到电磁现象了，不过既然做了程序猿，高中物理肯定还是懂的嘛，还不至于全还给老师吧。就是这样，一个按键和一个发声装置就组成了最简单的电报系统。当电报机的键按下时,发生器的电磁铁将可动棒拖下发出“滴”的声音;当键放开时,棒弹回初始位置,发出“嗒”的声音。快速的“嘀嗒”为点,慢速的则为划。物理装置就这样了，那我们怎么将语言翻译成点划，然后再由点划翻译回去呢？这时候，就是编码大展伸手的时候了，摩尔斯电码粉墨登场：好了，对着这张表。就可以愉快的收发电报了。但是，还有个最大的问题，就是长距离导线的电阻问题。导线越长，电阻越大，电压不变的情况下电流也就越小。小到一定程度，电报系统就不能用了。一个明显的解决办法是使用转发(中继)系统,也称继电器系统。如图继电器中，输入电流激发电磁铁,电磁铁吸引一根有弹性的金属条作为开关从而输出电流。继电器是一种卓越的设备。它是一个开关,但并不是由人工而是借助于电流进行开关操作的。如果你有耐心，利用它可以装配出一台计算机中的大部分部件。嗯！的确如此，有时间的话，我决定在“我的世界”里实现一个8位CPU的计算机。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新入坑的程序猿们，一起去屠龙吧！]]></title>
      <url>%2F2016%2F08%2F07%2F%E6%96%B0%E5%85%A5%E5%9D%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%BB%AC%EF%BC%8C%E4%B8%80%E8%B5%B7%E5%8E%BB%E5%B1%A0%E9%BE%99%E5%90%A7%2F</url>
      <content type="text"><![CDATA[我做的是JAVA编程，从大三开始决定入编程的坑开始，一瘸一拐的在编程世界跋涉也快一年半了。话说，自从半年前开始JAVA WEB编程，特别是一个月前毕业进入公司到现在，经常会在敲代码的时候，好似一个没诵读过《圣经》的传教士到处散播福音一般，心里一阵阵的发虚。为什么呢，因为我本科学的并不是计算机相关专业，没有用心的系统学过计算机底层的基础知识，底层知识不熟练，就会在编程的时候有种被架空的感觉，那种感觉，就好像刚摇摇晃晃学会骑自行车，就要骑上摩托飞奔。这种不能随心所欲控制的感觉，别提多难受了。既然如此，那就恶补基础呗。毕竟，磨砺好手中的利剑，才能开心屠龙嘛！先来看一个知乎问题,里面萧井陌大神的推荐：1234567列举几个我认为比较重要的根基并附入门书编程语言，《程序设计语言-实践之路》《concepts of programming languages》计算机通用知识，《csapp》算法、数据结构，《算法导论》程序设计、结构，没有书推荐软件工程，这个词大家理解不同，我以为，《人月》《代码大全》《the pragmatic programmer》《sicp》、讲测试讲重构的都是软件工程，其实上面设计模式也是软件工程，哈哈这些书，初时读来感觉全无作用，而且要读多次才能体会其中意味，所以叫它根基也是十分合适，你根基越深才能爬得越高嘛。 有大神指导，路就好走多了嘛，那我就从计算机系统原理开撸吧：准备看的书：《编码的奥秘》、《深入理解计算机系统》视频(准备看网易云课堂的几门课)：计算机组成原理之机器、计算机组成原理之数字、计算机组成原理之CPU、计算机系统结构 (一) 基本概念及指令集、计算机系统结构 (二) 计算机主要系统构成、计算机系统结构 (三) CPU及其结构分析接下来就是：数据结构、算法、操作系统、计算机网络、数据库、编译原理。就这样吧，感觉又挖了好大一个坑……恩！计划再好，不执行也是白搭。借用《海贼王》中路飞的一句话：“我是要成为海贼王的男人!”。来吧，一起去计算机的世界屠龙吧……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven项目创建缓慢解决方法]]></title>
      <url>%2F2016%2F07%2F20%2Fmaven%E9%A1%B9%E7%9B%AE%E7%BC%93%E6%85%A2%2F</url>
      <content type="text"><![CDATA[解决国内网络环境下，根据archetype创建Maven项目异常缓慢的问题。 原因根据archetype创建Maven项目，执行mvn archetype:generate命令时，需要指定一个archetype-catalog.xml文件。可通过该命令的-DarchetypeCatalog参数指定maven-archetype-plugin读取archetype-catalog.xml文件的位置。此参数的可选值: internal –&gt; maven-archetype-plugin内置 local –&gt; 本地，位于~/.m2/archetype-catalog.xml remote –&gt; 指向Maven中央仓库的Catalog: http://repo1.maven.org/maven2/archetype-catalog.xml file:// http://由于该参数默认为remote，从中央仓库下载archetype-catalog.xml文件。而国内访问中央仓库速度非常慢，所以导致创建过程异常缓慢。 命令行中解决方案创建时命令行中指定-DarchetypeCatalog=internal1mvn archetype:generate -DarchetypeCatalog=internal IDEA解决方案临时创建Maven项目时指定该参数 一劳永逸 点击项目默认设置 进入Maven – Runner设置窗口，指定VM Options:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你要避免的软件开发模式]]></title>
      <url>%2F2016%2F07%2F20%2F%E4%BD%A0%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[转自:程序人生做软件开发十数年，见识了形形色色的开发者，和各种各样的奇葩软件开发模式。本文跟你侃侃这些软件开发模式及其特点。 IDD（IDE-Driven Development） 大巧在所不为，大智在所不虑。 – 荀子 天论 IDD，也就是 IDE 驱动开发，几乎是初学者步入软件开发殿堂的必经之路。IDE 为开发者屏蔽了很多细节，并且几乎不用配置（相对于 vim / emacs / sublime）就可以使用代码自动补全，代码跳转，搜索，以及签入签出等软件开发中将会使用到的几乎所有工作。 然而，它带来的危害也是显而易见的，陷入 IDD 开发模式太深，开发者离开了 IDE 便像无头苍蝇一样，几乎不知道怎么读代码，甚至不太会写代码，不懂怎么编译，不会自动化完成常见的任务（比如 android 项目从编译到打包到 apk 分析），甚至连基本的 git 操作都无法完成。而这些被屏蔽的细节都是软件工程师的基本功，就像弹钢琴的基本指法一样，是必须修炼好的。试想一下，如果你只会在 IDE 里读代码，离了 IDE 的跳转就不知道怎么追溯代码的脉络，那么有的代码你只能通过 browser 阅读怎么办？不读了？如果你只会在 IDE 里写代码，有天你只能 ssh 到服务器上写代码（表笑，有很多公司这么做，也有很多场合需要这么做），你难道就不写了？ 此外，IDD 开发者如果不能及时从对 IDE 的极度依赖中抽身而出，很容易转化成下一类开发者。 适用人群：初学者 舒适指数：五星 危害指数：四星 解决之道：学会任意一个 shell 下的编辑器 DDD（Debugger-Driven Development） 合格的程序员的代码是一行行写出来的；不合格的程序员的代码是一行行调出来的。 – 某子 程序员的自我修养 DDD，面向调试器开发，是 IDD 依赖到一定程度的必然反应。这种开发模式的典型表现为：写出来的代码不知道对不对，从头到尾设置无数个断点，然后进入到调试模式，一个断点一个断点跟踪。发现一个问题，解决一个问题（也许引入一个新的问题），直到所有断点走数遍，所有遇到的问题被消灭，抹一抹头上的汗，心里骂上一句：妈的，这段代码老子（娘）终于调通了！ DDD 是非常浪费程序员生命的一种开发方式，它让我们把有限的时间精力都浪费在无穷地瞎忙活之中。因为断点过于唾手可得，程序员会变得懒于思考，懒于设计，甚至写完了代码都懒得自己看一眼 —— 大手一挥，无数个红色的断点就设置好了，反正出了问题我调就行了呗。 其实很多 concurrent 的问题，靠调试器是无法复现和解决的，更要命的是，DDD 还容易使程序员陷入 tunnel vision —— 我们太过于关注眼前的那一点点状态，而忽视了全局。 适用人群：入门者 舒适指数：四星 危害指数：五星 解决之道：多花时间思考和设计，使用 TDD（Test Driven Development），如果非要追踪状态，合理地使用日志（log）而非断点 PDD（Print-Driven Development） 王好战，请以战喻。填然鼓之，兵刃既接，弃甲曳兵而走。或百步而后止，或五十步而后止。以五十步笑百步，则何如？ – 孟子 梁惠王上 看到 DDD，做嵌入式开发的 C 程序员笑了，我们没有那臭毛病 —— 大部分嵌入式开发的场景，要么设断点太麻烦（需要 remote debugger），要么无法设置（比如说很多内核态的代码），所以我们的代码都是写出来的。不过，这部分程序员大多自发聚集起来，立起一个山头：PDD，也就是面向打印开发。其开发逻辑有如下面的代码：12345678// ...some awesome logic...printf(&quot;haha,hit 1&quot;);// ...some more logic...printf(&quot;!!!!! hit 2&quot;);if (awesome_check(awesome_state))&#123; printf(&quot;##### condition captured&quot;)&#125; PDD 和 DDD 相比，是旗鼓相当，半斤八两。PDD 开发者加入的代码，和 DDD 开发者设置的断点一样，头疼医头，脚疼医脚，哪里的状态不对了，或者和预想的流程不一致，先不考虑设计上是否有缺陷，为什么会出现这样的结果，而是不管三七二十一，加个打印（设个断点）看看状态是什么。如果没抓对位置，那么就继续细化，直到很被动地找到原因为止。 适用人群：入门者 舒适指数：三星 危害指数：四星 解决之道：多花时间思考和设计，合理地使用深思熟虑过的日志（log）而非用完即扔的打印信息 BDD（Bug-Driven Development） 以管窥天，以蠡测海，以莛撞钟，岂能通其条贯，考其文理，发其音声哉。 – 东方朔 答客难 看到 BDD，也就是问题单驱动开发，相信大家都相视一笑。本来这里我想用 TDD（Ticket-Driven Development），更接近我的原意，为了不和 Test-Driven Development 混淆，故而只好改成 BDD。这可能是我们最熟悉的开发模式了 —— 在一个业务稳定的软件公司（甭管规模大小），勉力维护现有的代码，小心地添加新功能是多数程序员的主要职责。在这些公司里，与其说我们是工程师，不如说我们是补锅匠。看不懂代码？没关系，只要你会读日志（出错信息）；解决不了问题？不打紧，能找到 workaround 把问题绕过去也可以，更有甚者，遇到神问题，看不懂，想不明，解不了，还没有 workaround，大笔一挥：not reproducible，就把问题关了，几个月半年后，说不定自己已经去补别的锅了。 BDD 开发者修的都是防御之道，一手华丽的 defensive coding skill，堪比仙女座的星云锁链，把系统的每寸肌肤防得滴水不漏。如果你看到一段代码，函数 A(a, b, c) 调了函数 B(c)，即便参数 c 在 A 的入口进行了详细的检查，在 B 中也还会再度详细检查（哪怕 B 只有 A 调用），那么这代码一定是 BDD 开发者开发的。 BDD 开发者的视野往往很窄，所学所用皆局限于已有的系统，由于系统并非自己所写，阅读代码又是就着问题去追根溯源，所以对系统的理解会比较狭窄。这并非程序员能力不足，相反，能做 BDD 开发往往都是很有经验的程序员。然而，他们被公司的需求所局限，整日被 ticket 追逐，疲于奔命，在工作中无法有效提升，渐渐迷失在一个又一个犯罪现场，眼界变得越来越狭窄。 适用人群：业务稳定的公司里的『高级程序员』 舒适指数：二星 危害指数：四星 解决之道：自己主导一个项目的开发，或者，跳槽 RDD（Rat-race-game-Driven Development） From day to day, we programmers dreamed of being an expert inside the team/company; however, when that day really comes we trapped ourselves. – 程序君 Programmer’s dilemma These walls are kind of funny. First you hate ’em, then you get used to ’em. Enough time passes, gets so you depend on them. That’s institutionalized. They send you here for life, that’s exactly what they take. The part that counts, anyways. – Red, The Shawshank Redemption RDD，老鼠赛跑驱动的开发，是指那些整个职业生涯都在原地打转的开发模式。Rat race game 是『富爸爸穷爸爸』中的经典例子 —— 老鼠在环形的笼子里拼命地奔跑。 每个程序员都在努力地成为他所在领域的专家。成为专家的代价是巨大的，我们需要付出经年累月的努力，才能爬到峰顶，带上「专家」的帽子。然而，成为「专家」往往意味着一条路走到黑 —— 一来之前的累计的惯性实在太大，掉头的机会成本太大；二来你的雇主因此而付你更高薪水，所以你只能在这个方向上不断前进。 我们知道，软件是个工程的活儿，并非科学。科学的路上走得越远，打出的装备越稀缺；而在同一家公司或者同一个行业里搞软件的，走得越远，就有越多的路是重复再走。你可能精于 chip verification，于是从第一份工作到第 n 份工作，干的都是 verification 的活，直到有天惊闻这个职位被砍；你可能是web 桌面化的好手，extjs 玩得风生水起，公司依赖你的技能开发产品，直到有一天，这个产品没人用了，你到市场上一看，你的 extjs 九段的功力，比不上玩 react 才刚刚两段的水平受欢迎。 RDD 就像 Red 口中所述的那些高墙。当你沉浸在 RDD 中不能自拔时，悄悄地，你曾经引以为豪赖以生存的能力成了你生存下去的最大障碍。 适用人群：大公司里的『专家』 舒适指数：五星 危害指数：四星 解决之道：在公司里换不同的团队，或者，跳槽去更有挑战的公司 以上写了这么多，总有一款符合你。你有没有找到自己心仪的开发模式？如果没有，恭喜你；如果找到了，别慌，有则改之，无则加勉即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈编程思想]]></title>
      <url>%2F2016%2F06%2F20%2F%E8%B0%88%E8%B0%88%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
      <content type="text"><![CDATA[转自:程序人生这段时间又攒了很多答应了，但还未动手的文章。大概一两周前，有个读者留言：「程序君，能发篇文章有关编程思想的吗？我是编程初学者，对编程思想没啥概念，求传授点经验！」 今天就讲讲编程思想。编程思想是个宏大的主题，我不敢保证我能在短短的一两个小时里讲得全面而深入。推荐给大家一本好书『冒号课堂』，是国内为数不多的讲编程思想的经典之作。无奈这本书已经不再出版，只能在图书馆里一睹芳容（我几年前在国图和它偶遇）。 各种软件思想虽然层出不穷，但其本质是降低系统复杂度，减少重复，减少代码的变更。掌握了这个大方向，理解各种编程思想就容易多了。 下文建议在手机上横过来看。所涉及的代码大多是剪短清晰的python代码。 以程序君不太准确的分类，编程思想可以分为以下几个大类： 原则（Principles） 范式（Paradigms） 方法论（Methodologies） 模式（Patterns） 我们一点点展开，说到哪算哪。 原则（Principles）我认识（或者说现在想得起来的）的原则主要有以下几种： DRY (Don’t Repeat Yourself) OCP (Open Close Principle) SoC (Separation of Concerns) IoC (Inversion of Concerns) CoC (Configuration over Convention) Indirection (Layering) “Don’t repeat yourself”很好理解。当你第二次写同样结构，变化不大的代码时，脑袋里就要闪现一个大大的问号：我是不是在repeat myself？如果是，就要重构，或封装，或抽象，或函数化，总之一个目的，消除重复。以笔者的经验，DRY原则看似基本，实则很多大型软件公司都未能做好，copy &amp; paste到处可见。我们写代码，从一开始就要把握好这个原则，否则在「破窗理论」的指引下，代码的质量会快速划向万劫不复的深渊。 OCP原则是说「软件要对扩展开放，对修改封闭」。比如你写一个message dispatching的代码，如果你只用一个主函数去处理所有消息，那么，每加一个message type，你就需要修改这个函数使之能处理新的消息。正确的，使用了OCP原则的代码是每个消息都有自己的callback，主函数仅仅根据消息的类型找到对应callback，然后执行。这样，新加的任何消息都无需改动主处理函数。这就是「对扩展开放，对修改封闭」的一个最浅显的例子。软件开发中的很多手段，如继承，如Observer pattern（观察者模式）目的就是实现OCP原则。 以上两个原则是最基础最基础的原则，之后的原则都是在此基础上衍生出来的。 SoC听起来高大上，其实就是解耦，将复杂系统分治成不同的子系统，尽可能将变化控制在子系统中。如果你十多年前做过互联网，就知道那时的html混杂着语义和样式，牵一发而动全身；现在的网站html/css基本分离，上帝的归上帝，撒旦的归撒旦，各司其职。这就是SoC。另一个SoC的经典应用场景就是MVC design pattern —— 整个系统的逻辑被分成 Model，View，Controller三层，（理想状态下）其中一层的改动不会影响到另一层。 IoC原则的思想是”Don’t call me, I’ll call you”。这一原则促使软件产业从lib时代发展到framework时代。想想libc，里面有各种各样的函数供你驱使，整个控制权在你；再看看django这样的framework，你并没有整个系统的控制权，你只能被动地按照规范写出一个个函数或类，在必要的时候由framework调用。使用IoC原则的好处是高级的细节和逻辑被隐藏，开发者只需要关注business logic。比如说使用ChicagoBoss（erlang的一个 web framework）来写web app，你写的代码基本上是顺序的，并发（concurrency）无关的，但整个系统的执行是异步的，大量并发的。 CoC原则出自Rails（或者至少Rails将其发扬光大），它的意思是：为了简单起见，我们写代码按照一定的约定写（代码放在什么目录，用什么文件名，用什么类名等），这样省去了很多不必要的麻烦（但也不失flexibility，因为约定可以通过配置修改），比如说在ember里component的定义在controller里要CamelCase，在template里要用”-“。在django里，只要你在”app/management/commands”里写一个文件，继承BaseCommand类，就可以通过”./manage.py xxx”运行你的命令。 Indirection/Layering原则也是为了解耦，就是把系统分成不同的层次，严格规定层次间的调用关系。layering最著名的例子是ISO/OSI七层模型；indirection最著名的例子是hypervisor。软件领域最著名的一句话是：”All problems in computer science can be solved by another level of indirection.” 范式（Paradigms）讲完了原则，讲讲范式。我能想到的两个范式是： GP: Generic Programming MP: Meta Programming 很多人一看到GP（泛型编程）就想到C++中的template，想到STL。此GP非彼GP也。这里的泛型编程是从抽象度的角度来看问题 —— 即对算法和算法操作的数据进行解耦。举个例子，我们要计算一个字符串表达式的值：”3 20 7 * 48”。这用python不难实现：123456789s = &quot;3* 20 * 7 * 48&quot;def calc(s, sep): r = 1 for t in s.split(sep): if t != &quot;&quot;: r *= int(t) return rcalc(s, &quot;*&quot;)20160 如果s是个加法的表达式呢？更好的方式是：123456s = &quot;3* 20 * 7 * 48&quot;def calc(s, sep): op = &#123;&apos;*&apos;: operator.mul, &apos;+&apos;: operator.add, ...&#125; return reduce(op[sep], map(int, filter(bool, s.split(sep))))calc(s, &quot;*&quot;)20160 在这个实现里，算法被抽象出来与数据无关。 再比如下面这个函数，对给定的list里面的任何一个元素执行一个测试，如果测试通过，则执行action，返回执行结果的list。12345def process(l, test, action): def f(x): return action(x) if test(x) else None return filter(None, map(f, l)) 这个函数可以应用于很多场景，比如说：「从公司的directory里找到所有女性工程师，将她们的工资统一涨10%」，「给我自己的微博里所有在北京的粉丝发一条消息」这样两个看似完全无关的场景。最重要的是，process函数一旦写完，就基本不需要任何改动而应用于这两个（甚至更多的）场景。从这里也可以看出，GP的一个作用就是实现OCP原则。 以上所述原则和范式都与具体的语言无关，是可以放之四海而皆准的基本思想。但Metaprogramming不然。它跟语言的能力很有关系。 狭义的metaprogramming指代码能够将代码当作数据操作，广义讲就是在接近语言级的层面写的让代码更具动态性的代码。先举一个后者的例子：123456789class dotdict(dict): def __getattr__(self, attr): return self.get(attr, None) __setattr__ = dict.__setitem__ __delattr__ = dict.__delitem__dd = dotdict(&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;)dd.a1 在python里，访问字典需要使用”[]”，但我们可以使用语言自身的魔法函数（magic functions）将”.”操作与”[]”映射起来，达到使用”.”来访问字典的效果（就像javascript一样）。字典里的key是无限延伸的，你无法对每个key生成一个方法，但求助于语言层的能力，就可以做到这一点。同理，如果让你写一个微博的api的sdk，你不必为每一个api写一个方法，一个getattr就可以将所有api抽象统一。这就是广义的metaprogramming，让代码更具动态性。 狭义的metaprogramming用django的ORM来说明最好:123456789class TagItem(models.Model): class Meta: app_label = &apos;cayman&apos; verbose_name = verbose_name_plural = _(&apos;关联的实体&apos;) tag = models.ForeignKey(&apos;Tag&apos;, verbose_name=_(&apos;分类&apos;), null=True) content_type = models.ForeignKey(ContentType, default=None, blank=True, null=True) object_id = models.PositiveIntegerField(blank=True, null=True) item = generic.GenericForeignKey(&apos;content_type&apos;, &apos;object_id&apos;) 复杂的Object relational mapping以这样一种declarative的方式解决了（你甚至可以将它看成一种DSL，Domain Specific Language），如果没有metaprogramming的支持，想想你如何以如此优雅地方式实现这种mapping？ 当然，就metaprogramming的能力而言，把代码完全看做数据（列表展开与求值）的lisp族语言更甚一筹。这是我为何说metaprogramming的能力和语言相关。我没有真正写过lisp代码（clojure仅仅写了几个hello world级的函数），但据说lisp程序员写一个系统时，会先写一个针对该系统的DSL，然后再用这个DSL写代码。听说而已，我没有亲见。 方法论主流的方法论不外乎三种： OOP（Object Oriented Programming） AOP（Aspect Oriented Programming） FP（Functional Programming） OOP就不在这里讨论了，这是一个已经被说烂了的名词。注意OOP是一种思想，和语言是否支持无关。不支持OOP的C一样可以写出OOP的代码（请参考linux kernel的device），支持OOP的python也有很多人写出来过程化的代码。 AOP是指把辅助的关注点从主关注点中分离，有点SoC的意味。在django里，我们会写很多view，这些view有各自不同的逻辑，但它们都需要考虑一件事：用户登录（获得授权）后才能访问这些view。这个关注点和每个view的主关注点是无关的，我们不该为此分心，于是（为了简便起见，以下我使用了django里已经逐渐废弃的function based view）：12345@login_requireddef user_view(request, *args, **kwargs): user = request.user profile = user.get_profile() ... 这里，login_required这个decorator就是AOP思想的一个很好的例子。 很多时候AOP是OOP的一个用于解耦的补充。 OOP发展了这么多年，慢慢地触及了它固有的天花板 —— 为了容纳更多的业务，不断抽象，不断分层，最终超过了人脑所能理解的极限。尽管有些design patterns努力帮我们把纵向的金字塔结构往横向发展（如composite pattern，decorator pattern等），但依然改变不了OOP树状的，金字塔型的结构。 如果说OOP帮助你构建层级式的系统，那么FP（函数式编程）则反其道而行之：在FP的世界里，一切是平的。你要构建的是一个个尽可能抽象的函数，然后将其组织起来形成系统。 比如说要你做一个系统，实现对list的合并，如果你是个OOP的好手，你可能这么做：12345678910111213class Base(object): def __init__(self, l): self.l = l def reduce(self): raise NotImplementedclass Adder(Base): def reduce(self): n = 0 for item in self.l: n += item return nclass Multipler(Base): ... 但对于FP，你大概会这么做：123456def list_op(f): def apply(l): return reduce(f, l) return applyadder = list_op(operator.add)multipler = list_op(operator.mul) 函数式编程通过变化，组合各种基本的函数能够实现复杂的功能，且实现地非常优雅。如我们前面举的例子： （haskell）：1boomBangs xs = [if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;- xs, odd x] 即使你没学过haskell，你也能立即领会这段代码的意思。 函数式编程有部分或全部如下特点（取决于语言的能力）： Immutable data First-class functions Higher-order functions Pure functions (no side effects) Recursion &amp; tail recursion Iterators, sequences Lazy evaluation curry Pattern matching Monads…. 其中不少思想和目前的多核多线程场景下进行高并发开发的思想契合。所以你会看到erlang，haskell这样的语言越来越受到重视，并被用到各种生产环境。 模式（Patterns）模式是在系统开发的过程中反复被用到的一些解决具体问题的思想。设计模式（Design patterns）首先由GoF（Gang of Four）总结，然后在Java中发扬光大。其实随着语言的进化，不少模式已经被整合在语言当中，比如iterator，有些已经固化到你写代码的方式当中，比如bridge，decorator，有些在framework里在不断使用而你不知道，如经典的MVC，如django的middleware（chain of responsibility），command（command pattern）等等。时间关系，就不一一道来。 最后，写代码是为了解决问题，而不是秀肌肉。脑袋里有了大原则，那么范式，方法论，模式这些实现手段哪个顺手，哪个更好地能解决问题就用哪个。代码写出来首先要为功能服务，其次为可读性服务，不是为某个思想服务的，也就是说，不要为了OO而OO，不要为了MP而MP，那样没有意义。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC基础]]></title>
      <url>%2F2016%2F05%2F21%2FJDBC%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[掌握数据库开发是java工程师的基本要求，而JDBC是数据库开发的基础，通过JDBC可以实现Java程序对后端数据库的访问。虽然现在大多使用MyBatis，但明白JDBC的工作流程，对初学者来说还是非常必要的，学会之后能够更快速的上手MyBatis。下面我就介绍一下JDBC的基础知识。注意：学习JDBC需要有Java基础以及数据库基础。 总的来说，使用JDBC的流程大概分为：12345装载驱动程序建立与数据库的连接执行SQL语句获取执行结果清理资源 接下来逐步详细说明： 装载驱动程序说到装载驱动程序，就不得不说JDBC中的Driver类、DriverManager类。Driver类是一个接口，定义了各个驱动程序都必须实现的功能，是驱动程序的抽象。而DriverManager类是Driver类的管理类。 想要装载驱动程序，我们就要用Class.forName(DriverName)向DriverManager注册驱动程序。DriverName就是响应数据库驱动的名称。推荐用maven管理驱动程序，免去到官网下载的麻烦。例如加载mysql驱动：1Class.forName（“com.mysql.jdbc.Driver&quot;); 建立与数据库的连接想要建立与数据库的连接，就要通过DriverManager类中的getConnection()方法调用驱动程序。 getConnection()方法返回的是一个JDBC Connection对象。Connection对象其实代表的是Java应用程序对后端数据库的一条物理链接。基于这条链接，我们可以执行SQL语句。Connection对象常用的方法就是createStatement()方法，这个方法用来创建Statement对象。 调用getConnection()方法需要传入三个参数，分别是URL、UserName、PassWord。注意：使用getConnection()可能会抛出异常，所以这里要捕获异常。 例如：1Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/数据库名&quot;,&quot;root&quot;,&quot;root&quot;); URL为相应数据库的地址，包含协议、子协议、子名称三部分，其中自名称又包括主机、端口、数据库名等。例如：“jdbc:mysql://127.0.0.1:3306/数据库名”。UserName则是你部署相应数据库时设置的用户名，一般都是“root”。PassWord就是你部署相应数据库时设置的密码。 执行SQL语句要执行SQL语句，首先要用Connection连接创建Statement对象。Statement对象，说到底就是一个SQL容器，这个容器可以承载一些SQL语句。 然后调用executeQuery()方法或execute()方法执行SQL语句。其中，executeQuery()方法可执行查询操作，execute()方法更新、添加、删除等操作。执行后返回int值或ResultSet对象。ResultSet是数据库结果集的数据表。 例如：12Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery(&quot;select name from user&quot;); 获取执行结果若返回的是ResultSet对象，则要用循环取出ResultSet对象中的数据。因为ResultSet对象具有指向其当前数据行的指针。最初，指针被置于第一行之前。next方法可以将指针移动到下一行；使用该方法是会true或false(若没有下一行则返回false)，所以可以在while循环中使用它迭代结果集。(ResultSet对象的其他常用方法自行搜索其他资料，这里就不赘述了。) 例如：123while(rs.next())&#123; System.out.println(rs.getString(&quot;name&quot;));&#125; 清理资源在finally{ }方法中清理资源。例如：123456789101112131415finally&#123; try&#123; if(rs != null) rs.close(); if(stmt != null) stmt.close(); if(conn != null) conn.close(); &#125; catch(SQLException)&#123; //ignore &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet原理 三：Servlet体系结构以及工作原理]]></title>
      <url>%2F2016%2F05%2F08%2FServlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%863%2F</url>
      <content type="text"><![CDATA[注：在网上看到一篇文章–《Servlet工作原理》,整理并做了一些笔记 1. Servlet 体系结构我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。 我们应该很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？ 仔细查看 ServletConfig 接口中声明的方法就会发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能会在 Servlet 运行时被用到。 那么 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。 ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类，所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。 同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。 通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。 Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示： 2. Servlet 如何工作我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。 当用户从浏览器向服务器发起一个请求，通常会包含如下信息：http://hostname: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？ Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 : 12345678910111213public void init() &#123; findDefaultHost(); Engine engine = (Engine) connector.getService().getContainer(); engine.addContainerListener(this); Container[] conHosts = engine.findChildren(); for (Container conHost : conHosts) &#123; Host host = (Host) conHost; if (!LifecycleState.NEW.equals(host.getState())) &#123; host.addLifecycleListener(this); registerHost(host); &#125; &#125; &#125; 这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。 接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。 Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。 当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet原理 二：Web应用与创建Servlet实例]]></title>
      <url>%2F2016%2F05%2F08%2FServlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862%2F</url>
      <content type="text"><![CDATA[注：在网上看到一篇文章–《Servlet工作原理》,整理并做了一些笔记 1. Web 应用的初始化工作Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。Tomcat 首先会找 globalWebXml ，这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。然后会找 hostWebXml ，这个文件可能会在 System.getProperty(“catalina.base”)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。解析 Servlet 时会将 Servlet 包装成 Context 容器中的 StandardWrapper，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象？这是因为StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。 2. 创建 Servlet 实例前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。 创建 Servlet 对象 如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。 创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。 创建 Servlet 对象的相关类结构图如下： 初始化 Servlet 初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。 如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。这样 Servlet 对象就初始化完成了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet原理 一：Servlet容器]]></title>
      <url>%2F2016%2F05%2F07%2FServlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%861%2F</url>
      <content type="text"><![CDATA[注：在网上看到一篇文章–《Servlet工作原理》,整理并做了一些笔记 了解 Servlet 容器首先，要从servlet 容器开始。servlet容器，故名思议，就是装载和管理Servlet的服务端程序。借用一个前辈的解释：Servlet与Servlet容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。下图是Tomcat容器模型：可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程， Context 容器如何运行将直接影响 Servlet 的工作方式。 Servlet 容器启动过程Tomcat7 支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，还可以通过这个对象来增加和修改 Tomcat 的配置参数。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。 12345678910# 创建一个 Tomcat 实例Tomcat tomcat = getTomcatInstance();File appDir = new File(getBuildDirectory(), &quot;webapps/examples&quot;);# 新增一个 Web 应用tomcat.addWebapp(null, &quot;/examples&quot;, appDir.getAbsolutePath());# 启动 Tomcattomcat.start();# 调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。ByteChunk res = getUrl(&quot;http://localhost:&quot; + getPort() + &quot;/examples/servlets/servlet/HelloWorldExample&quot;); assertTrue(res.toString().indexOf(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;) &gt; 0); 一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器(StandardContext是Context的标准实现)，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作。最后将这个 Context 容器加到父容器 Host 中。 接下去将会调用 Tomcat 的 start 方法启动 Tomcat，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener）。 当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用 addWebapp 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。 ContextConfig 的 init 方法将会主要完成以下工作：12345创建用于解析 xml 配置文件的 contextDigester 对象读取默认 context.xml 配置文件，如果存在解析它读取默认 Host 配置文件，如果存在解析它读取默认 Context 自身的配置文件，如果存在解析它设置 Context 的 DocBase ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：12345678创建读取资源文件的对象创建 ClassLoader 对象设置应用的工作目录启动相关的辅助类如：logger、realm、resources 等修改启动状态，通知感兴趣的观察者（Web 应用的配置）子容器的初始化获取 ServletContext 并设置必要的参数初始化“load on startup”的 Servlet]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shell的唯一选择--zsh]]></title>
      <url>%2F2016%2F05%2F06%2Fzshshell%2F</url>
      <content type="text"><![CDATA[有些同学可能对Shell不太熟悉。借用池建强的一个解释:简单的说，Shell是Linux/Unix的一个外壳。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。Linux/Unix提供了很多种Shell，输入以下的命令查看有哪些Shell:1cat /etc/shells Linux的默认 Shell 都是 bash，既然如此，那我今天为什么要说zsh呢？因为zsh搭配上”oh my zsh”真的好用到爆啊！”oh my zsh”的Github网址点我点我！。那么如何安装、配置和使用 zsh(我用的是Ubuntu) 安装zsh1sudo apt-get install zsh 安装oh my zsh1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 配置zshzsh的配置在当前用户目录的.zshrc里。oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。 换主题打开～/.zshrc。oh my zsh提供了数十种主题，相关文件在~/.oh-my-zsh/themes下，你可以随意选择，我采用的是ys主题。在～/.zshrc文件中找到1ZSH_THEME="ys" 更改成你想要的主题就好了。 插件oh my zsh里提供了非常多的插件，相关文件在~/.oh-my-zsh/plugins文件夹下，默认有100多种，我们可以根据自己的实际需要加载特定的插件。插件也是在～/.zshrc里配置，找到plugins关键字，你就可以加载自己的插件了，系统默认加载 git ，你可以在后面追加内容。1plugins=(git autojump mvn last-working-dir) 下面简单介绍一下我用的这几个插件: git:当你处于git的目录下时，Shell 会明确显示 git和 branch，如图所示，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh autojumpautojump可以说是zsh必备插件，有点双剑合璧的意思。安装了autojump之后，zsh会自动记录你访问过的目录，通过j+目录就可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过～/workspace目录，输入j wor即可正确跳转，如图。j –stat 可以看你的历史路径库。 last-working-dirlast-working-dir 插件，可以记录上一次退出Shell时的所在路径，并且在下一次启动Shell时自动恢复到退出时所在的路径。这一切不需要进行任何操作，全部都是自动完成的。 命令纠错如图，输入1sudp apt-get install nyae会提示zsh: correct ‘sudp’ to ‘sudo’ [nyae]?接下来直接按y/n就行了。真是太贴心了有木有那如何开启nyae提示呢？打开～/.zshrc，找到配置项更改为“true”即可12# Uncomment the following line to enable command auto-correction. ENABLE_CORRECTION="true" 指定zsh为默认Shell输入命令1chsh -s /bin/zsh zsh操作 输入 grep 然后用上下箭头可以翻阅你执行过的所有 grep 命令 tab补全:路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。 目录浏览和跳转:输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转 在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，不再需要输入 cd 命令了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ubuntu15.4安装mac主题]]></title>
      <url>%2F2016%2F05%2F05%2FUbuntu15.4%E5%AE%89%E8%A3%85mac%E4%B8%BB%E9%A2%98%2F</url>
      <content type="text"><![CDATA[mac用习惯了，换Ubuntu以后，觉得还是mac的图标主题好看。于是动手把Ubuntu的图标字体换成了mac的样式。教程如下: 安装Unity Tweak Tool个性化调节工具 1sudo apt-get install unity-tweak-tool 安装主题和鼠标光标 1234sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install mbuntu-y-ithemes-v5sudo apt-get install mbuntu-y-icons-v5 在Unity Tweak Tool选择 效果 docky与docky主题如果喜欢dock，可用下面命令安装。我不喜欢，就没装1234sudo apt-get install dockysudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install mbuntu-y-docky-skins-v5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器神器--Vimium]]></title>
      <url>%2F2016%2F05%2F05%2Fvimium%2F</url>
      <content type="text"><![CDATA[自从学会了正确的坐姿,坐在电脑一整天腰也不酸了、背也不痛了，精神倍棒吃嘛嘛香但奈何使用鼠标久了,手腕、肩膀依旧疼痛。偶尔逛知乎，看到有人推荐chrome浏览器的vimium插件（火狐浏览器是vimperator），安装了使用了几天，真不愧是浏览器神器，好用到想哭，而且非常容易上手。下面让我们来认识一下它吧: vimium简介Vimium 这个名字其实是 Vim 和 Chromium 的合体。很多人可能不知道 Vim，Vim 其实是 Linux 等平台上的一款文本编辑器，熟练的运用它可以彻底脱离鼠标，通过一系列快捷键，来操作写代码。而 Vimium 则继承了 Vim 中的常用操作，让你在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。想像一下，你再也不需要移动鼠标去打开一个链接，手指不用离开键盘，这一切将会是多么的幸福。 vimium安装chrome网上商店链接:点我点我！ vimium快捷键安装好vimium，按Shift+/可查看帮助如下下面是我整理的常用方法的思维导图:（注意大小写） 常用操作 页面滚动浏览任何一个页面时，不管你想向上滚动，向下滚动，到页面最底部……都只用按一两个键就可以搞定: j:向下滚动一点 k:向上滚动一点 gg:到页面最底部 G:到页面最底部(大写，即shift+g) d:向下翻一屏 u:向上翻一屏- 打开页面- 复制链接打开在网页上看到一段不可点的链接文字。以前是要复制–&gt;新建标签页–&gt;粘贴–&gt;回车,这才能打开。现在呢？你只需要:复制链接–&gt;直接按「p」或「P」就可以打开。小写的 p 是在当前标签页打开，大写的 P 是在新建标签页打开。- 从收藏夹、历史记录打开:如果之前看过的网页，现在还想再看一遍，直接按下o或O，输入对应的关键字后，会搜索历史记录和收藏夹，如果你输的是一个网址，回车就能直接打开。小写的o是在当前标签页打开，大写的O是在新标签页打开。如图:- 打开当前页面的任意一个链接:按一下f，当前页面上所有可点击的链接，都会生成一个对应的快捷键分派给这些链接。例如我想点击“我的收藏”，只需要输入“SM”(按住shift，再按s、m键)，就打开了“我的收藏”页面。- 切换标签页 显示当前所有标签页:浏览网页时，经常会打开好几个网页，按一下大写的T，就可以显示当前打开的所有标签页 切换到上个标签页:按大写的J 切换到下个标签页:按大写的K- 当前页面操作 后退:大写的H键 前进;大写的L键 关闭当前页面:小写的x 恢复刚刚关闭的页面:大写的X 查看网页源代码:g+s键 刷新页面:小写的r键 总结以上就是vimium的日常操作方法了。熟练掌握它，妈妈再也不用担心我的手腕、肩膀痛了……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo建立个人博客]]></title>
      <url>%2F2016%2F04%2F29%2F%E4%BD%BF%E7%94%A8Hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[个人博客是程序员的名片之一,今天,我们来看怎么使用Hexo快速建立个人博客. 一.完工效果http://www.lingyv.cn/ 这是本人建立好的个人网站.有以下特点: 使用个人申请的特色域名 代码托管在github和coding上 二.需要使用的工具 Hexo (Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。) github链接 hexo帮助文档 主题icarus(更多主题) github coding(国内coding访问速度更快) 三.开始1. github pages, coding pages github创建个人站点设置站点主题进入资源-setting选择主题并发布,我的已经设置过一次了.所以会跟你的有所不同 coding pagescoding创建项目设置pages2. 安装Hexo博客框架 安装git 1$ sudo apt-get install git 安装Node.js 12$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh$ nvm install 4 安装Hexo1$ npm install -g hexo-cli 新建blogs文件夹,克隆项目 1git clone git@github.com:lingyv/lingyv.github.io.git 执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件 123$ hexo init lingyv.github.io$ cd lingyv.github.io$ npm install 新建出的各种文件信息查看帮助文档 4. 配置Hexo查看配置文档我的配置文件信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: 漫步太虚subtitle: lingyvdescription: codingauthor: lingyvlanguage: zh-CNtimezone:avatar: /images/touxiang.png# URL 网址## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.lingyv.cnroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 目录source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类&amp;标签default_category: uncategorizedcategory_map:tag_map:# Archivesarchive: 1category: 1tag: 1# Date / Time format 日期格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: github: git@github.com:lingyv/lingyv.github.io.git coding: git@git.coding.net:lingyv/lingyv.git branch: master 5. 配置主题Hexo主题很多,查看主题 下载icarus主题到本地1$ git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus 主题参考文档 启用主题打开 站点配置文件,找到 theme字段，并将其值更改为icarus. 配置主题配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869menu: 首页: . 归档: archives# Categories: categories# 标签: tagcloud 关于: /about# Customizecustomize: logo: enabled: true width: 40 height: 40 url: images/logo.png profile: enabled: true # Whether to show profile bar avatar: css/images/touxiang.png gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: 凌宇 author_title: Java &amp; Python location: Shanghai, China follow: https://github.com/lingyv highlight: monokai sidebar: right # sidebar position, options: left, right thumbnail: true # enable posts thumbnail, options: true, false favicon: # path to favicon social_links: github: https://github.com/lingyv weibo: http://weibo.com/5051531692/profile?topnav=1&amp;wvr=6&amp;is_all=1 linkedin: http://cn.linkedin.com/in/lingyv# twitter: /# facebook: /# dribbble: /# rss: /# Widgets 小工具widgets: - recent_posts - category - archive - tag - tagcloud - links# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: true # you need to disable other search engines to use Baidu search, options: true, false# Commentcomment:# disqus: hexo-theme-icarus # enter disqus shortname here #使用多说评论 duoshuo: lingyv# youyan: # enter youyan uid here# Shareshare: default # options: jiathis, bdshare, addtoany, default# Pluginsplugins: fancybox: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics google_site_verification: # enter Google site verification code baidu_analytics: # enter Baidu Analytics hash key# Miscellaneousmiscellaneous: open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: links:# Hexo: http://hexo.io 6. 购买域名去万网或相关域名购买网站,挑选一个自己喜欢的域名吧 7. 域名解析 8. Hexo使用指南操作指令参考文档12345hexo n "博客"== hexo new "博客"#新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 9. hexo d以后,刷新网站就可以看到部署好的效果了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Http请求与响应]]></title>
      <url>%2F2016%2F04%2F29%2F%E6%B5%85%E8%B0%88Http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
      <content type="text"><![CDATA[我是一个服务器，名字是www.lingyv.cn，门牌号是121.42.155.28，每天得工作就是跟各种浏览器打交道。他们总来我这要求取信息、存信息、删信息。可惜我才疏学浅，只稍微学过HTTP协议，所以看得懂用HTTP规定格式发过来的请求信，当然，回复他的时候也是用HTTP规范写回信。我家有一个看门的人（服务器进程），每当有浏览器想找我时，他就会过来通知我。 这不，说着说着他就进来了。 “报~~~有浏览器找您。” “好，跟他连线。” OK，TCP连接已建立…… 哒哒哒………打印机将请求报文打印了出来。 我拿过来看了看。 只见第一行写着。 “GET /student/composition/index.html HTTP/1.1” “恩，这是用1.1版本HTTP规范写的。原来是找我要student文件夹里composition文件夹中的index.html文件啊。”我在心里默念。 转眼扫到第二行：“Host：www.lingyv.cn ”恩，是找我的没错。接着往下看第三行：“Connerction：keep-alive”噢，他跟我说给他发完index.html后不要关闭跟他的连接 接着看第四、第五行： “Accept:text/html” “Accept-Language:zh-CN” 这是在告诉我他能接收哪些类型的信息以及他能接收的语言啊。然后看最后一行： “User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36” 噢~~~这是在跟我表明自己的身份啊。 看完请求报文。我已经明白了这位浏览器客户的需求。赶紧找到index.html文件，给这位浏览器客户回信（响应报文）。 首先表明我使用的规范以及他的请求是成功的。 “HTTP/1.1 200 OK” 然后表明我接受获取他获取文件的请求 “Accept-Ranges: bytes” 接着告诉他我给他文件的类型 “Content-Type:text/html; charset=UTF-8“ 写上日期时间： “Date:Wed, 13 Apr 2016 13:17:32 GMT“告诉他我的个人信息： “Server：Apache/2.0.61 (Unix)” 告诉他内容的长度： “Content-Length:1350” …… 把这些声明（响应头）写完了。接下来空一行把他想要的文件内容copy进去（响应体）。 好了，所有东西写完，我就把信（响应报文）给这位浏览器客户发了过去，让他得到自己想要的文件信息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java变量]]></title>
      <url>%2F2016%2F04%2F01%2Fjava%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[参见官方文档There are several kinds of variables: Member variables in a class—these are called fields. Variables in a method or block of code—these are called local variables. Variables in method declarations—these are called parameters.]]></content>
    </entry>

    
  
  
</search>
