<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ActiveMQ官方文档 -- Spring支持]]></title>
      <url>%2F2016%2F11%2F18%2FActiveMQ%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3--Spring%E6%94%AF%E6%8C%81%2F</url>
      <content type="text"><![CDATA[ActiveMQ官方文档 – Spring支持We fully support Spring for configuration of the JMS client side as well as for configuring the JMS Message Broker.There is a great article on using Spring with ActiveMQ - I’d recommend reading it first. 我们完全支持Spring配置JMS客户端以及配置JMS Message Broker。这是一个关于使用Spring与ActiveMQ非常棒的文章 – 我建议首先阅读它。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Spring和ActiveMQ实现高效轻量的JMS]]></title>
      <url>%2F2016%2F11%2F18%2F%E4%BD%BF%E7%94%A8Spring%E5%92%8CActiveMQ%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E8%BD%BB%E9%87%8F%E7%9A%84JMS%2F</url>
      <content type="text"><![CDATA[官方推荐的文章，原文Asynchronicity, its the number one design principal for highly scalable systems, and for Java that means JMS, which in turn means ActiveMQ. But how do I use JMS efficiently? One can quickly become overwhelmed with talk of containers, frameworks, and a plethora of options, most of which are outdated. So lets pick it apart. 异步性，是高伸缩性系统的首要的设计原则，对Java来说，这意味着JMS和ActiveMQ。但是我应该如何高效的使用JMS呢？在谈论容器、框架、和一堆选项时，你可能会不知所措。所以，让我们分开来探讨下吧。 Frameworks 框架The ActiveMQ documentation makes mention of two frameworks; Camel and Spring. The decision here comes down to simplicity vs functionality. Camel supports an immense amount of Enterprise Integration Patterns that can greatly simplify integrating a variety of services and orchestrating complicated message flows between components. Its certainly a best of breed if your system requires such functionality. However, if you are looking for simplicity and support for the basic best practices then Spring has the upper hand. For me, simplicity wins out any day of the week. ActiveMQ文档中提及两个框架：Camel和Spring。那么如何做决定就取决于简单性和功能性的对比。Camel支持大量的企业集成模式，它可以大大简化集成组件间的大量服务和复杂的消息流。如果你的系统需要这样的功能，它当然是非常好的选择。然而，如果你寻找简单性，仅仅支持基本的最佳实践，那么Spring是好的选择。 JCA (Use It Or Loose It)Reading through ActiveMQ’s spring support one is instantly introduced to the idea of a JCA container and ActiveMQ’s various proxies and adaptors for working inside of one. However, this is all a red herring. JCA is part of the EJB specification and as with most of the EJB specification, Spring doesn’t support it. Then there is a mention of Jencks, a “lightweight JCA container for Spring”, which was spun off of ActiveMQ’s JCA container. At first this seems like the ideal solution, but let me stop you there. Jencks was last updated on January 3rd 2007. At that time ActiveMQ was at version 4.1.x and Spring was at version 2.0.x and things have come a long way, a very long way. Even trying to get Jencks from the maven repository fails due to dependencies on ActiveMQ 4.1.x jars that no longer exist. The simple fact is there are better and simpler ways to ensure resource caching. 阅读ActiveMQ的Spring支持时，开发者立刻被介绍了JCA容器和ActiveMQ很多的代理和适配器选项的概念。然而这些都不适应。JCA是EJB规范的一部分，对于大部分EJB规范，Spring都没有提供很好的支持。这时，就提到了Jencks，为Spring提供的轻量级JCA容器，它可以作为ActiveMQ的JCA容器。 乍看上去，这是个非常好的解决方案，但是我在这里告诉你不要这样做。Jencks最后更新时间是2007年1月。那时ActiveMQ的版本是 4.1x，Spring的版本是2.0.x，但是时间过了很多，事情也变化了很大。甚至是试图从Maven库中获取ActiveMQ4.1的依赖包 Jencks都会失败，因为它已经不存在了。简单的事实是有更好和更简单的方式来缓存资源。 Sending Messages 发送消息The core of Spring’s message sending architecture is the JmsTemplate. In typical Spring template fashion, the JmsTemplate abstracts away all the cruft of opening and closing sessions and producers so all the application developer needs to worry about is the actual business logic. However, ActiveMQ is quick to point out the JmsTemplate gotchas, mostly that JmsTemplate is designed to open and close the session and producer on each call. To prevent this from absolutely destroying the messaging performance the documentation recommends using ActiveMQ’s PooledConnectionFactory which caches the sessions and message producers. However this too is outdated. Starting with version 2.5.3, Spring started shipping its own CachingConnectionFactory which I believe to be the preferred caching method. (UPDATE: In my more recent post, I talk about when you might want to use PooledConnectionFactory.) However, there is one catch to point out. By default the CachingConnectionFactory only caches one session which the javadoc claims to be sufficient for low concurrency situations). By contrast, the PooledConnectionFactory defaults to 500. As with most settings of this type, some amount of experimentation is probably in order. I’ve started with 100 which seems like a good compromise. Spring消息发送的核心架构是JmsTemplate。在传统的Spring模板方式中，JmsTemplate隔离了像打开、关闭Session和Producer的繁琐操作，因此应用开发人员仅仅需要关注实际的业务逻辑。然而ActiveMQ快速的指出了JmsTemplate gotchas，大多是因为JmsTemplate被设计在每次调用时都打开和关闭session及producer。JmsTemplate损害了ActiveMQ的PooledConnectionFactory对session和消息producer的缓存机制而带来的性能提升。然而，这个太过时了。从Spring2.5.3开始，它开始提供自己的CachingConnectionFactory，我相信该类在缓存方面更加强大。然而，这里有一个点需要注意。默认情况下，CachingConnectionFactory只缓存一个session，在它的JavaDoc中，它声明对于低并发情况下这是足够的。与之相反，PooledConnectionFactory的默认值是500。这些设置，在很多情况下，需要亲自去测试并验证。我将其设置为100，对我来说还是很不错。 Receiving Messages 接收消息As you may have noticed, the JmsTemplate gotchas strongly discourages using the recieve() call on the JmsTemplate, again, since there is no pooling of sessions and consumers. Moreover, all calls on the JmsTemplate are synchronous which means the calling thread will block until the method returns. This is fine when using JmsTemplate to send messages since the method returns almost instantly. However, when using the recieve() call, the thread will block until a message is received, which has a huge impact on performance. Unfortunately, neither the JmsTemplate gotchas nor the spring support documentation mentions the simple Spring solution for these problems. In fact they both recommend using Jencks, which we already debunked. The actual solution, using the DefaultMessageListenerContainer, is buried in the how do I use JMS efficiently documentation. The DefaultMessageListenerContainer allows for the asynchronous receipt of messages as well as caching sessions and message consumers. Even more interesting, the DefaultMessageListenerContainer can dynamically grow and shrink the number of listeners based on message volume. In short, this is why we can completely ignore JCA. Spring消息发送的核心架构是JmsTemplate。在传统的Spring模板方式中，JmsTemplate隔离了像打开、关闭Session和Producer的繁琐操作，因此应用开发人员仅仅需要关注实际的业务逻辑。然而ActiveMQ快速的指出了JmsTemplate gotchas，大多是因为JmsTemplate被设计在每次调用时都打开和关闭session及producer。JmsTemplate损害了ActiveMQ的PooledConnectionFactory对session和消息producer的缓存机制而带来的性能提升。然而，这个太过时了。从Spring2.5.3开始，它开始提供自己的CachingConnectionFactory，我相信该类在缓存方面更加强大。然而，这里有一个点需要注意。默认情况下，CachingConnectionFactory只缓存一个session，在它的JavaDoc中，它声明对于低并发情况下这是足够的。与之相反，PooledConnectionFactory的默认值是500。这些设置，在很多情况下，需要亲自去测试并验证。我将其设置为100，对我来说还是很不错。 Putting It All Together 合并起来SPRING CONTEXT XMLSpring Context配置文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsdhttp://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.2.0.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsdhttp://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-2.5.xsd&quot;&gt;&lt;!-- enables annotation based configuration --&gt;&lt;context:annotation-config /&gt;&lt;!-- scans for annotated classes in the com.company package --&gt;&lt;context:component-scan base-package=&quot;com.company&quot;/&gt;&lt;!-- allows for $&#123;&#125; replacement in the spring xml configuration from the system.properties file on the classpath --&gt;&lt;context:property-placeholder location=&quot;classpath:system.properties&quot;/&gt;&lt;!-- creates an activemq connection factory using the amq namespace --&gt;&lt;amq:connectionFactory id=&quot;amqConnectionFactory&quot; brokerURL=&quot;$&#123;jms.url&#125;&quot; userName=&quot;$&#123;jms.username&#125;&quot; password=&quot;$&#123;jms.password&#125;&quot; /&gt;&lt;!-- CachingConnectionFactory Definition, sessionCacheSize property is the number of sessions to cache --&gt;&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt; &lt;constructor-arg ref=&quot;amqConnectionFactory&quot; /&gt; &lt;property name=&quot;exceptionListener&quot; ref=&quot;jmsExceptionListener&quot; /&gt; &lt;property name=&quot;sessionCacheSize&quot; value=&quot;100&quot; /&gt;&lt;/bean&gt;&lt;!-- JmsTemplate Definition --&gt;&lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt; &lt;constructor-arg ref=&quot;connectionFactory&quot;/&gt;&lt;/bean&gt;&lt;!-- listener container definition using the jms namespace, concurrency is the max number of concurrent listeners that can be started --&gt;&lt;jms:listener-container concurrency=&quot;10&quot; &gt; &lt;jms:listener id=&quot;QueueListener&quot; destination=&quot;Queue.Name&quot; ref=&quot;queueListener&quot; /&gt;&lt;/jms:listener-container&gt;&lt;/beans&gt; There are two things to notice here. First, I’ve added the amq and jms namespaces to the opening beans tag. Second, I’m using the Spring 2.5 annotation based configuration. By using the annotation based configuration I can simply add @Component annotation to my Java classes instead of having to specify them in the spring context xml explicitly. Additionally, I can add @Autowired on my constructors to have objects such as JmsTemplate automatically wired into my objects. 这里有两点需要注意。首先，我添加了amq和jms的命名空间。第二，我使用了Spring2.5的基于注解的配置。通过使用基于注解的配置，我可以简单的添加@Component注解到我的Java类上，而不是使用XML文件显式的在spring配置文件中定义它们。另外，我可以在我的构造方法中使用@Autowired来将像JmsTemplate这样的对象注入到我的对象中。 QUEUESENDER12345678910111213141516171819202122package com.company;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;@Componentpublic class QueueSender&#123; private final JmsTemplate jmsTemplate; @Autowired public QueueSender( final JmsTemplate jmsTemplate ) &#123; this.jmsTemplate = jmsTemplate; &#125; public void send( final String message ) &#123; jmsTemplate.convertAndSend( &quot;Queue.Name&quot;, message ); &#125;&#125; QUEUE LISTENER12345678910111213141516171819202122232425262728package com.company;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.springframework.stereotype.Component;@Componentpublic class QueueListener implements MessageListener&#123; public void onMessage( final Message message ) &#123; if ( message instanceof TextMessage ) &#123; final TextMessage textMessage = (TextMessage) message; try &#123; System.out.println( textMessage.getText() ); &#125; catch (final JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ## JMSEXCEPTIONLISTENER123456789101112131415package com.company;import javax.jms.ExceptionListener;import javax.jms.JMSException;import org.springframework.stereotype.Component;@Componentpublic class JmsExceptionListener implements ExceptionListener&#123; public void onException( final JMSException e ) &#123; e.printStackTrace(); &#125;&#125; Update 更新I have finally updated the wiki at activemq.apache.org. The following pages now recommend using MessageListenerContainers and JmsTemplate with a Pooling ConnectionFactory instead of JCA and Jencks. 推荐查看下面的页面来使用带有池化连接池的MessageListenerContainer和JmsTemplate而不是JCA和Jencks。 http://activemq.apache.org/spring-support.html http://activemq.apache.org/how-do-i-use-jms-efficiently.html http://activemq.apache.org/jmstemplate-gotchas.html 译文参考:寒江的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ActiveMQ官方文档 -- 入门]]></title>
      <url>%2F2016%2F11%2F17%2FActiveMQ%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[ActiveMQ官方文档 – 入门 Introduction 介绍This document describes how to install and configure ActiveMQ 4.x/5.x for both Unix and Windows’ platforms. 本文档介绍如何在Unix和Windows平台上安装和配置ActiveMQ 4.x / 5.x。 Pre-Installation Requirements 安装要求Hardware: 60 MB of free disk space for the ActiveMQ 5.x binary distribution.(you need additional disk space for storing persistent messages to disk) 300 MB of free disk space for the ActiveMQ 5.x source or developer’s distributions.Operating Systems: Windows: Windows XP SP2, Windows 2000, Windows Vista, Windows 7. Unix: Ubuntu Linux, Powerdog Linux, MacOS, AIX, HP-UX, Solaris, or any Unix platform that supports Java.Environment: Java Runtime Environment (JRE) JRE 1.7 (1.6 for version &lt;=5.10.0)(a JDK is required if you plan to recompile source code) The JAVA_HOME environment variable must be set to the directory where the JRE is installed(Unix: the binary “java” has to be resolvable by the PATH variable; execute “which java” to verify) Maven 3.0.0 build system(only if you plan to recompile source code) JARs that will be used must be added to the classpath.(only if you plan to recompile source code) Installation Procedure for Windows Windows的安装过程This section of the Getting Started Guide explains how to install binary and source distributions of ActiveMQ on a Windows system. “入门指南”的本部分介绍如何在Windows系统上安装ActiveMQ的二进制和源代码分发。 Windows Binary Installation Windows二进制安装This procedure explains how to download and install the binary distribution on a Windows system. 此过程说明如何在Windows系统上下载和安装二进制发行版。 Download the latest release(see Download -&gt; “The latest stable release” -&gt; “apache-activemq-x.x.x-bin.zip”) Extract the files from the ZIP file into a directory of your choice. Proceed to the #Starting ActiveMQ section of this document. Following start-up, go to the #Testing the Installation section of this document. 下载最新版本（请参阅下载 - &gt;“最新稳定版本” - &gt;“apache-activemq-x.x.x-bin.zip”） 将ZIP文件中的文件解压缩到您选择的目录中。 继续本文档的#Starting ActiveMQ部分。 启动后，请转到本文档的#Testing the Installation部分。 Windows Source Installation Windows源码安装This procedure explains how to download and install the source distribution on a Windows system. Download the latest release(see Download -&gt; “The latest stable release” -&gt; “apache-activemq-x.x.x-source-release.zip”) Extract ActiveMQ from the ZIP file into a directory of your choice. The recommended method of building ActiveMQ is the following:12REM add &quot;-Dmaven.test.skip=true&quot; if tests are failing on your system (should not happen)mvn clean install where [activemq_install_dir] is the directory in which ActiveMQ was installed. If you prefer to use an IDE, then you can auto-generate the IDE’s project file using maven plugins:1mvn eclipse:eclipse or1mvn idea:idea Feel free to use any other applicable IDE. Please refer to the plugin reference for more details. 此过程说明如何在Windows系统上下载和安装源码发行版。 下载最新版本（请参阅下载 - &gt;“最新稳定版本” - &gt;“apache-activemq-x.x.x-source-release.zip”） 将ActiveMQ从ZIP文件解压缩到您选择的目录中。 建议使用ActiveMQ的推荐方法如下：12如果测试在您的系统上失败（不应该发生）,REM添加“-Dmaven.test.skip = true”mvn clean install 其中[activemq_install_dir]是安装ActiveMQ的目录。 如果你喜欢使用IDE，那么你可以使用maven插件自动生成IDE的项目文件：1mvn eclipse:eclipse or1mvn idea:idea 可随意使用其他任何适用的IDE。 有关更多详细信息，请参阅插件参考。 Start ActiveMQ from the target directory, for example:1234cd [activemq_install_dir]\assembly\targetunzip activemq-x.x-SNAPSHOT.zipcd activemq-x.x-SNAPSHOTbin\activemq NOTE: Working directories get created relative to the current directory. To create the working directories in the proper place, ActiveMQ must be launched from its home/installation directory. Proceed to the #Testing the Installation section. 12Warning:If you are building ActiveMQ 4.x under Windows using Cygwin there is a path name length limitation. If the path name length is exceeded, you may see build errors. To correct this, move the ActiveMQ source directory higher in the file system tree, e.g., /cygdrive/c/d/sm. 从目标目录启动ActiveMQ，例如： 1234cd [activemq_install_dir]\assembly\targetunzip activemq-x.x-SNAPSHOT.zipcd activemq-x.x-SNAPSHOTbin\activemq 注意：相对于当前目录创建工作目录。 要在正确的位置创建工作目录，ActiveMQ必须从其home/安装目录启动。 转到#Testing安装部分。12警告如果您在Windows下使用Cygwin构建ActiveMQ 4.x，则存在路径名称长度限制。 如果超过路径名称长度，您可能会看到构建错误。 要纠正这一点，请将ActiveMQ源目录在文件系统树中更高的位置，例如/ cygdrive / c / d / sm。 Windows Developer’s Release Windows开发人员版本This procedure explains how to download and install the latest developer’s snapshot. Open the release archive: https://repository.apache.org/content/repositories/snapshots/org/apache/activemq/apache-activemq/(open one of the SNAPSHOT directories) Select the version of ActiveMQ to download (if necessary, scroll down to see the ActiveMQ snapshots). Extract the files from the ZIP file into a directory of your choice. If a binary snapshot was downloaded, proceed to the #Starting ActiveMQ section of this document.If a source snapshot was downloaded, perform step 6 and step 7 of the #Windows Source Installation procedure. Following start-up, proceed to the #Testing the Installation section. Installation Procedure for Unix Unix的安装过程Unix Binary Installation Unix二进制安装This procedure explains how to download and install the binary distribution on a Unix system. NOTE: There are several alternative ways to perform this type of installation. 此过程说明如何在Unix系统上下载和安装二进制发行版。 注意：有几种可选的方法来执行此类型的安装。 Download the activemq zipped tarball file to the Unix machine, using either a browser or a tool, i.e., wget, scp, ftp, etc. for example:(see Download -&gt; “The latest stable release”) 1wget http://activemq.apache.org/path/tofile/apache-activemq-x.x.x-bin.tar.gz Extract the files from the zipped tarball into a directory of your choice. For example: 12cd [activemq_install_dir]tar zxvf activemq-x.x.x-bin.tar.gz Proceed to the #Starting ActiveMQ section of this document. Following start-up, go to the #Testing the Installation section. Using Homebrew installer on OSXIf you use OSX as your platform, you can use Homebrew package manager to easily install Apache ActiveMQ. After installing Homebrew package manager successfully, just run1$ brew install apache-activemq You can expect the following output:1234567==&gt; Downloading http://www.gossipcheck.com/mirrors/apache/activemq/apache-activemq/x.x.x/apache-activemq-x.x.x-bin.tar.gz######################################################################## 100.0%==&gt; CaveatsSoftware was installed to: /usr/local/Cellar/apache-activemq/x.x.x/libexec==&gt; Summary/usr/local/Cellar/apache-activemq/x.x.x: 406 files, 35M, built in 2 seconds ActiveMQ will be installed in /usr/local/Cellar/apache-activemq/x.x.x/ directory (where x.x.x denotes the actual version being installed). Now you can proceed to #Starting ActiveMQ and #Testing the Installation sections. Unix Source InstallationThis procedure explains how to download and install the source distribution on a Unix system. This procedure assumes the Unix machine has a browser. Please see the previous #Unix Binary Installation section for details on how to install ActiveMQ without a browser. Download the latest source release(see Download -&gt; “The latest stable release” -&gt; “activemq-parent-x.x.x-source-release.zip”) Extract the files from the ZIP file into a directory of your choice. For example: 1tar zxvf activemq.x.x-src.tar.gz Build ActiveMQ using Maven:The preferred method of building ActiveMQ is the following:cd [activemq_install_dir] 1mvn clean install # add &quot;-Dmaven.test.skip=true&quot; if tests are failing on your system (should not happen) If Maven crashes with a java.lang.OutOfMemoryError, you you need to do this first (assuming a Bourne-like shell):1export MAVEN_OPTS=&quot;-Xmx512M&quot; If you prefer to use an IDE then you can auto-generate the IDE’s project file using maven plugins:1mvn eclipse:eclipse or1mvn idea:idea Feel free to use any other applicable IDE. Please refer to the plugin reference for more details.NOTE: Working directories get created relative to the current directory. To create working directories in the proper place, ActiveMQ must be launched from its home/installation directory. Proceed to the #Starting ActiveMQ section of this document. Proceed to #Testing the Installation section. ## Unix Developer’s ReleaseThis procedure explains how to download and install the latest developer’s snapshot. Open the release archive: https://repository.apache.org/content/repositories/snapshots/org/apache/activemq/apache-activemq/(open one of the SNAPSHOT directories) Select the version of ActiveMQ to download (you may have to scroll down to see the ActiveMQ snapshots).The filename will be similar to: activemq-x.x.x-tar.gz. Extract the files from the gzip file into a directory of your choice. For example:For a binary developer’s snapshot:1tar zxvf activemq-x.x.x.tar.gz For a source developer’s snapshot:1tar zxvf activemq-x.x.x-src.tar.gz If a binary snapshot was downloaded, to make it executable, the ActiveMQ script may need its permissions changed: 12cd [activemq_install_dir]/binchmod 755 activemq For a binary snapshot, proceed to the #Starting ActiveMQ section of this document. If a source snapshot was downloaded perform steps 6 - 8 of the #Unix Source Installation procedure. Proceed to the #Testing the Installation section. Starting ActiveMQ 运行ActiveMQThere now follows instructions on how to run the ActiveMQ Message Broker.现在有关于如何运行ActiveMQ消息代理的说明。 On Windows:From a console window, change to the installation directory and run ActiveMQ: 在控制台窗口中，切换到安装目录并运行ActiveMQ：1cd [activemq_install_dir] where activemq_install_dir is the directory in which ActiveMQ was installed, e.g., c:\Program Files\ActiveMQ-5.x.Then type: 其中activemq_install_dir是安装ActiveMQ的目录，例如c:\Program Files\ActiveMQ-5.x。然后键入：1bin\activemq start NOTE: Working directories get created relative to the current directory. To create working directories in the proper place, ActiveMQ must be launched from its home/installation directory. 注意：相对于当前目录创建工作目录。 要在正确的位置创建工作目录，ActiveMQ必须从其home/installation目录启动。 On Unix:From a command shell, change to the installation directory and run ActiveMQ as a foregroud process:12cd [activemq_install_dir]/bin./activemq console From a command shell, change to the installation directory and run ActiveMQ as a daemon process:12cd [activemq_install_dir]/bin./activemq start ## More helpFor other ways of running the broker see Here. For example you can run an embedded broker inside your JMS Connection to avoid starting a separate process. 有关运行代理的其他方法，请参阅这里。 例如，您可以在JMS连接中运行嵌入式代理，以避免启动单独的进程。 Testing the Installation 测试安装是否成功Using the administrative interface 使用管理接口 Open the administrative interface URL: http://127.0.0.1:8161/admin/ Login: admin Passwort: admin Navigate to “Queues” Add a queue name and click create Send test message by klicking on Send to 打开管理界面 网址：http://127.0.0.1:8161/admin/ 登录：admin 密码：admin 导航到“Queues” 添加队列名称，然后单击create 通过点击Send to发送测试消息 Logfile and console output 日志文件和控制台输出If ActiveMQ is up and running without problems, the Window’s console window or the Unix command shell will display information similar to the following log line: (see stdout output or “[activemq_install_dir]/data/activemq.log”) 如果ActiveMQ启动并运行没有问题，窗口的控制台窗口或Unix命令shell将显示类似以下日志行的信息： （请参见stdout输出或“[activemq_install_dir] /data/activemq.log”）1Apache ActiveMQ 5.11.1 (localhost, ID:ntbk11111-50816-1428933306116-0:1) started | org.apache.activemq.broker.BrokerService | main Listen port 监听端口ActiveMQ’s default port is 61616. From another window run netstat and search for port 61616. ActiveMQ的默认端口是61616.从另一个窗口运行netstat并搜索端口61616。 From a Windows console, type: 在Windows控制台中，键入：1netstat -an|find &quot;61616&quot; ORFrom a Unix command shell, type:1netstat -nl|grep 61616 Monitoring ActiveMQ 监视ActiveMQYou can monitor ActiveMQ using the Web Console by pointing your browser athttp://localhost:8161/admin 您可以通过指向浏览器使用Web控制台监视ActiveMQhttp://localhost:8161/admin12345From ActiveMQ 5.8 onwards the web apps is secured out of the box.The default username and password is admin/admin. You can configure this in the conf/jetty-real.properties file.从ActiveMQ 5.8起，网络应用程序是开箱即用的。默认用户名和密码为admin/admin。 您可以在conf/jetty-real.properties文件中进行配置。 Or you can use the JMX support to view the running state of ActiveMQ. 或者可以使用JMX支持来查看ActiveMQ的运行状态。 For more information see the file docs/WebConsole-README.txt in the distribution. 有关详细信息，请参阅分发中的文件docs / WebConsole-README.txt。 Stopping ActiveMQ 停止ActiveMQFor both Windows and Unix installations, terminate ActiveMQ by typing “CTRL-C” in the console or command shell in which it is running. 对于Windows和Unix安装，通过在其运行的控制台或命令shell中键入“CTRL-C”来终止ActiveMQ。 If ActiveMQ was started in the background on Unix, the process can be killed, with the following: 如果ActiveMQ是在后台在Unix上启动的，进程可以被以下命令杀死：12cd [activemq_install_dir]/bin./activemq stop Configuring ActiveMQThe ActiveMQ broker should now run. You can configure the broker by specifying an Xml Configuration file as a parameter to the activemq command. An alternative is to use the Broker Configuration URI to configure things on the command line in a concise format (though the configuration options are not as extensive as if you use Java or XML code). ActiveMQ代理现在应该运行。 您可以通过将Xml配置文件指定为activemq命令的参数来配置代理。 另一种方法是使用Broker配置URI以简洁的格式配置命令行中的内容（虽然配置选项不像使用Java或XML代码那样广泛）。 You can also see Configuring Transports to see how you can configure the various connection, transport and broker options using the connection URL in the ActiveMQConnectionFactory. 您还可以查看配置传输，了解如何使用ActiveMQConnectionFactory中的连接URL配置各种连接，传输和代理选项。 See the Initial Configuration for details of which jars you need to add to your classpath to start using ActiveMQ in your Java code 有关哪些jar需要添加到类路径以开始在Java代码中使用ActiveMQ的详细信息，请参阅初始配置 If you want to use JNDI to connect to your JMS provider then please view the JNDI Support. If you are a Spring user you should read about Spring Support 如果要使用JNDI连接到JMS提供程序，请查看JNDI支持。 如果你是一个Spring用户，你应该阅读关于Spring支持 After the installation, ActiveMQ is running with a basic configuration. For details on configuring options, please see refer to the Configuration section. 安装后，ActiveMQ正在使用基本配置运行。 有关配置选项的详细信息，请参阅配置部分。 Additional Resources 其他资源If you are new to using ActiveMQ, running the Web Samples or the Examples is a good next step to learn more about ActiveMQ. 如果您刚刚使用ActiveMQ，运行Web示例或示例可以了解ActiveMQ的更多信息。 The Commercial Providers listed on the Support page may also have additional documentation, examples, tutorials, etc… that can help you get started. 支持页面上列出的商业提供商可能还有其他文档，示例，教程等，可以帮助您开始。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate Validator官方文档 -- 第2章]]></title>
      <url>%2F2016%2F11%2F11%2FHibernate%20Validator%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3--%E7%AC%AC2%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[Hibernate Validator官方文档–第2章 声明和验证bean约束 2. Declaring and validating bean constraintsIn this chapter you will learn how to declare (see Section 2.1, “Declaring bean constraints”) and validate (see Section 2.2, “Validating bean constraints”) bean constraints. Section 2.3, “Built-in constraints” provides an overview of all built-in constraints coming with Hibernate Validator. If you are interested in applying constraints to method parameters and return values, refer to Chapter 3, Declaring and validating method constraints. 在本章中，您将学习如何声明(见第2.1节“声明bean约束”)和验证(参见第2.2节“验证bean约束”)bean约束。 第2.3节“内置约束”提供了Hibernate Validator提供的所有内置约束的概述。 如果您有兴趣对方法参数和返回值应用约束，请参阅第3章，声明和验证方法约束。 2.1. Declaring bean constraintsConstraints in Bean Validation are expressed via Java annotations. In this section you will learn how to enhance an object model with these annotations. There are the following three types of bean constraints: Bean验证中的约束通过Java注释来表示。 在本节中，您将学习如何使用这些注释增强对象模型。 有以下三种类型的bean约束： field constraints 字段约束 property constraints 属性约束 class constraints 类约束 Note：Not all constraints can be placed on all of these levels. In fact, none of the default constraints defined by Bean Validation can be placed at class level. The java.lang.annotation.Target annotation in the constraint annotation itself determines on which elements a constraint can be placed. See Chapter 6, Creating custom constraints for more information. 注意：不是所有的约束都可以放在所有这些级别上。 事实上，Bean Validation定义的默认约束不能放在类级别。 约束注释中的java.lang.annotation.Target注释本身确定了可以在哪些元素上放置约束。 有关更多信息，请参阅第6章，创建自定义约束。 2.1.1. Field-level constraintsConstraints can be expressed by annotating a field of a class. Example 2.1, “Field-level constraints” shows a field level configuration example: 约束可以通过注释类的字段来表示。 示例2.1，“字段级约束”显示字段级配置示例：1234567891011121314151617package org.hibernate.validator.referenceguide.chapter02.fieldlevel;public class Car &#123; @NotNull private String manufacturer; @AssertTrue private boolean isRegistered; public Car(String manufacturer, boolean isRegistered) &#123; this.manufacturer = manufacturer; this.isRegistered = isRegistered; &#125; //getters and setters...&#125; When using field-level constraints field access strategy is used to access the value to be validated. This means the validation engine directly accesses the instance variable and does not invoke the property accessor method even if such an accessor exists. Constraints can be applied to fields of any access type (public, private etc.). Constraints on static fields are not supported, though. Tip：When validating byte code enhanced objects property level constraints should be used, because the byte code enhancing library won’t be able to determine a field access via reflection. 当使用字段级约束时，字段访问策略用于访问要验证的值。 这意味着验证引擎不调用属性访问方法(即使这样的访问方法存在),而是直接访问实例变量。 约束可以应用于访问任何类型(公共，私有等)的字段，但不支持静态字段的约束。 提示：当验证字节码增强对象时，应该使用属性级别约束，因为字节码增强库将不能通过反射来确定字段访问。 2.1.2. Property-level constraintsIf your model class adheres to the JavaBeans standard, it is also possible to annotate the properties of a bean class instead of its fields. Example 2.2, “Property-level constraints” uses the same entity as in Example 2.1, “Field-level constraints”, however, property level constraints are used. 如果你的model类遵循JavaBeans标准，也可以注释一个bean类的属性，而不是它的字段。 示例2.2，“属性级别约束”使用与示例2.1“字段级别约束”中相同的实体类，但是，这里使用属性级别约束。12345678910111213141516171819202122232425262728293031package org.hibernate.validator.referenceguide.chapter02.propertylevel;public class Car &#123; private String manufacturer; private boolean isRegistered; public Car(String manufacturer, boolean isRegistered) &#123; this.manufacturer = manufacturer; this.isRegistered = isRegistered; &#125; @NotNull public String getManufacturer() &#123; return manufacturer; &#125; public void setManufacturer(String manufacturer) &#123; this.manufacturer = manufacturer; &#125; @AssertTrue public boolean isRegistered() &#123; return isRegistered; &#125; public void setRegistered(boolean isRegistered) &#123; this.isRegistered = isRegistered; &#125;&#125; Note:The property’s getter method has to be annotated, not its setter. That way also read-only properties can be constrained which have no setter method When using property level constraints property access strategy is used to access the value to be validated, i.e. the validation engine accesses the state via the property accessor method. Tip：It is recommended to stick either to field or property annotations within one class. It is not recommended to annotate a field and the accompanying getter method as this would cause the field to be validated twice. 注意：必须注解属性的getter方法，而不是它的setter方法。 这种方式也可以约束没有setter方法的只读属性。 当使用属性级别约束时，使用属性访问策略来访问要验证的值，即验证引擎通过属性访问方法来访问状态。 提示：建议注释一个类中的字段或属性。 不建议对字段和附带的getter方法进行注释，因为这会导致该字段被验证两次。 2.1.3. Type argument constraintsStarting from Java 8, it is possible to specify constraints directly on the type argument of a parameterized type. However, this requires that ElementType.TYPE_USE is specified via @Target in the constraint definition. To maintain backwards compatibility, built-in Bean Validation as well as Hibernate Validator specific constraints do not yet specify ElementType.TYPE_USE. To make use of type argument constraints, custom constraints must be used (see Chapter 6, Creating custom constraints). Hibernate Validator validates type arguments constraints specified on collections, map values, java.util.Optional, and custom parameterized types. 从Java 8开始，可以直接在参数化类型的类型参数上指定约束。 但是，这要求在约束定义中通过@Target指定ElementType.TYPE_USE。 为了保持向后兼容性，内置Bean验证以及Hibernate Validator特定的约束还没有指定ElementType.TYPE_USE。 要使用类型参数约束，必须使用自定义约束(请参见第6章，创建自定义约束)。 Hibernate Validator验证指定的集合，map，java.util.Optional和自定义参数化类型等类型参数的约束。 2.1.3.1. With IterableWhen applying constraints on an Iterable type argument, Hibernate Validator will validate each element. Example 2.3, “Type argument constraint on List” shows an example of a List with a type argument constraint. In this example, @ValidPart is a custom constraint allowed to be used in the TYPE_USE context. 当对Iterable类型参数应用约束时，Hibernate Validator将验证每个元素。 示例2.3，“List上的类型参数约束”显示了具有类型参数约束的List的示例。 在此示例中，@ValidPart是允许在TYPE_USE上下文中使用的自定义约束。123456789101112131415161718192021222324252627282930Example 2.3. Type argument constraint on Listpackage org.hibernate.validator.referenceguide.chapter02.typeargument;public class Car &#123; @Valid private List&lt;@ValidPart String&gt; parts = new ArrayList&lt;&gt;(); public void addPart(String part) &#123; parts.add( part ); &#125; //...&#125;Car car = Car();car.addPart( &quot;Wheel&quot; );car.addPart( null );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;&apos;null&apos; is not a valid car part.&quot;, constraintViolations.iterator().next().getMessage());assertEquals( &quot;parts[1].&lt;collection element&gt;&quot;, constraintViolations.iterator().next().getPropertyPath().toString() ); 2.1.3.2. With MapType argument constraints are also validated for map values. Constraints on the key are ignored. Example 2.4, “Type argument constraint on maps” shows an example of a Map value with a type argument constraint. 类型参数约束也针对map验证。 忽略键上的约束。 示例2.4，“map类型参数约束”显示了具有类型参数约束的Map值的示例。1234567891011121314151617181920212223242526272829Example 2.4. Type argument constraint on mapspackage org.hibernate.validator.referenceguide.chapter02.typeargument;public class Car &#123; public static enum FuelConsumption &#123; CITY, HIGHWAY &#125; @Valid private EnumMap&lt;FuelConsumption, @MaxAllowedFuelConsumption Integer&gt; fuelConsumption = new EnumMap&lt;&gt;( FuelConsumption.class ); public void setFuelConsumption(FuelConsumption consumption, int value) &#123; fuelConsumption.put( consumption, value ); &#125; //...&#125;Car car = new Car();car.setFuelConsumption( Car.FuelConsumption.HIGHWAY, 20 );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;20 is outside the max fuel consumption.&quot;, constraintViolations.iterator().next() 2.1.3.3. With java.util.OptionalWhen applying a constraint on the type argument of Optional, Hibernate Validator will automatically unwrap the type and validate the internal value. Example 2.5, “Type argument constraint on Optional” shows an example of an Optional with a type argument constraint. 当对Optional的类型参数应用约束时，Hibernate Validator将自动解包类型并验证内部值。 示例2.5，“Optional上的类型参数约束”显示了一个带有类型参数约束的Optional示例。123456789101112131415161718192021222324252627282930Example 2.5. Type argument constraint on Optionalpackage org.hibernate.validator.referenceguide.chapter02.typeargument;import java.util.ArrayList;import java.util.EnumMap;import java.util.List;import java.util.Optional;import javax.validation.Valid;public class Car &#123; private Optional&lt;@MinTowingCapacity(1000) Integer&gt; towingCapacity = Optional.empty(); public void setTowingCapacity(Integer alias) &#123; towingCapacity = Optional.of( alias ); &#125; //...&#125;Car car = Car();car.setTowingCapacity( 100 );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;Not enough towing capacity.&quot;, constraintViolations.iterator().next().getMessage() );assertEquals( &quot;towingCapacity&quot;, constraintViolations.iterator().next().getPropertyPath().toString() ); 2.1.3.4. With custom parameterized typesType arguments constraints can with two restrictions also be used with custom types. First, a ValidatedValueUnwrapper must be registered for the custom type allowing to retrieve the value to validate (see Section 11.13, “Unwrapping values”). Second, only types with one type arguments are supported. Parameterized types with two or more type arguments are not checked for type argument constraints. This limitation might change in future versions. Example 2.6, “Type argument constraint on custom parameterized type” shows an example of a custom parameterized type with a type argument constraint. 类型参数约束可以有两个限制也可以使用自定义类型。 首先，必须为自定义类型注册ValidatedValueUnwrapper，以允许检索要验证的值(请参见第11.13节“解包值”)。 第二，只支持具有一个类型参数的类型。 不检查具有两个或更多类型参数的参数化类型的类型参数约束。 此限制在将来的版本中可能会更改。 示例2.6，“自定义参数化类型的类型参数约束”显示了具有类型参数约束的自定义参数化类型的示例。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Example 2.6. Type argument constraint on custom parameterized typepackage org.hibernate.validator.referenceguide.chapter02.typeargument;public class Car &#123; private GearBox&lt;@MinTorque(100) Gear&gt; gearBox; public void setGearBox(GearBox&lt;Gear&gt; gearBox) &#123; this.gearBox = gearBox; &#125; //...&#125;package org.hibernate.validator.referenceguide.chapter02.typeargument;public class GearBox&lt;T extends Gear&gt; &#123; private final T gear; public GearBox(T gear) &#123; this.gear = gear; &#125; public Gear getGear() &#123; return this.gear; &#125;&#125;package org.hibernate.validator.referenceguide.chapter02.typeargument;public class Gear &#123; private final Integer torque; public Gear(Integer torque) &#123; this.torque = torque; &#125; public Integer getTorque() &#123; return torque; &#125; public static class AcmeGear extends Gear &#123; public AcmeGear() &#123; super( 100 ); &#125; &#125;&#125;package org.hibernate.validator.referenceguide.chapter02.typeargument;public class GearBoxUnwrapper extends ValidatedValueUnwrapper&lt;GearBox&gt; &#123; @Override public Object handleValidatedValue(GearBox gearBox) &#123; return gearBox == null ? null : gearBox.getGear(); &#125; @Override public Type getValidatedValueType(Type valueType) &#123; return Gear.class; &#125;&#125;Car car = Car();car.setGearBox( new GearBox&lt;&gt;( new Gear.AcmeGear() ) );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;Gear is not providing enough torque.&quot;, constraintViolations.iterator().next().getMessage() );assertEquals( &quot;gearBox&quot;, constraintViolations.iterator().next().getPropertyPath().toString() ); 2.1.4. Class-level constraintsLast but not least, a constraint can also be placed on the class level. In this case not a single property is subject of the validation but the complete object. Class-level constraints are useful if the validation depends on a correlation between several properties of an object. 最后但并非不重要的是，约束也可以放在类级别上。 在这种情况下，单个属性不是验证的主体，而是完整的对象。 如果验证取决于对象的几个属性之间的相关性，则类级别约束很有用。 The Car class in Example 2.7, “Class-level constraint” has the two attributes seatCount and passengers and it should be ensured that the list of passengers has not more entries than seats are available. For that purpose the @ValidPassengerCount constraint is added on the class level. The validator of that constraint has access to the complete Car object, allowing to compare the numbers of seats and passengers. 例2.7中的Car类，“类级约束”具有座位数和乘客的两个属性，并且应该确保乘客没有多余座位。 为此，在类级别上添加@ValidPassengerCount约束。 该约束的验证器可以访问完整的Car对象，允许比较座位和乘客的数量。 Refer to Section 6.2, “Class-level constraints” to learn in detail how to implement this custom constraint. 请参见第6.2节“类级约束”以详细了解如何实现此自定义约束。12345678910111213Example 2.7. Class-level constraintpackage org.hibernate.validator.referenceguide.chapter02.classlevel;@ValidPassengerCountpublic class Car &#123; private int seatCount; private List&lt;Person&gt; passengers; //...&#125; 2.1.5. Constraint inheritanceWhen a class implements an interface or extends another class, all constraint annotations declared on the super-type apply in the same manner as the constraints specified on the class itself. To make things clearer let’s have a look at the following example: 当类实现接口或扩展另一个类时，在超类上声明的所有约束注释都以与在类本身指定约束相同的方式应用。 为了使事情更清楚，让我们看看下面的例子：1234567891011121314151617181920212223242526272829Example 2.8. Constraint inheritancepackage org.hibernate.validator.referenceguide.chapter02.inheritance;public class Car &#123; private String manufacturer; @NotNull public String getManufacturer() &#123; return manufacturer; &#125; //...&#125;package org.hibernate.validator.referenceguide.chapter02.inheritance;public class RentalCar extends Car &#123; private String rentalStation; @NotNull public String getRentalStation() &#123; return rentalStation; &#125; //...&#125; Here the class RentalCar is a subclass of Car and adds the property rentalStation. If an instance of RentalCar is validated, not only the @NotNull constraint on rentalStation is evaluated, but also the constraint on manufacturer from the parent class. 这里类RentalCar是Car的子类，并添加了属性rentalStation。 如果验证RentalCar的实例，则不仅评估rentalStation上的@NotNull约束，而且评估父类对manufacturer的约束。 The same would be true, if Car was not a superclass but an interface implemented by RentalCar. 如果Car不是一个超类，而是一个由RentalCar实现的接口,同样的情况也是如此。 Constraint annotations are aggregated if methods are overridden. So if RentalCar overrode the getManufacturer() method from Car, any constraints annotated at the overriding method would be evaluated in addition to the @NotNull constraint from the superclass. 如果方法被覆盖，则会聚合约束注释。 因此，如果RentalCar从Car上覆盖了getManufacturer()方法，那么除了来自超类的@NotNull约束之外，还将评估在重写方法中注释的任何约束。 2.1.6. Object graphsThe Bean Validation API does not only allow to validate single class instances but also complete object graphs (cascaded validation). To do so, just annotate a field or property representing a reference to another object with @Valid as demonstrated in Example 2.9, “Cascaded validation”. Bean验证API不仅允许验证单个类实例，还允许完成对象图(级联验证)。 为此，只需使用@Valid注释表示对另一个对象的引用的字段或属性，如示例2.9“级联验证”中所示。1234567891011121314151617181920212223Example 2.9. Cascaded validationpackage org.hibernate.validator.referenceguide.chapter02.objectgraph;public class Car &#123; @NotNull @Valid private Person driver; //...&#125;package org.hibernate.validator.referenceguide.chapter02.objectgraph;public class Person &#123; @NotNull private String name; //...&#125; If an instance of Car is validated, the referenced Person object will be validated as well, as the driver field is annotated with @Valid. Therefore the validation of a Car will fail if the name field of the referenced Person instance is null. 如果Car的实例被验证，因为driver字段用@Valid注释，所以引用的Person对象也将被验证。 因此，如果引用的Person实例的名称字段为null，那么Car的验证将失败。 The validation of object graphs is recursive, i.e. if a reference marked for cascaded validation points to an object which itself has properties annotated with @Valid, these references will be followed up by the validation engine as well. The validation engine will ensure that no infinite loops occur during cascaded validation, for example if two objects hold references to each other. 对象图的验证是递归的，即如果标记为级联验证的引用指向用@Valid注释属性的对象，则验证引擎也将跟随这些引用。 验证引擎将确保在级联验证期间不发生无限循环，例如，如果两个对象保存对彼此的引用。 Note that null values are getting ignored during cascaded validation. 请注意，级联验证期间忽略空值。 Object graph validation also works for collection-typed fields. That means any attributes that 对象图验证也适用于集合类型的字段。 这意味着任何属性： are arrays implement java.lang.Iterable (especially Collection, List and Set) implement java.util.Mapcan be annotated with @Valid, which will cause each contained element to be validated, when the parent object is validated. 可以用@Valid注释，这将在验证父对象时验证每个包含的元素。123456789101112Example 2.10. Cascaded validation of a collectionpackage org.hibernate.validator.referenceguide.chapter02.objectgraph.list;public class Car &#123; @NotNull @Valid private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;(); //...&#125; So when validating an instance of the Car class shown in Example 2.10, “Cascaded validation of a collection”, a ConstraintViolation will be created, if any of the Person objects contained in the passengers list has a null name. 因此，在验证示例2.10“集合的级联验证”中显示的Car类的实例时，如果乘客列表中包含的任何Person对象具有空名称，则将创建ConstraintViolation。 2.2. Validating bean constraintsThe Validator interface is the most important object in Bean Validation. The next section shows how to obtain an Validator instance. Afterwards you’ll learn how to use the different methods of the Validator interface. Validator接口是Bean验证中最重要的对象。 下一节将介绍如何获取Validator实例。 之后，您将学习如何使用Validator接口的不同方法。 2.2.1. Obtaining a Validator instanceThe first step towards validating an entity instance is to get hold of a Validator instance. The road to this instance leads via the Validation class and a ValidatorFactory. The easiest way is to use the static method Validation#buildDefaultValidatorFactory(): 验证实体实例的第一步是获取Validator实例。 获取这个实例的路径是通过Validation类和ValidatorFactory。 最简单的方法是使用静态方法Validation＃buildDefaultValidatorFactory()：1234Example 2.11. Validation#buildDefaultValidatorFactory()ValidatorFactory factory = Validation.buildDefaultValidatorFactory();Validator validator = factory.getValidator(); This bootstraps a validator in the default configuration. Refer to Chapter 8, Bootstrapping to learn more about the different bootstrapping methods and how to obtain a specifically configured Validator instance. 这将在默认配置中引导验证程序。 有关详细信息，请参阅第8章“引导”，了解不同的引导方法以及如何获取特殊配置的Validator实例。 2.2.2. Validator methodsThe Validator interface contains three methods that can be used to either validate entire entities or just single properties of the entity. All three methods return a Set. The set is empty, if the validation succeeds. Otherwise a ConstraintViolation instance is added for each violated constraint. All the validation methods have a var-args parameter which can be used to specify, which validation groups shall be considered when performing the validation. If the parameter is not specified the default validation group (javax.validation.groups.Default) is used. The topic of validation groups is discussed in detail in Chapter 5, Grouping constraints. Validator接口包含三个方法，可用于验证整个实体或仅验证实体的单个属性。 所有三个方法都返回一个Set 。 如果验证成功，则该集合为空。 否则，为每个违反的约束添加一个约束违例实例。 所有验证方法都有一个var-args参数，可用于指定在执行验证时应考虑哪些验证组。 如果未指定参数，则使用缺省验证组(javax.validation.groups.Default)。 第5章“分组约束”中详细讨论了验证组的主题。 2.2.2.1. Validator#validate()Use the validate() method to perform validation of all constraints of a given bean. Example 2.12, “Using Validator#validate()” shows the validation of an instance of the Car class from Example 2.2, “Property-level constraints” which fails to satisfy the @NotNull constraint on the manufacturer property. The validation call therefore returns one ConstraintViolation object. 使用validate()方法来执行给定bean的所有约束的验证。 例2.12，“使用Validator＃validate()”显示来自例2.2“属性级别约束”的Car类的实例的验证，它不能满足制造商属性的@NotNull约束。 验证调用因此返回一个ConstraintViolation对象。12345678Example 2.12. Using Validator#validate()Car car = new Car( null, true );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );assertEquals( 1, constraintViolations.size() );assertEquals( &quot;may not be null&quot;, constraintViolations.iterator().next().getMessage() ); 2.2.2.2. Validator#validateProperty()With help of the validateProperty() you can validate a single named property of a given object. The property name is the JavaBeans property name. 在validateProperty()的帮助下，您可以验证给定对象的单个命名属性。 属性名称是JavaBeans属性名称。 1234567891011Example 2.13. Using Validator#validateProperty()Car car = new Car( null, true );Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty( car, &quot;manufacturer&quot;);assertEquals( 1, constraintViolations.size() );assertEquals( &quot;may not be null&quot;, constraintViolations.iterator().next().getMessage() ); 2.2.2.3. Validator#validateValue()By using the validateValue() method you can check whether a single property of a given class can be validated successfully, if the property had the specified value: 通过使用validateValue()方法，您可以检查给定类的单个属性是否可以成功验证，如果属性具有指定的值：12345678910Example 2.14. Using Validator#validateValue()Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue( Car.class, &quot;manufacturer&quot;, null);assertEquals( 1, constraintViolations.size() );assertEquals( &quot;may not be null&quot;, constraintViolations.iterator().next().getMessage() );--- Note:@Valid is not honored by validateProperty() or validateValue(). 注意：@Valid不受validateProperty()或validateValue()支持。 Validator#validateProperty() is for example used in the integration of Bean Validation into JSF 2 (see Section 10.2, “JSF &amp; Seam”) to perform a validation of the values entered into a form before they are propagated to the model. Validator＃validateProperty()例如用于将Bean验证集成到JSF 2(参见第10.2节“JSF和Seam”)中，以便在将输入到表单中的值传播到模型之前对其进行验证。 ### 2.2.3. ConstraintViolation methodsNow it is time to have a closer look at what a ConstraintViolation is. Using the different methods of ConstraintViolation a lot of useful information about the cause of the validation failure can be determined. Table 2.1, “The various ConstraintViolation methods” gives an overview of these methods. The values in the “Example” column refer to Example 2.12, “Using Validator#validate()”. 现在是时候仔细观察一下ConstraintViolation是什么。 使用ConstraintViolation的不同方法，可以确定关于验证失败的原因的许多有用信息。 表2.1，“各种约束违背方法”给出了这些方法的概述。 “示例”列中的值引用示例2.12，“Using Validator＃validate()”。Table 2.1. The various ConstraintViolation methods Method Usage Example getMessage() The interpolated error message “may not be null” getMessageTemplate() The non-interpolated error message “{…​ NotNull.message}” getRootBean() The root bean being validated car getRootBeanClass() The class of the root bean being validated Car.class getLeafBean() If a bean constraint, the bean instance the constraint is applied on; If a property constraint, the bean instance hosting the property the constraint is applied on car getPropertyPath() The property path to the validated value from root bean contains one node with kind PROPERTY and name “manufacturer” getInvalidValue() The value failing to pass the constraint null getConstraintDescriptor() Constraint metadata reported to fail descriptor for @NotNull ## 2.3. Built-in constraintsHibernate Validator comprises a basic set of commonly used constraints. These are foremost the constraints defined by the Bean Validation specification (see Table 2.2, “Bean Validation constraints”). Additionally, Hibernate Validator provides useful custom constraints (see Table 2.3, “Custom constraints” and Table 2.4, “Custom country specific constraints”). Hibernate Validator包含一组基本的常用约束。 这些首先是Bean验证规范定义的约束(见表2.2“Bean验证约束”)。 此外，Hibernate Validator提供了有用的自定义约束(见表2.3“自定义约束”和表2.4“自定义国家特定约束”)。 2.3.1. Bean Validation constraintsTable 2.2, “Bean Validation constraints” shows purpose and supported data types of all constraints specified in the Bean Validation API. All these constraints apply to the field/property level, there are no class-level constraints defined in the Bean Validation specification. If you are using the Hibernate object-relational mapper, some of the constraints are taken into account when creating the DDL for your model (see column “Hibernate metadata impact”). 表2.2“Bean验证约束”显示了Bean验证API中指定的所有约束的目的和受支持的数据类型。 所有这些约束适用于字段/属性级别，没有在Bean验证规范中定义的类级别约束。 如果使用Hibernate对象关系映射器，在为模型创建DDL时会考虑一些约束(请参阅“Hibernate元数据影响”一栏)。 Note:Hibernate Validator allows some constraints to be applied to more data types than required by the Bean Validation specification (e.g. @Max can be applied to strings). Relying on this feature can impact portability of your application between Bean Validation providers. 注意:Hibernate Validator允许将一些约束应用于Bean验证规范所要求的更多数据类型(例如@Max可以应用于字符串)。 依赖此功能可能会影响应用程序与Bean验证提供程序之间的可移植性。 Annotation Supported data types Use Hibernate metadata impact @AssertFalse Boolean, boolean Checks that the annotated element is false None @AssertTrue Boolean, boolean Checks that the annotated element is true None @DecimalMax(value=,inclusive=) BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of Number Checks whether the annotated value is less than the specified maximum, when inclusive=false. Otherwise whether the value is less than or equal to the specified maximum. The parameter value is the string representation of the max value according to the BigDecimal string representation. None @DecimalMin(value=,inclusive=) BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of Number Checks whether the annotated value is larger than the specified minimum, when inclusive=false. Otherwise whether the value is larger than or equal to the specified minimum. The parameter value is the string representation of the min value according to the BigDecimal string representation. None @Digits(integer=,fraction=) BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of Number Checks whether the annotated value is a number having up to integer digits and fraction fractional digits Defines column precision and scale @Future java.util.Date, java.util.Calendar, java.time.chrono.ChronoZonedDateTime, java.time.Instant, java.time.OffsetDateTime; Additionally supported by HV, if the Joda Time date/time API is on the class path: any implementations of ReadablePartial and ReadableInstant Checks whether the annotated date is in the future None @Max(value=) BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the character sequence is evaluated), any sub-type of Number Checks whether the annotated value is less than or equal to the specified maximum Adds a check constraint on the column @Min(value=) BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; Additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the char sequence is evaluated), any sub-type of Number Checks whether the annotated value is higher than or equal to the specified minimum Adds a check constraint on the column @NotNull Any type Checks that the annotated value is not null. Column(s) are not nullable @Null Any type Checks that the annotated value is null None @Past java.util.Date, java.util.Calendar, java.time.chrono.ChronoZonedDateTime, java.time.Instant, java.time.OffsetDateTime; Additionally supported by HV, if the Joda Time date/time API is on the class path: any implementations of ReadablePartial and ReadableInstant Checks whether the annotated date is in the past None @Pattern(regex=,flag=) CharSequence Checks if the annotated string matches the regular expression regex considering the given flag match None @Size(min=, max=) CharSequence, Collection, Map and arrays Checks if the annotated element’s size is between min and max (inclusive) Column length will be set to max @Valid Any non-primitive type Performs validation recursively on the associated object. If the object is a collection or an array, the elements are validated recursively. If the object is a map, the value elements are validated recursively. None Note:On top of the parameters indicated in Table 2.2, “Bean Validation constraints” each constraint has the parameters message, groups and payload. This is a requirement of the Bean Validation specification. 注意：除了表2.2“Bean验证约束”中指示的参数之外，每个约束都有参数message，groups和payload。 这是Bean验证规范的要求。 2.3.2. Additional constraintsIn addition to the constraints defined by the Bean Validation API Hibernate Validator provides several useful custom constraints which are listed in Table 2.3, “Custom constraints”. With one exception also these constraints apply to the field/property level, only @ScriptAssert is a class- level constraint. 除了Bean Validation API定义的约束外，Hibernate Validator还提供了几个有用的自定义约束，如表2.3“自定义约束”中所列。 有一个例外，这些约束适用于字段/属性级别，只有@ScriptAssert是类级别约束。 Table 2.3. Custom constraints| Annotation | Supported data types | Use | Hibernate metadata impact ||————|:——————–:|:—:|————————–:|| @CreditCardNumber(ignoreNonDigitCharacters=) | CharSequence | Checks that the annotated character sequence passes the Luhn checksum test. Note, this validation aims to check for user mistakes, not credit card validity! See also Anatomy of Credit Card Numbers. ignoreNonDigitCharacters allows to ignore non digit characters. The default is false. | None || @EAN | CharSequence | Checks that the annotated character sequence is a valid EAN barcode. type determines the type of barcode. The default is EAN-13. | None || @Email | CharSequence | Checks whether the specified character sequence is a valid email address. The optional parameters regexp and flags allow to specify an additional regular expression (including regular expression flags) which the email must match. | None || @Length(min=,max=) | CharSequence | Validates that the annotated character sequence is between min and max included | Column length will be set to max || @LuhnCheck(startIndex= ,endIndex=,checkDigitIndex=,ignoreNonDigitCharacters=) | CharSequence | Checks that the digits within the annotated character sequence pass the Luhn checksum algorithm (see also Luhn algorithm). startIndex and endIndex allow to only run the algorithm on the specified sub-string. checkDigitIndex allows to use an arbitrary digit within the character sequence as the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, ignoreNonDigitCharacters allows to ignore non digit characters. | None || @Mod10Check(multiplier=,weight=,startIndex=,endIndex=,checkDigitIndex=,ignoreNonDigitCharacters=) | CharSequence | Checks that the digits within the annotated character sequence pass the generic mod 10 checksum algorithm. multiplier determines the multiplier for odd numbers (defaults to 3), weight the weight for even numbers (defaults to 1). startIndex and endIndex allow to only run the algorithm on the specified sub-string. checkDigitIndex allows to use an arbitrary digit within the character sequence as the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, ignoreNonDigitCharacters allows to ignore non digit characters. | None || @Mod11Check(threshold=,startIndex=,endIndex=,checkDigitIndex=,ignoreNonDigitCharacters=,treatCheck10As=,treatCheck11As=) | CharSequence | Checks that the digits within the annotated character sequence pass the mod 11 checksum algorithm. threshold specifies the threshold for the mod11 multiplier growth; if no value is specified the multiplier will grow indefinitely. treatCheck10As and treatCheck11As specify the check digits to be used when the mod 11 checksum equals 10 or 11, respectively. Default to X and 0, respectively. startIndex, endIndex checkDigitIndex and ignoreNonDigitCharacters carry the same semantics as in @Mod10Check. | None || @NotBlank | CharSequence | Checks that the annotated character sequence is not null and the trimmed length is greater than 0. The difference to @NotEmpty is that this constraint can only be applied on strings and that trailing white-spaces are ignored. | None || @NotEmpty | CharSequence, Collection, Map and arrays | Checks whether the annotated element is not null nor empty | None || @Range(min=,max=) | BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types | Checks whether the annotated value lies between (inclusive) the specified minimum and maximum | None || @SafeHtml(whitelistType= ,additionalTags=,additionalTagsWithAttributes=) | CharSequence | Checks whether the annotated value contains potentially malicious fragments such as . In order to use this constraint, the jsoup library must be part of the class path. With the whitelistType attribute a predefined whitelist type can be chosen which can be refined via additionalTags or additionalTagsWithAttributes. The former allows to add tags without any attributes, whereas the latter allows to specify tags and optionally allowed attributes using the annotation @SafeHtml.Tag. | None || @ScriptAssert(lang=,script=,alias=) | Any type | Checks whether the given script can successfully be evaluated against the annotated element. In order to use this constraint, an implementation of the Java Scripting API as defined by JSR 223 (“Scripting for the JavaTM Platform”) must part of the class path. The expressions to be evaluated can be written in any scripting or expression language, for which a JSR 223 compatible engine can be found in the class path. | None || @URL(protocol=,host=,port=,regexp=,flags=) | CharSequence | Checks if the annotated character sequence is a valid URL according to RFC2396. If any of the optional parameters protocol, host or port are specified, the corresponding URL fragments must match the specified values. The optional parameters regexp and flags allow to specify an additional regular expression (including regular expression flags) which the URL must match. Per default this constraint used the java.net.URL constructor to verify whether a given string represents a valid URL. A regular expression based version is also available - RegexpURLValidator - which can be configured via XML (see Section 7.2, “Mapping constraints via constraint-mappings”) or the programmatic API (see Section 11.14.2, “Adding constraint definitions programmatically”). | None | 2.3.2.1. Country specific constraintsHibernate Validator offers also some country specific constraints, e.g. for the validation of social security numbers. Hibernate验证器还提供一些国家特定的约束，例如。 用于验证社会保障号码。 Note:If you have to implement a country specific constraint, consider making it a contribution to Hibernate Validator! 注意：如果你必须实现一个国家特定的约束，考虑使它成为Hibernate验证器的一个贡献！ Table 2.4. Custom country specific constraints Annotation Supported data types Use Country Hibernate metadata impact @CNPJ CharSequence Checks that the annotated character sequence represents a Brazilian corporate tax payer registry number (Cadastro de Pessoa Juríeddica) Brazil None @CPF CharSequence Checks that the annotated character sequence represents a Brazilian individual taxpayer registry number (Cadastro de Pessoa Fídsica) Brazil None @TituloEleitoral CharSequence Checks that the annotated character sequence represents a Brazilian voter ID card number (Título Eleitoral) Brazil None TipIn some cases neither the Bean Validation constraints nor the custom constraints provided by Hibernate Validator will fulfill your requirements. In this case you can easily write your own constraint. You can find more information in Chapter 6, Creating custom constraints. 提示：在某些情况下，Bean验证约束和Hibernate Validator提供的自定义约束都不能满足您的要求。 在这种情况下，您可以轻松地编写自己的约束。 您可以在第6章“创建自定义约束”中找到更多信息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate Validator官方文档 -- 第1章]]></title>
      <url>%2F2016%2F11%2F10%2FHibernate%20Validator%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3--%E7%AC%AC1%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[Hibernate Validator官方文档 – 第1章 入门 1. Getting started1.1. Project set upIn order to use Hibernate Validator within a Maven project, simply add the following dependency to your pom.xml:12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.2.Final&lt;/version&gt;&lt;/dependency&gt; 1.1.1. Unified ELHibernate Validator requires an implementation of the Unified Expression Language (JSR 341) for evaluating dynamic expressions in constraint violation messages (see Section 4.1, “Default message interpolation”). When your application runs in a Java EE container such as JBoss AS, an EL implementation is already provided by the container. In a Java SE environment, however, you have to add an implementation as dependency to your POM file. For instance you can add the following two dependencies to use the JSR 341 reference implementation: Hibernate Validator需要实现统一表达式语言(JSR 341)来评估约束违反消息中的动态表达式(参见第4.1节“默认消息插值”)。 当应用程序在Java EE容器(如JBoss AS)中运行时，容器已经提供了EL实现。 但在Java SE环境中，您必须将实现作为依赖关系添加到POM文件中。 例如，您可以添加以下两个依赖关系来使用JSR 341参考实现：12345678910&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt; 1.1.2. CDIBean Validation defines integration points with CDI (Contexts and Dependency Injection for Java TM EE, JSR 346). If your application runs in an environment which does not provide this integration out of the box, you may use the Hibernate Validator CDI portable extension by adding the following Maven dependency to your POM: Bean验证使用CDI(Java TM EE，JSR 346的上下文和依赖注入)定义集成点。 如果您的应用程序在一个不提供此集成的环境中运行，您可通过添Maven依赖使用Hibernate Validator CDI便携式扩展:12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-cdi&lt;/artifactId&gt; &lt;version&gt;5.3.2.Final&lt;/version&gt;&lt;/dependency&gt; Note that adding this dependency is usually not required for applications running on a Java EE application server. You can learn more about the integration of Bean Validation and CDI in Section 10.3, “CDI”. 请注意，通常不需要在Java EE应用程序服务器上运行的应用程序添加此依赖关系。 您可以在第10.3节“CDI”中了解有关Bean验证和CDI的集成的更多信息。1.1.3. Running with a security managerHibernate Validator supports running with a security manager being enabled. To do so, you must assign several permissions to the Hibernate Validator and the Bean Validation API code bases. The following shows how to do this via a policy file as processed by the Java default policy implementation: Hibernate Validator支持在启用安全管理器的情况下运行。 为此，您必须为Hibernate验证器和Bean验证API代码库分配多个权限。 下面显示了如何通过Java默认策略实现处理的策略文件执行此操作：1234567891011grant codeBase &quot;file:path/to/hibernate-validator-5.3.2.Final.jar&quot; &#123; permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;; permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;; // Only needed when working with XML descriptors (validation.xml or XML constraint mappings) permission java.util.PropertyPermission &quot;mapAnyUriToUri&quot;, &quot;read&quot;;&#125;;grant codeBase &quot;file:path/to/validation-api-1.1.0.Final.jar&quot; &#123; permission java.io.FilePermission &quot;path/to/hibernate-validator-5.3.2.Final.jar&quot;, &quot;read&quot;;&#125;; 1.2. Applying constraint 应用约束Lets dive directly into an example to see how to apply constraints. 让我们直接实现一个例子，看看如何应用约束。1234567891011121314151617181920212223242526package org.hibernate.validator.referenceguide.chapter01;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;public class Car &#123; @NotNull private String manufacturer; @NotNull @Size(min = 2, max = 14) private String licensePlate; @Min(2) private int seatCount; public Car(String manufacturer, String licencePlate, int seatCount) &#123; this.manufacturer = manufacturer; this.licensePlate = licencePlate; this.seatCount = seatCount; &#125; //getters and setters ...&#125; The @NotNull, @Size and @Min annotations are used to declare the constraints which should be applied to the fields of a Car instance: @NotNull，@Size和@Min注释用于声明应该应用于Car实例的字段的约束： manufacturer must never be null 制造商不能为空 licensePlate must never be null and must be between 2 and 14 characters long 车牌照不为长度在2~14之间 seatCount must be at least 2 座位至少有两个1.3. Validating constraints 验证约束To perform a validation of these constraints, you use a Validator instance. Let’s have a look at a unit test for Car: 要执行这些约束的验证，您需要使用一个Validator实例。 让我们来看看汽车的单元测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.hibernate.validator.referenceguide.chapter01;import java.util.Set;import javax.validation.ConstraintViolation;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.ValidatorFactory;import org.junit.BeforeClass;import org.junit.Test;import static org.junit.Assert.assertEquals;public class CarTest &#123; private static Validator validator; @BeforeClass public static void setUpValidator() &#123; ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); validator = factory.getValidator(); &#125; @Test public void manufacturerIsNull() &#123; Car car = new Car( null, &quot;DD-AB-123&quot;, 4 ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car ); assertEquals( 1, constraintViolations.size() ); assertEquals( &quot;may not be null&quot;, constraintViolations.iterator().next().getMessage() ); &#125; @Test public void licensePlateTooShort() &#123; Car car = new Car( &quot;Morris&quot;, &quot;D&quot;, 4 ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car ); assertEquals( 1, constraintViolations.size() ); assertEquals( &quot;size must be between 2 and 14&quot;, constraintViolations.iterator().next().getMessage() ); &#125; @Test public void seatCountTooLow() &#123; Car car = new Car( &quot;Morris&quot;, &quot;DD-AB-123&quot;, 1 ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car ); assertEquals( 1, constraintViolations.size() ); assertEquals( &quot;must be greater than or equal to 2&quot;, constraintViolations.iterator().next().getMessage() ); &#125; @Test public void carIsValid() &#123; Car car = new Car( &quot;Morris&quot;, &quot;DD-AB-123&quot;, 2 ); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car ); assertEquals( 0, constraintViolations.size() ); &#125;&#125; In the setUp() method a Validator object is retrieved from the ValidatorFactory. A Validator instance is thread-safe and may be reused multiple times. It thus can safely be stored in a static field and be used in the test methods to validate the different Car instances. The validate() method returns a set of ConstraintViolation instances, which you can iterate over in order to see which validation errors occurred. The first three test methods show some expected constraint violations: The @NotNull constraint on manufacturer is violated in manufacturerIsNull() The @Size constraint on licensePlate is violated in licensePlateTooShort() The @Min constraint on seatCount is violated in seatCountTooLow() If the object validates successfully, validate() returns an empty set as you can see in carIsValid().Note that only classes from the package javax.validation are used. These are provided from the Bean Validation API. No classes from Hibernate Validator are directly referenced, resulting in portable code. 在setUp()方法中，从ValidatorFactory取出Validator对象。 Validator实例是线程安全的，可以重复使用多次。 因此它可以安全地存储在静态字段中，并在测试方法中用于验证不同的Car实例。 validate()方法返回一组ConstraintViolation实例，您可以迭代它们以查看发生了哪些验证错误。 前三个测试方法显示一些预期的约束违反： The @NotNull constraint on manufacturer is violated in manufacturerIsNull() The @Size constraint on licensePlate is violated in licensePlateTooShort() The @Min constraint on seatCount is violated in seatCountTooLow() 如果对象验证成功，validate()返回一个空的set集合，你可以在carIsValid()中看到。注意，这我们只使用包javax.validation中的类。 他们是Bean Validation API提供的。没有直接引用来自Hibernate Validator的类，所以可移植代码。 1.4. Java 8 supportJava 8 introduces several enhancements which are valuable from a Hibernate Validator point of view. This section briefly introduces the Hibernate Validator features based on Java 8. They are only available in Hibernate Validator 5.2 and later. Java 8引入了几个从Hibernate Validator的角度来看有价值的增功能。 本节简要介绍基于Java 8的Hibernate Validator功能。它们仅在Hibernate Validator 5.2和更高版本中可用。 1.4.1. Type arguments constraintsIn Java 8 it is possible to use annotations in any location a type is used. This includes type arguments. Hibernate Validator supports the validation of constraints defined on type arguments of collections, maps, and custom parameterized types. The Section 2.1.3, “Type argument constraints” chapter provides further information on how to apply and use type argument constraints. 在Java 8中，可以在使用类型的任何位置使用注释。 这包括类型参数。 Hibernate Validator支持对集合，Map和自定义参数化类型等类型参数的约束验证。 第2.1.3节“类型参数约束”一章提供了有关如何应用和使用类型参数约束的更多信息。 1.4.2. Actual parameter namesThe Java 8 Reflection API can now retrieve the actual parameter names of a method or constructor. Hibernate Validator uses this ability to report the actual parameter names instead of arg0, arg1, etc. The Section 8.2.4, “ParameterNameProvider” chapter explains how to use the new reflection based parameter name provider. Java 8反射API可以检索方法或构造函数的实际参数名称。 Hibernate Validator可使用此功能显示实际的参数名称而不是arg0，arg1等。第8.2.4节“ParameterNameProvider”一章解释了如何使用基于新反射提供的参数名称提供程序。 1.4.3. New date/time APIJava 8 introduces a new date/time API. Hibernate Validator provides full support for the new API where @Future and @Past constraints can be applied on the new types. The table Table 2.2, “Bean Validation constraints” shows the types supported for @Future and @Past, including the types from the new API. Java 8引入了一个新的日期/时间API。 Hibernate Validator提供对新API的完全支持，其中@Future和@Past约束可以应用于新类型。 表2.2“Bean验证约束”显示了@Future和@Past支持的类型，包括来自新API的类型。 1.4.4. Optional typeHibernate Validator provides also support for Java 8 Optional type, by unwrapping the Optional instance and validating the internal value. Section 11.13.1, “Optional unwrapper” provides examples and a further discussion. Hibernate Validator还通过解包可选实例并验证内部值提供对Java 8可选类型的支持。 第11.13.1节“可选解包器”提供了示例和进一步讨论。 1.5. Where to go next?That concludes the 5 minute tour through the world of Hibernate Validator and Bean Validation. Continue exploring the code examples or look at further examples referenced in Chapter 13, Further reading. To learn more about the validation of beans and properties, just continue reading Chapter 2, Declaring and validating bean constraints. If you are interested in using Bean Validation for the validation of method pre- and postcondition refer to Chapter 3, Declaring and validating method constraints. In case your application has specific validation requirements have a look at Chapter 6, Creating custom constraints. 至此Hibernate Validator和Bean Validation世界的5分钟旅游结束。可继续探索代码示例或进一步阅读第13章中提及的更多示例。 要了解有关bean和属性验证的更多信息，只需继续阅读第2章声明和验证bean约束。 如果您有兴趣使用Bean验证来验证方法的前后条件，请参考第3章声明和验证方法约束。 如果您的应用程序有特定的验证要求，请参阅第6章创建自定义约束。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Velocity用户手册]]></title>
      <url>%2F2016%2F11%2F06%2FVelocity%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C%2F</url>
      <content type="text"><![CDATA[Velocity用户手册 (Version:1.7) 原文 What is Velocity? 什么是Velocity?Velocity is a Java-based template engine. It permits web page designers to reference methods defined in Java code. Web designers can work in parallel with Java programmers to develop web sites according to the Model-View-Controller (MVC) model, meaning that web page designers can focus solely on creating a well-designed site, and programmers can focus solely on writing top-notch code. Velocity separates Java code from the web pages, making the web site more maintainable over the long run and providing a viable alternative to Java Server Pages (JSPs) or PHP. Velocity是一个基于Java的模板引擎。 它允许网页设计者引用在Java代码中定义的方法。 网页设计师可以与Java程序员根据MVC模型同时开发网站，这意味着网页设计者可以专注于精心设计网站，程序员可以专注于写top-notch代码。 Velocity将Java代码与网页分离，使网站更易于维护，并为Java Server Pages（JSP）或PHP提供了替代方案。 Velocity can be used to generate web pages, SQL, PostScript and other output from templates. It can be used either as a standalone utility for generating source code and reports, or as an integrated component of other systems. When complete, Velocity will provide template services for the Turbine web application framework. Velocity+Turbine will provide a template service that will allow web applications to be developed according to a true MVC model. Velocity可以使用模板生成网页，SQL，PostScript等。 它可以用作生成源代码和报告的独立实用程序，也可以用作其他系统的集成组件。 完成后，Velocity将为Turbine Web应用程序框架提供模板服务。 Velocity + Turbine将提供一个模板服务，允许根据MVC模型开发Web应用程序。 What can Velocity do for me? Velocity能做什么The Mud Store Example Mud 商店实例Velocity Template Language (VTL): An Introduction Velocity模板语言 (VTL): 简介VTL uses references to embed dynamic content in a web site, and a variable is one type of reference. Variables are one type of reference that can refer to something defined in the Java code, or it can get its value from a VTL statement in the web page itself. Here is an example of a VTL statement that could be embedded in an HTML document: VTL使用引用动态将内容嵌入到网站中，变量也是一种类型的引用，它可以引用在Java代码中定义的东西，也可以从网页本身的VTL语句获得值。 下面是可以嵌入到HTML文档中的VTL语句的示例：1#set( $a = &quot;Velocity&quot; ) This VTL statement, like all VTL statements, begins with the # character and contains a directive: set. When an online visitor requests your web page, the Velocity Templating Engine will search through your web page to find all # characters, then determine which mark the beginning of VTL statements, and which of the # characters that have nothing to do with VTL. 这个VTL语句和所有VTL语句一样，以＃字符开头，并包含一条指令：set。 当在线访问者请求您的网页时，Velocity模板引擎将搜索您的网页查找所有＃个字符，然后确定哪个标记是VTL语句的开头，哪个是与VTL无关的＃个字符。 The # character is followed by a directive, set. The set directive uses an expression (enclosed in brackets) – an equation that assigns a value to a variable. The variable is listed on the left hand side and its value on the right hand side; the two are separated by an = character. ＃字符后面是一个指令，set。 set指令使用一个表达式（括在括号中） – 一个变量的赋值语句。 变量在左侧列出，其值在右侧; 两个用=字符分隔。 The following rule of thumb may be useful to better understand how Velocity works: References begin with $ and are used to get something. Directives begin with # and are used to do something. 下面的规则可能有助于更好地理解Velocity的工作：引用以$开头，用于获取值。 指令以＃开头，用于设置值。 In the example above, #set is used to assign a value to a variable. The variable, $a, can then be used in the template to output “Velocity”. 在上面的示例中，#set用于为变量赋值。 然后可以在模板中使用$a输出“Velocity”。 Hello Velocity World! Velocity简单实例:Hello Velocity World123456&lt;html&gt; &lt;body&gt; #set( $foo = &quot;Velocity&quot; ) Hello $foo World! &lt;/body&gt;&lt;/html&gt; The result is a web page that prints “Hello Velocity World!”. 网页将会输出”Hello Velocity World!” To make statements containing VTL directives more readable, we encourage you to start each VTL statement on a new line, although you are not required to do so. The set directive will be revisited in greater detail later on. 为了使包含VTL指令的语句更具可读性，建议在新行上写每个VTL语句。 稍后将更详细地重新讨论set指令。 Comments 注释1## This is a single line comment. A single line comment begins with ## and finishes at the end of the line. If you’re going to write a few lines of commentary, there’s no need to have numerous single line comments. Multi-line comments, which begin with # and end with #, are available to handle this scenario. 单行注释以##开头，并在行末尾结束。 如果你要写几行评论，没有必要写大量的单行注释。 多行注释以＃开始，以＃结束。12345678910This is text that is outside the multi-line comment.Online visitors can see it.#* Thus begins a multi-line comment. Online visitors won&apos;t see this text because the Velocity Templating Engine will ignore it.*#Here is text outside the multi-line comment; it is visible. Here are a few examples to clarify how single line and multi-line comments work: 可以用下面几个例子来说明单行和多行注释的工作：1234567This text is visible. ## This text is not.This text is visible.This text is visible. #* This text, as part of a multi-linecomment, is not visible. This text is not visible; it is alsopart of the multi-line comment. This text still notvisible. *# This text is outside the comment, so it is visible.## This text is not visible. There is a third type of comment, the VTL comment block, which may be used to store any sort of extra information you want to track in the template (e.g. javadoc-style author and versioning information): 还有第三种注释类型，VTL注释块，用于存储您要在模板中跟踪的任何类型的额外信息（例如javadoc样式的作者和版本控制信息）：12345678#** This is a VTL comment block and may be used to store such information as the document author and versioning information: @author John Doe @version 5*# References 引用There are three types of references in the VTL: variables, properties and methods. As a designer using the VTL, you and your engineers must come to an agreement on the specific names of references so you can use them correctly in your templates. 在VTL中有三种类型的引用：变量，属性和方法。 作为使用VTL的设计人员，您和您的工程师必须就引用的名称达成一致，以便您可以在模板中正确使用它们。 Variables 变量The shorthand notation of a variable consists of a leading “$” character followed by a VTL Identifier. A VTL Identifier must start with an alphabetic character (a .. z or A .. Z). The rest of the characters are limited to the following types of characters: 变量由一个前导的“$”字符和一个VTL标识符组成。 VTL标识符必须以字母字符（a .. z或A .. Z）开头。 其余字符限于以下类型的字符： 字母 (a .. z, A .. Z) 数字 (0 .. 9) 下划线Properties 属性The second flavor of VTL references are properties, and properties have a distinctive format. The shorthand notation consists of a leading $ character followed a VTL Identifier, followed by a dot character (“.”) and another VTL Identifier. These are examples of valid property references in the VTL: VTL引用的第二种类型是属性,并且属性具有不同的格式。 由$字符后的VTL标识符,后跟一个点字符(“.”)和另一个VTL标识符。 例如： 12$customer.Address$purchase.Total Take the first example, $customer.Address. It can have two meanings. It can mean, Look in the hashtable identified as customer and return the value associated with the key Address. But $customer.Address can also be referring to a method (references that refer to methods will be discussed in the next section); $customer.Address could be an abbreviated way of writing $customer.getAddress(). When your page is requested, Velocity will determine which of these two possibilities makes sense, and then return the appropriate value. 第一个例子,$customer.Address,可以有两种含义： 查找标识为customer的散列表,并返回与key ‘Address’相关联的值。 也可以是引用一个方法, $customer.Address可以是$customer.getAddress()的缩写。 当请求您的页面时,Velocity将确定这两种可能性中的哪一种是有意义的,然后返回适当的值。 Methods 方法A method is defined in the Java code and is capable of doing something useful, like running a calculation or arriving at a decision. Methods are references that consist of a leading “$” character followed a VTL Identifier, followed by a VTL Method Body. A VTL Method Body consists of a VTL Identifier followed by an left parenthesis character (“(“), followed by an optional parameter list, followed by right parenthesis character (“)”). These are examples of valid method references in the VTL: 在Java中,定义一个方法,它能够做一些有用的事情,比如运行计算或者做出决定。VTL中,方法由“$”字符加VTL标识符,后跟VTL方法体组成。 VTL方法体包括一个VTL标识符,后跟一对括号”()”,括号中是可选参数列表。例如：1234$customer.getAddress()$purchase.getTotal()$page.setTitle( &quot;My Home Page&quot; )$person.setAttributes( [&quot;Strange&quot;, &quot;Weird&quot;, &quot;Excited&quot;] ) The first two examples – $customer.getAddress() and $purchase.getTotal() – may look similar to those used in the Properties section above, $customer.Address and $purchase.Total. If you guessed that these examples must be related some in some fashion, you are correct! 前两个示例–$customer.getAddress()和$purchase.getTotal(),可能类似于上面的Properties(属性)部分中使用的$customer.Address和$ purchase.Total。 VTL Properties can be used as a shorthand notation for VTL Methods. The Property $customer.Address has the exact same effect as using the Method $customer.getAddress(). It is generally preferable to use a Property when available. The main difference between Properties and Methods is that you can specify a parameter list to a Method. VTL属性可以用作VTL方法的缩写。 属性$customer.Address与使用方法$customer.getAddress()有完全相同的效果。一般情况下,属性可用时建议使用属性。 属性和方法之间的主要区别是您可以为方法指定参数列表。 We might expect these methods to return the names of planets belonging to the sun, feed our earthworm, or get a photograph from an album. Only the long notation works for the following Methods. 如果我们期望一些方法返回属于太阳系的行星的名称,喂我们的蚯蚓,或者从相册中获取照片。12345678$sun.getPlanet( [&quot;Earth&quot;, &quot;Mars&quot;, &quot;Neptune&quot;] )## Can&apos;t pass a parameter list with $sun.Planets$sisyphus.pushRock()## Velocity assumes I mean $sisyphus.getRock()$book.setTitle( &quot;Homage to Catalonia&quot; )## Can&apos;t pass a parameter All array references are treated as if they are fixed-length lists. This means that you can call java.util.List methods and properties on array references. So, if you have a reference to an array (let’s say this one is a String[] with three values), you can do: 所有数组引用都被看作固定长度的列表。这意味着你可以在数组引用中调用java.util.List的方法和属性。 所以,如果你有一个数组的引用myarray(我们约定这是个有三个值String[]),你可以：1234567$myarray.isEmpty() or $myarray.empty$myarray.size()$myarray.get(2)$myarray.set(1, &apos;test&apos;) Velocity also supports vararg methods. A method like azpublic void setPlanets(String... planets) or even just public void setPlanets(String[] planets) can now accept any number of arguments when called in a template. Velocity还支持可变参数的方法。例如azpublic void setPlanets(String... planets)或者public void setPlanets(String[] planets)方法可以在调用时接受任意数量的参数。1234567$sun.setPlanets(&apos;Earth&apos;, &apos;Mars&apos;, &apos;Neptune&apos;)$sun.setPlanets(&apos;Mercury&apos;)$sun.setPlanets()## Will just pass in an empty, zero-length array## 仅传入一个空的,零长度的数组 As of Velocity 2.0, method calls now provides implicit conversions between all Java basic builtin types: numbers, booleans and strings. 从Velocity 2.0开始,方法调用提供所有Java基本内置类型之间的隐式转换：数字,布尔值和字符串。 Property Lookup Rules 属性查找规则As was mentioned earlier, properties often refer to methods of the parent object. Velocity is quite clever when figuring out which method corresponds to a requested property. It tries out different alternatives based on several established naming conventions. The exact lookup sequence depends on whether or not the property name starts with an upper-case letter. For lower-case names, such as $customer.address, the sequence is 前面说过,属性通常引用父对象的方法。当找出哪个方法对应请求的属性时,Velocity是相当聪明的。它基于几种命名约定尝试不同的替代方案。确切的查找顺序取决于属性名称是否以大写字母开头。 对于小写的名称,例如$customer.address,顺序是 getaddress() getAddress() get(“address”) isAddress() For upper-case property names like $customer.Address, it is slightly different: 对于大写的属性名称,如$customer.Address,它稍有不同： getAddress() getaddress() get(“Address”) isAddress()Rendering 展示The final value resulting from each and every reference (whether variable, property, or method) is converted to a String object when it is rendered into the final output. If there is an object that represents $foo (such as an Integer object), then Velocity will call its .toString() method to resolve the object into a String. 每个引用(无论是变量,属性或方法),它们的值在最终输出展示时都将转换为String对象。 如果有一个$foo的对象(如Integer对象),Velocity将调用它的.toString()方法来将对象解析成一个String。 Index Notation 索引符号Using the notation of the form $foo[0] can be used to access a given index of an object. This form is synonymous with calling the get(Object) method on a given object i.e, $foo.get(0), and provides essentially a syntactic shorthand for such operations. Since this simply calls the get method all of the following are valid uses: 使用$foo[0]形式的符号可以用来访问对象给定的索引。这种形式与在给定对象(即$foo.get(0))上调用get(Object)方法同义,且为这样的操作提供了基本的句法简写。由于这只是调用get方法,所以下面的都是有效的用法：123$foo[0] ## $foo takes in an Integer look up$foo[$i] ## Using another reference as the index $foo[&quot;bar&quot;] ## Passing a string where $foo may be a Map The bracketed syntax also works with Java arrays since Velocity wraps arrays in an access object that provides a get(Integer) method which returns the specified element. 括号式语法也适用于Java数组,因为Velocity在访问提供了get(Integer)方法来返回指定元素的对象时会包装数组。 The bracketed syntax is valid anywhere .get is valid, for example: 括号式语法在任何.get有效的地方都是有效的,例如：123$foo.bar[1].junk$foo.callMethod()[1]$foo[&quot;apple&quot;][4] A reference can also be set using index notation, for example: 引用赋值也可以使用索引符号,例如：123#set($foo[0] = 1)#set($foo.bar[1] = 3)#set($map[&quot;apple&quot;] = &quot;orange&quot;) The specified element is set with the given value. Velocity tries first the ‘set’ method on the element, then ‘put’ to make the assignment. 使用给定的值对指定的元素赋值。Velocity首先尝试元素上的“set”方法,然后“put”进行赋值。 Formal Reference Notation 正式引用标识符Shorthand notation for references was used for the examples listed above, but there is also a formal notation for references, which is demonstrated below: 上面列出的示例使用了简写符号,但是还存在正式符号,如下所示：123$&#123;mudSlinger&#125;$&#123;customer.Address&#125;$&#123;purchase.getTotal()&#125; In almost all cases you will use the shorthand notation for references, but in some cases the formal notation is required for correct processing. 几乎在所有情况下,您都可以使用简写符号的引用,但在某些情况下,需要正式符号才能进行正确处理。 Suppose you were constructing a sentence on the fly where $vice was to be used as the base word in the noun of a sentence. The goal is to allow someone to choose the base word and produce one of the two following results: “Jack is a pyromaniac.” or “Jack is a kleptomaniac.”. Using the shorthand notation would be inadequate for this task. Consider the following example: 假设你使用$vice作为句子名词中的基本单词来动态的构造一个句子。目标是允许选择基本词,并产生以下两个结果之一：“杰克是一个pyromaniac,或“杰克是kleptomaniac”。使用简写符号将不足以完成这项任务。考虑下面的例子：1Jack is a $vicemaniac. There is ambiguity here, and Velocity assumes that $vicemaniac, not $vice, is the Identifier that you mean to use. Finding no value for $vicemaniac, it will return $vicemaniac. Using formal notation can resolve this problem. 这里有歧义,Velocity假定您要使用的标识符是$vicemaniac,而不是$vice。发现没有为$vicemaniac找到值,它将返回$vicemaniac。使用正式符号可以解决这个问题。1Jack is a $&#123;vice&#125;maniac. Now Velocity knows that $vice, not $vicemaniac, is the reference. Formal notation is often useful when references are directly adjacent to text in a template. 现在Velocity知道引用$vice,不是$vicemaniac。 当引用与模板中的文本直接相邻时,正式符号通常很有用。 Quiet Reference Notation 静态引用标识符When Velocity encounters an undefined reference, its normal behavior is to output the image of the reference. For example, suppose the following reference appears as part of a VTL template. 当Velocity遇到没有定义的引用时,它通常会输出引用的镜像。例如,假设以下引用显示是VTL模板的一部分。 1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$email&quot;/&gt; When the form initially loads, the variable reference $email has no value, but you prefer a blank text field to one with a value of “$email”. Using the quiet reference notation circumvents Velocity’s normal behavior; instead of using $email in the VTL you would use $!email. So the above example would look like the following: 当表单初始加载时,变量引用$email没有值,如果你更喜欢使用空值作为“$email”的值,那么可以使用静态引用符来规避Velocity的正常行为;在VTL中使用$!email替代$email。所以上面的例子看起来像下面这样：1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$!email&quot;/&gt; Now when the form is initially loaded and $email still has no value, an empty string will be output instead of “$email”. 现在,当表单初始加载并且$email仍然没有值时,将输出一个空字符串,而不是“$email”。 Formal and quiet reference notation can be used together, as demonstrated below. 正式和静态的引用符可以一起使用,如下所示。1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$!&#123;email&#125;&quot;/&gt; Strict Reference Mode 严格引用模式Velocity 1.6 introduces the concept of strict reference mode which is activated by setting the velocity configuration property ‘runtime.references.strict’ to true. The general intent of this setting is to make Velocity behave more strictly in cases that are undefined or ambiguous, similar to a programming language, which may be more appropriate for some uses of Velocity. In such undefined or ambiguous cases Velocity will throw an exception. The following discussion outlines the cases in which strict behavior is different from traditional behavior. Velocity 1.6引入了严格引用模式的概念,可以通过将velocity配置属性“runtime.references.strict”设置为true来激活它。 这个设置一般是使Velocity在未定义或不明确的情况下类似于编程语言一样严格地运行,这可能使Velocity在一些用途下更适合。在未定义或不明确的情况下,Velocity将抛出异常。以下讨论概述了严格行为不同于传统行为的情况。 With this setting references are required to be either placed explicitly into the context or defined with a #set directive or Velocity will throw an exception. References that are in the context with a value of null will not produce an exception. Additionally, if an attempt is made to call a method or a property on an object within a reference that does not define the specified method or property then Velocity will throw an exception. This is also true if there is an attempt to call a method or property on a null value. 使用此设置,引用需要显式地放置到上下文中或使用#set指令定义,否则Velocity将抛出异常。在上下文中值为null的引用不会产生异常。此外,如果试图调用未定义指定方法或属性的对象引用上的方法或属性,那么Velocity将抛出异常。如果试图在空值上调用方法或属性,这也是正确的。 In the following examples $bar is defined but $foo is not, and all these statements will throw an exception: 在下面的例子中,定义了$bar,但$foo未定义,所以下面这些语句都会抛出异常： 1234$foo ## Exception#set($bar = $foo) ## Exception#if($foo == $bar)#end ## Exception#foreach($item in $foo)#end ## Exception Also, The following statements show examples in which Velocity will throw an exception when attempting to call methods or properties that do not exist. In these examples $bar contains an object that defines a property ‘foo’ which returns a string, and ‘retnull’ which returns null. 另外,以下语句是Velocity在尝试调用不存在的方法或属性时抛出异常的示例。在这些示例中,$bar包含一个对象,该对象定义了返回字符串的属性“foo”和返回null的“retnull”。123$bar.bogus ## $bar does not provide property bogus, Exception$bar.foo.bogus ## $bar.foo does not provide property bogus, Exception$bar.retnull.bogus ## cannot call a property on null, Exception&lt;/pre&gt; In general strict reference behavior is true for all situations in which references are used except for a special case within the #if directive. If a reference is used within a #if or #elseif directive without any methods or properties, and if it is not being compared to another value, then undefined references are allowed. This behavior provides an easy way to test if a reference is defined before using it in a template. In the following example where $foo is not defined the statements will not throw an exception. 一般来说,严格引用模式对使用引用的所有情况都是正确的,除了#if指令中的特殊情况。如果在#if或#elseif指令中使用没有任何方法或属性的引用,并且没有与另一个值进行比较,则允许使用未定义的引用。这种行为提供了一种简单的方法来测试在模板中使用引用之前是否定义了引用。在下面的例子中,$foo未定义,但语句不会抛出异常。12345#if ($foo)#end ## False#if ( ! $foo)#end ## True#if ($foo &amp;&amp; $foo.bar)#end ## False and $foo.bar will not be evaluated#if ($foo &amp;&amp; $foo == &quot;bar&quot;)#end ## False and $foo == &quot;bar&quot; wil not be evaluated#if ($foo1 || $foo2)#end ## False $foo1 and $foo2 are not defined Strict mode requires that comparisons of &gt;, &lt;, &gt;= or &lt;= within an #if directive makes sense. Also, the argument to #foreach must be iterable (this behavior can be modified with the property directive.foreach.skip.invalid). Finally, undefined macro references will also throw an exception in strict mode. 严格模式要求在#if指令内比较&gt;,&lt;,&gt; =或&lt;=是有意义的。 另外,#foreach的参数必须是可迭代的(这个行为可以用属性directive.foreach.skip.invalid修改)。最后,未定义的micro引用也将在严格模式中抛出异常。 References that Velocity attempts to render but evaluate to null will cause an Exception. To simply render nothing in this case the reference can be preceded by ‘$!’ instead of ‘$’, similar to non strict mode. Keep in mind this is different from the reference not existing in the context which will always throw an exception when attempting to render it in strict mode. For example, below $foo has a value of null in the context 当Velocity尝试呈现求值为null的引用时将导致异常。为了在这种情况下简单地不呈现,引用可以类似于非严格模式在“$!”之前,而不是’$’。请记住,这不同于上下文中不存在的引用,当尝试以严格模式呈现它时,它将总是引发异常。 例如,下面的$foo在上下文中的值为null123this is $foo ## throws an exception because $foo is nullthis is $!foo ## renders to &quot;this is &quot; without an exceptionthis is $!bogus ## bogus is not in the context so throws an exception Quiet Reference Notation 可替换情况Now that you are familiar with references, you can begin to apply them effectively in your templates. Velocity references take advantage of some Java principles that template designers will find easy to use. For example: 现在您已经熟悉了引用,可以开始在模板中有效地应用它们了。 Velocity引用利用了一些Java的原则,模板设计者会发现它们易于使用。 例如：123456789101112131415$foo$foo.getBar()## is the same as$foo.Bar$data.setUser(&quot;jon&quot;)## is the same as#set( $data.User = &quot;jon&quot; )$data.getRequest().getServerName()## is the same as$data.Request.ServerName## is the same as$&#123;data.Request.ServerName&#125; These examples illustrate alternative uses for the same references. Velocity takes advantage of Java’s introspection and bean features to resolve the reference names to both objects in the Context as well as the objects methods. It is possible to embed and evaluate references almost anywhere in your template. 这些示例说明了相同引用可以互相替代的使用方式。Velocity利用Java的introspection和bean特性来解析上下文中的两个对象的引用名称以及对象方法。 可以在模板的任何位置嵌入和评估引用。 Velocity, which is modelled on the Bean specifications defined by Sun Microsystems, is case sensitive; however, its developers have strove to catch and correct user errors wherever possible. When the method getFoo() is referred to in a template by $bar.foo, Velocity will first try $getfoo. If this fails, it will then try $getFoo. Similarly, when a template refers to $bar.Foo, Velocity will try $getFoo() first and then try getfoo(). Velocity,是由Sun Microsystems定义的Bean规范建模的,区分大小写; 然而,它的开发人员尽力捕获并纠正用户错误。 当方法getFoo()在模板中由$ bar.foo引用时,Velocity将首先尝试$getfoo。如果失败,它将尝试$getFoo。 同样,当模板引用$bar.Foo时,Velocity首先尝试$getFoo(),然后尝试getfoo()。 Note: References to instance variables in a template are not resolved. Only references to the attribute equivalents of JavaBean getter/setter methods are resolved (i.e. $foo.Name does resolve to the class Foo’s getName() instance method, but not to a public Name instance variable of Foo). 注意：不会解析模板中对实例变量的引用。 只有与JavaBean getter/setter方法等价属性的引用被解析(即$foo.Name解析为Foo的getName()实例方法,而不是Foo的public Name实例变量)。 Directives 指令References allow template designers to generate dynamic content for web sites, while directives – easy to use script elements that can be used to creatively manipulate the output of Java code – permit web designers to truly take charge of the appearance and content of the web site. 引用允许模板设计者为网站生成动态内容,而指令 – 易于使用的脚本元素,可用于创造性地操纵Java代码的输出 – 允许网页设计师真正的掌控网站的外观和内容。 Directives always begin with a #. Like references, the name of the directive may be bracketed by a { and a } symbol. This is useful with directives that are immediately followed by text. For example the following produces an error: 指令始终以＃开头。像引用一样,指令的名称可以用{和}符号括起来。这对于紧接着紧跟文本的指令很有用。例如,以下产生错误：1#if($a==1)true enough#elseno way!#end In such a case, use the brackets to separate #else from the rest of the line. 在这种情况下,使用括号将#else与行的其余部分分开。1#if($a==1)true enough#&#123;else&#125;no way!#end SetThe #set directive is used for setting the value of a reference. A value can be assigned to either a variable reference or a property reference, and this occurs in brackets, as demonstrated: #set指令用于设置引用的值。在括号中出现的值可以分配给变量引用或属性引用,如下所示：12#set( $primate = &quot;monkey&quot; )#set( $customer.Behavior = $primate ) The left hand side (LHS) of the assignment must be a variable reference or a property reference. The right hand side (RHS) can be one of the following types: 赋值的左侧(LHS)必须是变量引用或属性引用。 右侧(RHS)可以是以下类型之一： Variable reference String literal Property reference Method reference Number literal ArrayList Map These examples demonstrate each of the aforementioned types: 这些示例说明了上述每种类型：1234567#set( $monkey = $bill ) ## variable reference#set( $monkey.Friend = &quot;monica&quot; ) ## string literal#set( $monkey.Blame = $whitehouse.Leak ) ## property reference#set( $monkey.Plan = $spindoctor.weave($web) ) ## method reference#set( $monkey.Number = 123 ) ##number literal#set( $monkey.Say = [&quot;Not&quot;, $my, &quot;fault&quot;] ) ## ArrayList#set( $monkey.Map = &#123;&quot;banana&quot; : &quot;good&quot;, &quot;roast beef&quot; : &quot;bad&quot;&#125;) ## Map NOTE: For the ArrayList example the elements defined with the [..] operator are accessible using the methods defined in the ArrayList class. So, for example, you could access the first element above using $monkey.Say.get(0). 注意：对于ArrayList示例,使用[..]运算符定义的元素可以使用ArrayList类中定义的方法访问。 因此,例如,您可以访问上面的第一个元素使用$ monkey.Say.get(0)。 Similarly, for the Map example, the elements defined within the { } operator are accessible using the methods defined in the Map class. So, for example, you could access the first element above using $monkey.Map.get(“banana”) to return a String ‘good’, or even $monkey.Map.banana to return the same value. 类似地,对于Map示例,在{}运算符中定义的元素可以使用Map类中定义的方法访问。例如,您可以使用$monkey.Map.get(“banana”)访问上面的第一个元素,返回一个String’good’,或者使用$monkey.Map.banana返回相同的值。 The RHS can also be a simple arithmetic expression: RHS也可以是一个简单的算术表达式：1234#set( $value = $foo + 1 )#set( $value = $bar - 1 )#set( $value = $foo * $bar )#set( $value = $foo / $bar ) If the RHS is a property or method reference that evaluates to null, it will not be assigned to the LHS. Depending on how Velocity is configured, it is usually not possible to remove an existing reference from the context via this mechanism. (Note that this can be permitted by changing one of the Velocity configuration properties). This can be confusing for newcomers to Velocity. For example: 如果RHS是一个计算为null的属性或方法引用,则不会将其分配给LHS。根据Velocity的配置方式,通常不可能通过此机制从上下文中删除现有的引用。 (注意,这可以通过更改Velocity配置属性之一来允许)。 这对于Velocity的新人来说可能很困惑。 例如：12345#set( $result = $query.criteria(&quot;name&quot;) )The result of the first query is $result#set( $result = $query.criteria(&quot;address&quot;) )The result of the second query is $result If $query.criteria(“name”) returns the string “bill”, and $query.criteria(“address”) returns null, the above VTL will render as the following: 如果$query.criteria(“name”)返回字符串“bill”,并且$query.criteria(“address”)返回null,上述VTL将呈现如下：123The result of the first query is billThe result of the second query is bill This tends to confuse newcomers who construct #foreach loops that attempt to #set a reference via a property or method reference, then immediately test that reference with an #if directive. For example: 这往往会混淆新手构造#foreach循环时,尝试通过#set设置属性或方法引用后,立即使用#if指令测试这个引用。 例如：1234567891011#set( $criteria = [&quot;name&quot;, &quot;address&quot;] )#foreach( $criterion in $criteria ) #set( $result = $query.criteria($criterion) ) #if( $result ) Query was successful #end#end In the above example, it would not be wise to rely on the evaluation of $result to determine if a query was successful. After $result has been #set (added to the context), it cannot be set back to null (removed from the context). The details of the #if and #foreach directives are covered later in this document. 在上面的例子中,使用$result的求值来确定查询是否成功是不明智的。 $result已经#set(添加到上下文)后,它不能设置为null(从上下文中删除)。 #if和#foreach指令的详细信息将在本文档的后面部分介绍。 One solution to this would be to pre-set $result to false. Then if the $query.criteria() call fails, you can check. 一个解决方案是将$result设置为false。 然后如果$query.criteria()调用失败,你可以检查。123456789101112#set( $criteria = [&quot;name&quot;, &quot;address&quot;] )#foreach( $criterion in $criteria ) #set( $result = false ) #set( $result = $query.criteria($criterion) ) #if( $result ) Query was successful #end#end Unlike some of the other Velocity directives, the #set directive does not have an #end statement. 与其他一些Velocity指令不同,#set指令没有#end语句。 Literals 字面量When using the #set directive, string literals that are enclosed in double quote characters will be parsed and rendered, as shown: 当使用#set指令时,括在双引号中的字符串将被解析和呈现,如下所示：1234#set( $directoryRoot = &quot;www&quot; )#set( $templateName = &quot;index.vm&quot; )#set( $template = &quot;$directoryRoot/$templateName&quot; )$template The output will be1www/index.vm However, when the string literal is enclosed in single quote characters, it will not be parsed: 但是,当字符串文字在单引号中时,不会被解析：1234#set( $foo = &quot;bar&quot; )$foo#set( $blargh = &apos;$foo&apos; )$blargh This renders as:12bar$foo By default, this feature of using single quotes to render unparsed text is available in Velocity. This default can be changed by editing velocity.properties such that stringliterals.interpolate=false. 默认情况下,使用单引号来呈现解析的文本的功能在Velocity中是可用的。 可以通过编辑velocity.properties使stringliterals.interpolate = false来更改此默认值。 Alternately, the #[[don’t parse me!]]# syntax allows the template designer to easily use large chunks of uninterpreted and unparsed content in VTL code. This can be especially useful in place of escaping multiple directives or escaping sections which have content that would otherwise be invalid (and thus unparseable) VTL. 或者,模板设计者可以在VTL代码中通过＃[[不解析我！]]语法轻松地使用大块未解释和未解析的内容。 这在代替转义多个指令或转义部分具有无效(不可解析)的VTL内容时特别有用。12345#[[#foreach ($woogie in $boogie) nothing will happen to $woogie#end]]# Renders as:123#foreach ($woogie in $boogie) nothing will happen to $woogie#end Conditionals 条件语句If / ElseIf / ElseThe #if directive in Velocity allows for text to be included when the web page is generated, on the conditional that the if statement is true. For example: Velocity中的#if指令允许在生成网页时,在if语句为真的条件下包含文本。 例如：123#if( $foo ) &lt;strong&gt;Velocity!&lt;/strong&gt;#end The variable $foo is evaluated to determine whether it is true, which will happen under one of three circumstances: 在以下三种情况之一下发生时将评估变量$foo以确定其是否为真： $foo is a boolean (true/false) which has a true value $foo是值为true的布尔值 $foo is a string or a collection which is not null and not empty $foo是是一个非null字符串或者非空集合 $foo is an object (other than a string or a collection) which is not null $foo是一个非null对象 Remember that the Velocity context only contains Objects, so when we say ‘boolean’, it will be represented as a Boolean (the class). This is true even for methods that return boolean - the introspection infrastructure will return a Boolean of the same logical value. 记住,Velocity上下文只包含对象,所以当我们说’boolean’时,它将被表示为一个Boolean(类),即使返回boolean的方法 - introspection基础设施也将返回相同的逻辑值的Boolean。 The content between the #if and the #end statements become the output if the evaluation is true. In this case, if $foo is true, the output will be: “Velocity!”. Conversely, if $foo has a null value, or if it is a boolean false, the statement evaluates as false, and there is no output. 如果值为true,#if和#end语句之间的内容将会输出。在这种情况下,如果$foo为true,输出将是：“Velocity！”。相反,如果$foo有一个null,或者如果它是一个布尔值false,语句计算结果为false,没有输出。 An #elseif or #else element can be used with an #if element. Note that the Velocity Templating Engine will stop at the first expression that is found to be true. In the following example, suppose that $foo has a value of 15 and $bar has a value of 6. #elseif或#else元素可以与#if元素一起使用。 注意,Velocity模板引擎将停在第一个为真的表达式那里。 在以下示例中,假设$foo的值为15,$bar的值为6。123456789#if( $foo &lt; 10 ) **Go North**#elseif( $foo == 10 ) **Go East**#elseif( $bar == 6 ) **Go South**#else **Go West**#end In this example, $foo is greater than 10, so the first two comparisons fail. Next $bar is compared to 6, which is true, so the output is Go South. 在此示例中,$foo大于10,因此前两个比较失败。 下一个$bar比较为6,这是真的,所以输出是Go South。 Relational and Logical Operators 关系和逻辑运算符Velocity uses the equivalent operator to determine the relationships between variables. Here is a simple example to illustrate how the equivalent operator is used. Velocity使用等效运算符来确定变量之间的关系。 这里是一个简单的例子来说明如何使用等效运算符。12345678#set ($foo = &quot;deoxyribonucleic acid&quot;)#set ($bar = &quot;ribonucleic acid&quot;)#if ($foo == $bar) In this case it&apos;s clear they aren&apos;t equivalent. So...#else They are not equivalent and this will be the output.#end Note that the semantics of == are slightly different than Java where == can only be used to test object equality. In Velocity the equivalent operator can be used to directly compare numbers, strings, or objects. When the objects are of different classes, the string representations are obtained by calling toString() for each object and then compared. 注意==的语义与Java略有不同,Java中==只能用于测试对象的相等性。 而在Velocity中,等效运算符可以用于直接比较数字,字符串或对象。 当对象是不同的类时,通过调用每个对象的toString()然后比较获得的字符串。 Velocity has logical AND, OR and NOT operators as well. Below are examples demonstrating the use of the logical AND, OR and NOT operators. Velocity具有逻辑AND,OR和NOT运算符。 下面是演示使用逻辑AND,OR和NOT运算符的示例。12345## logical AND#if( $foo &amp;&amp; $bar ) ** This AND that**#end The #if() directive will only evaluate to true if both $foo and $bar are true. If $foo is false, the expression will evaluate to false; $bar will not be evaluated. If $foo is true, the Velocity Templating Engine will then check the value of $bar; if $bar is true, then the entire expression is true and This AND that becomes the output. If $bar is false, then there will be no output as the entire expression is false. 如果$foo和$bar都为true,#if()指令计算为true。 如果$foo为false,表达式将计算为false,不会评估$bar。如果$foo为true,Velocity模板引擎将检查$bar的值; 如果$bar为true,则整个表达式为true,这个AND将成为输出。如果$bar是false,那么将没有输出,因为整个表达式是false。 Logical OR operators work the same way, except only one of the references need evaluate to true in order for the entire expression to be considered true. Consider the following example. 逻辑OR运算符的工作方式相同,但只要有一个引用值为true,表达式的值就是true。 请考虑以下示例。12345## logical OR#if( $foo || $bar ) **This OR That**#end If $foo is true, the Velocity Templating Engine has no need to look at $bar; whether $bar is true or false, the expression will be true, and This OR That will be output. If $foo is false, however, $bar must be checked. In this case, if $bar is also false, the expression evaluates to false and there is no output. On the other hand, if $bar is true, then the entire expression is true, and the output is This OR That 如果$foo为true,Velocity模板引擎不需要查看$bar; 无论$bar是true还是false,表达式都将为true,并且将输出此OR。如果$foo为false,则必须检查$bar。在这种情况下,如果$bar也为false,那么表达式将计算为false,并且没有输出。 另一方面,如果$bar为true,则整个表达式为true,输出为This OR That With logical NOT operators, there is only one argument : 使用逻辑NOT运算符,只有一个参数：12345##logical NOT#if( !$foo ) **NOT that**#end Here, the if $foo is true, then !$foo evaluates to false, and there is no output. If $foo is false, then !$foo evaluates to true and NOT that will be output. Be careful not to confuse this with the quiet reference $!foo which is something altogether different. 这里,如果$foo为true,那么!$foo计算结果为false,没有输出。 如果$foo为false,那么！$ foo计算结果为true,否则输出NOT。 小心不要混淆它与静态引用$!foo,它们是完全不同的东西。 There are text versions of all logical operators, including eq, ne, and, or, not, gt, ge, lt, and le. 有所有逻辑运算符的文本版本,包括eq,ne,and,or,not,gt,ge,lt和le。 One more useful note. When you wish to include text immediately following a #else directive you will need to use curly brackets immediately surrounding the directive to differentiate it from the following text. (Any directive can be delimited by curly brackets, although this is most useful for #else). 一个更有用的注释,当你希望包含紧跟在#else指令之后的文本时,你需要使用直接围绕指令的大括号来区分它和下面的文本。 (任何指令可以用大括号分隔,虽然这对#else最有用)。1#if( $foo == $bar)it&apos;s true!#&#123;else&#125;it&apos;s not!#end Loops 循环Foreach LoopThe #foreach element allows for looping. For example: #foreach元素允许循环。 例如：12345&lt;ul&gt;#foreach( $product in $allProducts ) &lt;li&gt;$product&lt;/li&gt;#end&lt;/ul&gt; This #foreach loop causes the $allProducts list (the object) to be looped over for all of the products (targets) in the list. Each time through the loop, the value from $allProducts is placed into the $product variable. 这个#foreach循环遍历$allProducts列表(对象)中的所有产品(目标)。每次循环,将$allProducts的值将放入$product变量中。 The contents of the $allProducts variable is a Vector, a Hashtable or an Array. The value assigned to the $product variable is a Java Object and can be referenced from a variable as such. For example, if $product was really a Product class in Java, its name could be retrieved by referencing the $product.Name method (ie: $Product.getName()). $allProducts变量的内容是Vector,Hashtable或Array。 分配给$product变量的值是一个Java对象,可以从变量中引用。例如,如果$product实际上是Java中的Product类,则可以通过引用$product.Name方法(即：$Product.getName())来检索其名称。 Lets say that $allProducts is a Hashtable. If you wanted to retrieve the key values for the Hashtable as well as the objects within the Hashtable, you can use code like this: $allProducts是一个Hashtable。如果要检索Hashtable的键值以及Hashtable中的对象,可以使用如下代码：12345&lt;ul&gt;#foreach( $key in $allProducts.keySet() ) &lt;li&gt;Key: $key -&gt; Value: $allProducts.get($key)&lt;/li&gt;#end&lt;/ul&gt; Velocity provides an easy way to get the loop counter so that you can do something like the following: Velocity提供了一种简单的方法来获取循环计数器,以便您可以执行以下操作：12345&lt;table&gt;#foreach( $customer in $customerList ) &lt;tr&gt;&lt;td&gt;$foreach.count&lt;/td&gt;&lt;td&gt;$customer.Name&lt;/td&gt;&lt;/tr&gt;#end&lt;/table&gt; Velocity also now provides an easy way to tell if you are on the last iteration of a loop: Velocity现在还提供了一种简单的方法来判断你是否在循环的最后一次迭代：123#foreach( $customer in $customerList ) $customer.Name#if( $foreach.hasNext ),#end#end If you want a zero-based index of the #foreach loop, you can just use $foreach.index instead of $foreach.count. Likewise, $foreach.first and $foreach.last are provided to compliment $foreach.hasNext. If you want to access these properties for an outer #foreach loop, you can reference them directly through the $foreach.parent or $foreach.topmost properties (e.g. $foreach.parent.index or $foreach.topmost.hasNext). 如果你想要一个从零开始的#foreach循环的索引,你可以使用$foreach.index而不是$foreach.count。同样,提供$foreach.first和$foreach.last来补充$foreach.hasNext。如果要访问外部#foreach循环的这些属性,可以通过$foreach.parent或$foreach.topmost属性(例如$foreach.parent.index或$foreach.topmost.hasNext)直接引用它们。 It’s possible to set a maximum allowed number of times that a loop may be executed. By default there is no max (indicated by a value of 0 or less), but this can be set to an arbitrary number in the velocity.properties file. This is useful as a fail-safe. 可以设置循环可执行的最大允许次数。默认情况下没有max(由0或更小的值指示),但是可以将其设置为velocity.properties文件中的任意数字。这可用作故障安全。12# The maximum allowed number of loops.directive.foreach.maxloops = -1 If you want to stop looping in a foreach from within your template, you can now use the #break directive to stop looping at any time: 如果想要在模板中停止循环,可以随时使用#break指令停止循环：1234567## list first 5 customers only#foreach( $customer in $customerList ) #if( $foreach.count &gt; 5 ) #break #end $customer.Name#end Include 包含The #include script element allows the template designer to import a local file, which is then inserted into the location where the #include directive is defined. The contents of the file are not rendered through the template engine. For security reasons, the file to be included may only be under TEMPLATE_ROOT. #include脚本元素允许模板设计器导入本地文件,然后将其插入到定义#include指令的位置。文件的内容不通过模板引擎呈现。出于安全考虑,要包含的文件只能处于TEMPLATE_ROOT下。1#include( &quot;one.txt&quot; ) The file to which the #include directive refers is enclosed in quotes. If more than one file will be included, they should be separated by commas. #include指令引用的文件用引号括起来。 如果包含多个文件,它们应该用逗号分隔。1#include( &quot;one.gif&quot;,&quot;two.txt&quot;,&quot;three.htm&quot; ) The file being included need not be referenced by name; in fact, it is often preferable to use a variable instead of a filename. This could be useful for targeting output according to criteria determined when the page request is submitted. Here is an example showing both a filename and a variable. 所包含的文件不需要通过名称引用; 实际上,通常优先使用变量而不是文件名。 这可能有助于根据在提交页面请求时确定的标准定位输出。 这里是一个显示文件名和变量的例子。1#include( &quot;greetings.txt&quot;, $seasonalstock ) Parse 解析The #parse script element allows the template designer to import a local file that contains VTL. Velocity will parse the VTL and render the template specified. #parse脚本元素允许模板设计器导入包含VTL的本地文件。 Velocity将解析VTL并渲染指定的模板。1#parse( &quot;me.vm&quot; ) Like the #include directive, #parse can take a variable rather than a template. Any templates to which #parse refers must be included under TEMPLATE_ROOT. Unlike the #include directive, #parse will only take a single argument. 像#include指令一样,#parse可以接受一个变量而不是一个模板。 #parse引用的任何模板必须包含在TEMPLATE_ROOT下。 与#include指令不同,#parse只接受一个参数。 VTL templates can have #parse statements referring to templates that in turn have #parse statements. By default set to 10, the directive.parse.max.depth line of the velocity.properties allows users to customize maximum number of #parse referrals that can occur from a single template. (Note: If the directive.parse.max.depth property is absent from the velocity.properties file, Velocity will set this default to 10.) Recursion is permitted, for example, if the template dofoo.vm contains the following lines: VTL模板使用#parse语句引用的模板中可以有#parse语句。 默认设置为10,velocity.properties文件中的directive.parse.max.depth允许用户自定义可从单个模板发生的#parse引用的最大数量。 (注意：如果velocity.properties文件中缺少directive.parse.max.depth属性,则Velocity会将此默认值设置为10.)允许递归,例如,如果模板dofoo.vm包含以下行：1234Count down.#set( $count = 8 )#parse( &quot;parsefoo.vm&quot; )All done with dofoo.vm! It would reference the template parsefoo.vm, which might contain the following VTL: 它将引用模板parsefoo.vm,它可能包含以下VTL：1234567$count#set( $count = $count - 1 )#if( $count &gt; 0 ) #parse( &quot;parsefoo.vm&quot; )#else All done with parsefoo.vm!#end After “Count down.” is displayed, Velocity passes through parsefoo.vm, counting down from 8. When the count reaches 0, it will display the “All done with parsefoo.vm!” message. At this point, Velocity will return to dofoo.vm and output the “All done with dofoo.vm!” message. “Count down.”之后,Velocity从8开始计数，通过parsefoo.vm显示。当计数达到0时,它将显示“All done with parsefoo.vm！”信息，此时,Velocity将返回dofoo.vm并输出“All done with dofoo.vm！”信息。 Break 中止The #break directive stops any further rendering of the current execution scope. An “execution scope” is essentially any directive with content (i.e. #foreach, #parse, #evaluate, #define, #macro, or #@somebodymacro) or any “root” scope (i.e. template.merge(…), Velocity.evaluate(…) or velocityEngine.evaluate(…)). Unlike #stop, #break will only stop the innermost, immediate scope, not all of them. #break指令停止对当前执行范围的任何进一步呈现。“执行范围”基本上是任何带有内容的指令(即#foreach,#parse,#evaluate,#define,#macro或＃@somebodymacro)或任何“根”范围(即template.merge Velocity.evaluate(…)或velocityEngine.evaluate(…))。与#stop不同,#break只会停止最里面的,立即的范围,而不是所有的。 If you wish to break out of a specific execution scope that is not necessarily the most immediate one, then you can pass the scope control reference (i.e. $foreach, $template, $evaluate, $define, $macro, or $somebodymacro) as an argument to #break. (e.g. #break($macro)). This will stop rendering of all scopes up to the specified one. When within nested scopes of the same type, remember that you can always access the parent(s) via $.parent or $.topmost and pass those to #break instead (e.g. #break($foreach.parent) or #break($macro.topmost)). 如果你希望跳出一个不一定是最直接的特定执行范围,那么你可以通过范围控制引用(即$foreach,$template,$evaluate,$define,$macro或$somebodymacro)#break的参数。(例如#break($macro))。这将停止渲染所有范围直到指定的范围。当在同一类型的嵌套作用域内时,记住你可以随时通过$.parent或$.topmost访问父类,并将它们传递给#break(例如#break($foreach.parent)或#break($macro.topmost)))。 Stop 停止he #stop directive stops any further rendering and execution of the template. This is true even when the directive is nested within another template accessed through #parse or located in a velocity macro. The resulting merged output will contain all the content up to the point the #stop directive was encountered. This is handy as an early exit from a template. For debugging purposes, you may provide a message argument (e.g. #stop(‘$foo was not in context’) ) that will be written to the logs (DEBUG level, of course) upon completion of the stop command. #stop指令停止任何进一步的模板渲染和执行。即使当指令嵌套在通过#parse访问或位于velocity macro中的另一个模板中时,也是如此。生成的合并输出将包含遇到#stop指令之前的所有内容。这是方便的作为早期退出模板。为了调试,可以在完成停止命令后提供一个消息参数(例如#stop(‘$foo不在上下文中’))将被写入日志(当然是DEBUG级别)。 Evaluate 计算The #evaluate directive can be used to dynamically evaluate VTL. This allows the template to evaluate a string that is created at render time. Such a string might be used to internationalize the template or to include parts of a template from a database. #evaluate指令可用于动态评估VTL。这允许模板评估在渲染时创建的字符串。这样的字符串可以用于国际化模板或包括来自数据库的模板的部分。 The example below will display abc.12345#set($source1 = &quot;abc&quot;)#set($select = &quot;1&quot;)#set($dynamicsource = &quot;$source$select&quot;)## $dynamicsource is now the string &apos;$source1&apos;#evaluate($dynamicsource) Define 定义The #define directive lets one assign a block of VTL to a reference. #define指令允许将一个VTL块分配给一个引用。 The example below will display Hello World!.123#define( $block )Hello $who#end#set( $who = &apos;World!&apos; )$block Velocimacros 宏The #macro script element allows template designers to define a repeated segment of a VTL template. Velocimacros are very useful in a wide range of scenarios both simple and complex. This Velocimacro, created for the sole purpose of saving keystrokes and minimizing typographic errors, provides an introduction to the concept of Velocimacros. #macro脚本元素允许模板设计者定义VTL模板的重复段。 Velocimacros在广泛的简单和复杂场景是非常有用的。 创造Velocimacro的唯一目的是保存按键和最小化印刷错误,提供Velocimacros的概念介绍。123#macro( d )&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;#end The Velocimacro being defined in this example is d, and it can be called in a manner analogous to any other VTL directive: 在本例中定义的Velocimacro是d,它可以以类似于任何其他VTL指令的方式调用：1#d() When this template is called, Velocity would replace #d() with a row containing a single, empty data cell. If we want to put something in that cell, we can alter the macro to allow for a body: 当调用此模板时,Velocity将用包含单个空数据单元的行替换#d()。 如果我们想在该单元格中放置某些东西,我们可以改变该macro以允许一个body：123#macro( d )&lt;tr&gt;&lt;td&gt;$!bodyContent&lt;/td&gt;&lt;/tr&gt;#end Now, if we call the macro just a bit differently, using #@ before the name and providing a body and #end to the call, then Velocity will render the body when it gets to the $!bodyContent: 现在,如果我们调用macro有点不同,名称之前使用＃@,并在调用里提供一个body和#end,然后当Velocity得到$!bodyContent将渲染body：1#@d()Hello!#end You can still call the macro as you did before, and since we used the silent reference notation for the body reference ($!bodyContent instead of $bodyContent), it will still render a row with a single, empty data cell. 你仍然可以像以前一样调用macro,因为我们使用静态引用符号为body引用($!bodyContent而不是$bodyContent),它仍然将渲染一个具有单个空数据单元格的行。 A Velocimacro can also take any number of arguments – even zero arguments, as demonstrated in the first example, is an option – but when the Velocimacro is invoked, it must be called with the same number of arguments with which it was defined. Many Velocimacros are more involved than the one defined above. Here is a Velocimacro that takes two arguments, a color and an array. Velocimacro也可以采用任意数量的参数 - 即使是零参数,如第一个示例中所示,是一个选项 - 但是当Velocimacro被调用时,必须使用与它定义的参数相同的参数来调用它。 许多Velocimacros比上面定义的更多参与。 这里是一个Velocimacro,它接受两个参数,一个颜色和一个数组。12345#macro( tablerows $color $somelist )#foreach( $something in $somelist ) &lt;tr&gt;&lt;td bgcolor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt;#end#end The Velocimacro being defined in this example, tablerows, takes two arguments. The first argument takes the place of $color, and the second argument takes the place of $somelist. 在本例中定义的Velocimacro tablerows,有两个参数。第一个参数代替$color,第二个参数代替$somelist。 Anything that can be put into a VTL template can go into the body of a Velocimacro. The tablerows Velocimacro is a foreach statement. There are two #end statements in the definition of the #tablerows Velocimacro; the first belongs to the #foreach, the second ends the Velocimacro definition. 任何可以放入VTL模板的东西都可以进入Velocimacro的body。 Tablocows Velocimacro是一个foreach语句。 #tablerows Velocimacro的定义中有两个#end语句：第一个属于#foreach,第二个结束Velocimacro定义。12345#set( $greatlakes = [&quot;Superior&quot;,&quot;Michigan&quot;,&quot;Huron&quot;,&quot;Erie&quot;,&quot;Ontario&quot;] )#set( $color = &quot;blue&quot; )&lt;table&gt; #tablerows( $color $greatlakes )&lt;/table&gt; Notice that $greatlakes takes the place of $somelist. When the #tablerows Velocimacro is called in this situation, the following output is generated: 注意$greatlakes代替$somelist。 当在这种情况下调用#tablerows Velocimacro时,会生成以下输出：1234567&lt;table&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Superior&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Michigan&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Huron&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Erie&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;blue&quot;&gt;Ontario&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Velocimacros can be defined inline in a Velocity template, meaning that it is unavailable to other Velocity templates on the same web site. Defining a Velocimacro such that it can be shared by all templates has obvious advantages: it reduces the need to redefine the Velocimacro on numerous templates, saving work and reducing the chance of error, and ensures that a single change to a macro available to more than one template. Velocimacros可以在Velocity模板中内联定义,这意味着它在同一网站上的其他Velocity模板不可用。 定义一个Velocimacro,以便它可以被所有模板共享有明显的优势：它减少了需要重新定义Velocimacro在许多模板,节省工作和减少错误的机会,并确保对单个更改可用的大于 一个模板。 Were the #tablerows($color $list) Velocimacro defined in a Velocimacros template library, this macro could be used on any of the regular templates. It could be used many times and for many different purposes. In the template mushroom.vm devoted to all things fungi, the #tablerows Velocimacro could be invoked to list the parts of a typical mushroom: 在Velocimacros模板库中定义的#tablerows($color $list)Velocimacro,这个macro可以用于任何常规模板。它可以为许多不同的目的被使用许多次。在模板mushroom.vm致力于所有的真菌,#tablerows Velocimacro可以调用列出典型的蘑菇的部分：…12345#set( $parts = [&quot;volva&quot;,&quot;stipe&quot;,&quot;annulus&quot;,&quot;gills&quot;,&quot;pileus&quot;] )#set( $cellbgcol = &quot;#CC00FF&quot; )&lt;table&gt;#tablerows( $cellbgcol $parts )&lt;/table&gt; When fulfilling a request for mushroom.vm, Velocity would find the #tablerows Velocimacro in the template library (defined in the velocity.properties file) and generate the following output: 当满足对mushroom.vm的请求时,Velocity将在模板库(在velocity.properties文件中定义)中找到#tablerows Velocimacro并生成以下输出：1234567&lt;table&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;volva&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;stipe&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;annulus&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;gills&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td bgcolor=&quot;#CC00FF&quot;&gt;pileus&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Velocimacro ArgumentsVelocimacros can take as arguments any of the following VTL elements : Velocimacro可以接受任何以下VTL元素作为参数： Reference : anything that starts with ‘$’ String literal : something like “$foo” or ‘hello’ Number literal : 1, 2 etc IntegerRange : [ 1..2] or [$foo .. $bar] ObjectArray : [ “a”, “b”, “c”] boolean value true boolean value false When passing references as arguments to Velocimacros, please note that references are passed ‘by name’. This means that their value is ‘generated’ at each use inside the Velocimacro. This feature allows you to pass references with method calls and have the method called at each use. For example, when calling the following Velocimacro as shown 当引用作为参数传递到Velocimacros时,请注意引用是通过名称传递的。 这意味着它们的值是在Velocimacro内部每次使用时产生的。 此功能允许您使用方法调用传递引用,并在每次使用时调用该方法。 例如,当调用以下Velocimacro时,所示12345#macro( callme $a ) $a $a $a#end#callme( $foo.bar() ) results in the method bar() of the reference $foo being called 3 times. 导致$foo引用的bar()方法被调用3次。 At first glance, this feature appears surprising, but when you take into consideration the original motivation behind Velocimacros – to eliminate cut’n’paste duplication of commonly used VTL – it makes sense. It allows you to do things like pass stateful objects, such as an object that generates colors in a repeating sequence for coloring table rows, into the Velocimacro. 乍一看,这个功能看起来令人惊讶,但是当你考虑到Velocimacros的原始动机 – 以消除常用的VTL的cut’n’paste重复 – 这是有道理的。 它允许你做一些事情,比如传递一个在重复的序列中生成着色表行颜色的有状态的对象,进入Velocimacro。 If you need to circumvent this feature, you can always just get the value from the method as a new reference and pass that : 如果你需要规避这个功能,你可以通过把该方法的值作为一个新的引用：12#set( $myval = $foo.bar() )#callme( $myval ) Velocimacro PropertiesSeveral lines in the velocity.properties file allow for flexible implementation of Velocimacros. Note that these are also documented in the Developer Guide. velocity.properties文件中的几行允许灵活实现Velocimacros。 请注意,这些内容也记录在“开发人员指南”中。 velocimacro.library - A comma-separated list of all Velocimacro template libraries. By default, Velocity looks for a single library: VM_global_library.vm. The configured template path is used to find the Velocimacro libraries. velocimacro.library - 所有Velocimacro模板库的逗号分隔列表。 默认情况下,Velocity查找单个库：VM_global_library.vm。 配置的模板路径用于查找Velocimacro库。 velocimacro.permissions.allow.inline - This property, which has possible values of true or false, determines whether Velocimacros can be defined in regular templates. The default, true, allows template designers to define Velocimacros in the templates themselves. velocimacro.permissions.allow.inline - 此属性的可能值为true或false,用于确定Velocimacros是否可在常规模板中定义。 默认值为true,允许模板设计者在模板自身中定义Velocimacros。 velocimacro.permissions.allow.inline.to.replace.global - With possible values of true or false, this property allows the user to specify if a Velocimacro defined inline in a template can replace a globally defined template, one that was loaded on startup via the velocimacro.library property. The default, false, prevents Velocimacros defined inline in a template from replacing those defined in the template libraries loaded at startup. velocimacro.permissions.allow.inline.to.replace.global - 使用可能的值true或false,此属性允许用户指定是否在模板中定义的Velocimacro可以替换全局定义的模板,启动时通过velocimacro.library属性加载模板。 默认值为false,可防止模板中定义的Velocimacros替换在启动时加载的模板库中定义的那些。 velocimacro.permissions.allow.inline.local.scope - This property, with possible values of true or false, defaulting to false, controls if Velocimacros defined inline are ‘visible’ only to the defining template. In other words, with this property set to true, a template can define inline VMs that are usable only by the defining template. You can use this for fancy VM tricks - if a global VM calls another global VM, with inline scope, a template can define a private implementation of the second VM that will be called by the first VM when invoked by that template. All other templates are unaffected. velocimacro.permissions.allow.inline.local.scope - 此属性的可能值为true或false，默认为false，控制Velocimacros定义内联是否仅对定义模板可见。 换句话说，将此属性设置为true时，模板可以定义只能由定义模板使用的内联VM。 您可以使用这个虚拟的技巧 - 如果一个全局虚拟机调用另一个全局虚拟机，使用内联作用域，一个模板可以定义第二个虚拟机的私有实现，当被该模板调用时，第一个虚拟机将调用它。 所有其他模板不受影响。 velocimacro.library.autoreload - This property controls Velocimacro library autoloading. The default value is false. When set to true the source Velocimacro library for an invoked Velocimacro will be checked for changes, and reloaded if necessary. This allows you to change and test Velocimacro libraries without having to restart your application or servlet container, just like you can with regular templates. This mode only works when caching is off in the resource loaders (e.g. file.resource.loader.cache = false ). This feature is intended for development, not for production. velocimacro.library.autoreload - 此属性控制Velocimacro库自动加载。 默认值为false。 设置为true时,将调用Velocimacro的源Velocimacro库检查更改,如有必要,将重新加载。 这允许您更改和测试Velocimacro库,而不必重新启动应用程序或servlet容器,就像使用常规模板一样。 此模式仅在资源加载程序中的缓存关闭时有效(例如file.resource.loader.cache = false)。 此功能用于开发,而不是用于生产。 Please note than when two templates each define a macro with the same name, you either need velocimacro.permissions.allow.inline.local.scope or velocimacro.permissions.allow.inline.to.replace.global to be set to true for each template to use its own macro version. 请注意,当两个模板各自定义一个具有相同名称的micro时,您需要velocimacro.permissions.allow.inline.local.scope或velocimacro.permissions.allow.inline.to.replace.global为每个micro设置为true,使模板使用自己的micro版本。 Getting Literal 获取字面量VTL uses special characters, such as $ and #, to do its work, so some added care should be taken where using these characters in your templates. This section deals with escaping these characters. VTL使用特殊字符(例如$和＃)来完成其工作,因此在模板中使用这些字符时应该格外小心。 本节介绍转义这些字符。 Currency 并发There is no problem writing “I bought a 4 lb. sack of potatoes at the farmer’s market for only $2.50!” As mentioned, a VTL identifier always begins with an upper- or lowercase letter, so $2.50 would not be mistaken for a reference. 写”我在农民的市场上买了一块4磅的土豆,只需$2.50!”没有问题,如上所述,VTL标识符总是以大写或小写字母开头,因此$2.50不会被误认为是引用。 Escaping Valid VTL References 转义VTL引用Cases may arise where you do not want to have a reference rendered by Velocity. Escaping special characters is the best way to output VTL’s special characters in these situations, and this can be done using the backslash ( ** ) character when those special characters are part of a valid VTL reference. 当你不想有由Velocity提供的引用时,可能会出现一些情况。在这些情况下,转义特殊字符是输出VTL的特殊字符的最佳方法,当这些特殊字符是有效VTL引用的一部分时,可以使用反斜杠( ** )字符来完成。12#set( $email = &quot;foo&quot; )$email If Velocity encounters a reference in your VTL template to $email, it will search the Context for a corresponding value. Here the output will be foo, because $email is defined. If $email is not defined, the output will be $email. 如果Velocity遇到VTL模板中的引用到$email,它将搜索Context以获取相应的值。因为$email是定义的,这里的输出将是foo。如果没有定义$email,输出将是$email。 Suppose that $email is defined (for example, if it has the value foo), and that you want to output $email. There are a few ways of doing this, but the simplest is to use the escape character. Here is a demonstration: 假设定义了$email(例如,如果它具有值foo),并且您想输出$email。有几种方法可以做到这一点,但最简单的是使用转义字符。这里是一个示范： Suppose that $email is defined (for example, if it has the value foo), and that you want to output $email. There are a few ways of doing this, but the simplest is to use the escape character. Here is a demonstration: 假设定义了$email(例如,如果它具有值foo),并且您想输出$email。有几种方法可以做到这一点,但最简单的是使用转义字符。这里是一个示范：1234## The following line defines $email in this template:#set( $email = &quot;foo&quot; )$email\$email renders as12foo$email If, for some reason, you need a backslash before either line above, you can do the following: 如果因为某些原因,在上面的任一行之前需要反斜杠,您可以执行以下操作：1234## The following line defines $email in this template:#set( $email = &quot;foo&quot; )\\$email\\\$email which renders as12\foo\$email Note that the character bind to the $ from the left. The bind-from-left rule causes \\$email to render as \$email. Compare these examples to those in which `$email` is not defined. 注意, 字符绑定到左边的$。 左侧带从规则导致\\$email呈现为\$email。 将这些示例与未定义$email 的示例进行比较。1234$email\$email\\$email\\\$email renders as1234$email\$email\\$email\\\$email Notice Velocity handles references that are defined differently from those that have not been defined. Here is a set directive that gives $foo the value gibbous. 注意Velocity处理的引用定义与未定义的引用的定义不同。 这里是一个set指令,给出$foo的值gibbous。12#set( $foo = &quot;gibbous&quot; )$moon = $foo The output will be: $moon = gibbous – where $moon is output as a literal because it is undefined and gibbous is output in place of $foo. 输出将是：$moon = gibbous – 其中$moon输出为文字,因为它是未定义的,并且输出gibbous代替$foo。 Escaping Invalid VTL References 转义不可用VTL引用Sometimes Velocity has trouble parsing your template when it encounters an “invalid reference” that you never intended to be a reference at all. Escaping special characters is, again, the best way to handle these situations, but in these situations, the backslash will likely fail you. Instead of simply trying to escape the problematic $ or #, you should probably just replace this: 有时Velocity遇到解析你的模板时遇到一个“无效的引用”,你从来没有打算作为一个引用。转义特殊字符同样是处理这些情况的最佳方式,但在这些情况下,反斜杠可能会失败。不能简单地试图逃避有问题的$或＃,你应该替换为：1$&#123;my:invalid:non:reference&#125; with something like this12#set( $D = &apos;$&apos; )$&#123;D&#125;&#123;my:invalid:non:reference&#125; You can, of course, put your $ or # string directly into the context from your java code (e.g. context.put(“D”,”$”);) to avoid the extra #set() directive in your template(s). Or, if you are using VelocityTools, you can just use the EscapeTool like this: 当然，你可以把你的$或＃字符串直接从你的java代码放入上下文(例如context.put(“D”,“$”);),以避免额外的#set()指令在你的模板。或者,如果你使用VelocityTools,你可以使用EscapeTool像这样：1$&#123;esc.d&#125;&#123;my:invalid:non:reference&#125; Escaping of both valid and invalid VTL directives is handled in much the same manner; this is described in more detail in the Directives section. 有效和无效的VTL指令的转义以同样的方式处理; 这在“指令”部分中有更详细的描述。 Escaping VTL Directives 转义VTL指令VTL directives can be escaped with the backslash character (“\”) in a manner similar to valid VTL references. VTL指令可以使用反斜杠字符(“\”)以类似于有效VTL引用的方式转义。12345678## #include( &quot;a.txt&quot; ) renders as &lt;contents of a.txt&gt;#include( &quot;a.txt&quot; )## \#include( &quot;a.txt&quot; ) renders as #include( &quot;a.txt&quot; )\#include( &quot;a.txt&quot; )## \\#include ( &quot;a.txt&quot; ) renders as \&lt;contents of a.txt&gt;\\#include ( &quot;a.txt&quot; ) Extra care should be taken when escaping VTL directives that contain multiple script elements in a single directive (such as in an if-else-end statements). Here is a typical VTL if-statement: 当转义单个指令中包含多个脚本元素的VTL指令时(如if-else-end语句中),应格外小心。 这里是一个典型的VTL if语句：123#if( $jazz ) Vyacheslav Ganelin#end If $jazz is true, the output is1Vyacheslav Ganelin If $jazz is false, there is no output. Escaping script elements alters the output. Consider the following case: 如果$ jazz为false,则没有输出。 转义脚本元素会更改输出。 考虑以下情况：123\#if( $jazz ) Vyacheslav Ganelin\#end This causes the directives to be escaped, but the rendering of $jazz proceeds as normal. So, if $jazz is true, the output is 这将导致指令被转义,但$jazz的正常显示。 所以,如果$jazz为true,输出为123#if( true ) Vyacheslav Ganelin #end Suppose backslashes precede script elements that are legitimately escaped: 假设在合法转义的脚本元素前面有反斜杠：123v\\#if( $jazz ) Vyacheslav Ganelin\\#end In this case, if $jazz is true, the output is 在这种情况下,$jazz是true,输出为12\ Vyacheslav Ganelin\ To understand this, note that the #if( arg ) when ended by a newline (return) will omit the newline from the output. Therefore, the body of the #if() block follows the first ‘\’, rendered from the ‘\’ preceding the #if(). The last \ is on a different line than the text because there is a newline after ‘Ganelin’, so the final \, preceding the #end is part of the body of the block. 要理解这一点,请注意如果#if(arg)在新的一行结束时,输出时将省略这一行。 因此,#if()的语句块跟在第一个’\’之后,从#if()之前的’\’开始。 最后一个\在与文本不同的行上,因为在’Ganelin’之后有一个换行符,因此#end之前的最后一个\是块的主体的一部分。 If $jazz is false, the output is1\ Note that things start to break if script elements are not properly escaped. 请注意,如果脚本元素未正确转义,事情就会开始中断。123\\\#if( $jazz ) Vyacheslave Ganelin\\#end Here the #if is escaped, but there is an #end remaining; having too many endings will cause a parsing error. 这里#if被转义,但是还有一个#end标签; 多余的标签将导致解析错误. VTL: Formatting Issues 格式化问题Although VTL in this user guide is often displayed with newlines and whitespaces, the VTL shown below 虽然本用户指南中的VTL经常显示换行符和空格,但它们的VTL如下所示1234#set( $imperial = [&quot;Munetaka&quot;,&quot;Koreyasu&quot;,&quot;Hisakira&quot;,&quot;Morikune&quot;] )#foreach( $shogun in $imperial ) $shogun#end is equally valid as the following snippet that Geir Magnusson Jr. posted to the Velocity user mailing list to illustrate a completely unrelated point: 同样有效,如下面的代码片段Geir Magnusson Jr.发布到Velocity用户邮件列表来说明一个完全不相关的点：1Send me #set($foo=[&quot;$10 and &quot;,&quot;a pie&quot;])#foreach($a in $foo)$a#end please. Velocity’s default behaviour is to gobble up excess whitespace. The preceding directive can be written as: Velocity的默认行为是吞噬多余的空格。 前面的指令可以写成：123456Send me#set( $foo = [&quot;$10 and &quot;,&quot;a pie&quot;] )#foreach( $a in $foo )$a#endplease. or as12345Send me#set($foo = [&quot;$10 and &quot;,&quot;a pie&quot;]) #foreach ($a in $foo )$a #end please. In each case the output will be the same. Please note that it&apos;s possible to configure Velocity with other space gobbling behaviors. In each case the output will be the same. Please note that it’s possible to configure Velocity with other space gobbling behaviors. 在每种情况下,输出将是相同的。 请注意,可以配置Velocity与其他空间gobbling行为。 Other Features and Miscellany 其它特征和功能Math 算术Velocity has a handful of built-in mathematical functions that can be used in templates with the set directive. The following equations are examples of addition, subtraction, multiplication and division, respectively: Velocity有一些内置的数学函数,可以在模板中使用set指令。 以下等式分别是加法,减法,乘法和除法的示例：1234#set( $foo = $bar + 3 )#set( $foo = $bar - 4 )#set( $foo = $bar * 6 )#set( $foo = $bar / 2 ) When a division operation is performed between two integers, the result will be an integer, as the fractional portion is discarded. Any remainder can be obtained by using the modulus (%) operator. 当在两个整数之间执行除法运算时,结果将是一个整数,因为会舍去小数部分。 任何余数可以通过使用模量(％)运算符获得。1#set( $foo = $bar % 5 ) Range Operator 范围操作符The range operator can be used in conjunction with #set and #foreach statements. Useful for its ability to produce an object array containing integers, the range operator has the following construction: 范围运算符可以与#set和#foreach语句结合使用。 对于生成包含整数的对象数组时非常有用,范围运算符具有以下结构：1[n..m] Both n and m must either be or produce integers. Whether m is greater than or less than n will not matter; in this case the range will simply count down. Examples showing the use of the range operator as provided below: n和m必须是或者产生整数。 m大于或小于n无关紧要; 在这种情况下,范围将只是倒置的。 下面提供了示范使用范围运算符的示例：123456789101112131415161718First example:#foreach( $foo in [1..5] )$foo#endSecond example:#foreach( $bar in [2..-2] )$bar#endThird example:#set( $arr = [0..1] )#foreach( $i in $arr )$i#endFourth example:[1..3] Produces the following output:1234567891011First example:1 2 3 4 5Second example:2 1 0 -1 -2Third example:0 1Fourth example:[1..3] Note that the range operator only produces the array when used in conjunction with #set and #foreach directives, as demonstrated in the fourth example. 请注意,范围运算符仅在与#set和#foreach指令结合使用时才会生成数组,如第四个示例中所示。 Web page designers concerned with making tables a standard size, but where some will not have enough data to fill the table, will find the range operator particularly useful. 网页设计师希望表格成为标准尺寸,但是有些人没有足够的数据填充表格,这时会发现范围操作符特别有用。 Advanced Issues: Escaping and ! 高级问题:转义和!When a reference is silenced with the ! character and the ! character preceded by an escape character, the reference is handled in a special way. Note the differences between regular escaping, and the special case where precedes ! follows it: 当一个引用前面加上！ 字符和！ 字符前面带有转义字符,则引用以特殊方式处理。 注意常规转义和特殊情况之间的区别,其中先于！ 遵循：12345#set( $foo = &quot;bar&quot; )$\!foo$\!&#123;foo&#125;$\\!foo$\\\!foo This renders as:1234$!foo$!&#123;foo&#125;$\!foo$\\!foo Contrast this with regular escaping, where precedes $ :1234\$foo\$!foo\$!&#123;foo&#125;\\$!&#123;foo&#125; This renders as:1234$foo$!foo$!&#123;foo&#125;\bar Velocimacro Miscellany Velocimacro杂谈Can I use a directive or another VM as an argument to a VM?Can I register Velocimacros via #parse() ?What is Velocimacro Autoreloading?There is a property, meant to be used in development, not production : 有一个属性,意味着用于开发,而不是生产：1`velocimacro.library.autoreload` which defaults to false. When set to true along with1`&lt;type&gt;.resource.loader.cache = false` (where is the name of the resource loader that you are using, such as ‘file’) then the Velocity engine will automatically reload changes to your Velocimacro library files when you make them, so you do not have to dump the servlet engine (or application) or do other tricks to have your Velocimacros reloaded. (其中是您正在使用的资源加载程序的名称,例如’file’),则Velocity引擎将自动重新加载更改Velocimacro库文件,当你使它们,所以你不必转储servlet引擎(或 应用程序)或做其他的技巧,让你的Velocimacros重新加载。 Here is what a simple set of configuration properties would look like. 这里是一个简单的配置属性的集合。123file.resource.loader.path = templatesfile.resource.loader.cache = falsevelocimacro.library.autoreload = true Don’t keep this on in production. 不要把它保留在生产中。 String Concatenation 字符串拼接A common question that developers ask is How do I do String concatenation? Is there any analogue to the ‘+’ operator in Java?. 开发人员问的一个常见问题是如何做字符串连接？ 在Java中是否有’+’运算符的模拟？ To do concatenation of references in VTL, you just have to ‘put them together’. The context of where you want to put them together does matter, so we will illustrate with some examples. In the regular ‘schmoo’ of a template (when you are mixing it in with regular content) : 在模板的常规“shmoo”中(当您将其与常规内容混合时)：1234#set( $size = &quot;Big&quot; )#set( $name = &quot;Ben&quot; )The clock is $size$name. and the output will render as ‘The clock is BigBen’. For more interesting cases, such as when you want to concatenate strings to pass to a method, or to set a new reference, just do 并且输出将呈现为“时钟是大本钟”。 对于更有趣的情况,例如当你想要连接字符串传递给一个方法,或者设置一个新的引用,只是做123456#set( $size = &quot;Big&quot; )#set( $name = &quot;Ben&quot; )#set($clock = &quot;$size$name&quot; )The clock is $clock. Which will result in the same output. As a final example, when you want to mix in ‘static’ strings with your references, you may need to use ‘formal references’ : 这将导致相同的输出。 作为最后一个例子,当你想混合静态字符串和你的引用,你可能需要使用’正式引用’：123456#set( $size = &quot;Big&quot; )#set( $name = &quot;Ben&quot; )#set($clock = &quot;$&#123;size&#125;Tall$name&quot; )The clock is $clock. Now the output is ‘The clock is BigTallBen’. The formal notation is needed so the parser knows you mean to use the reference ‘$size’ versus ‘$sizeTall’ which it would if the ‘{}’ weren’t there. 现在的输出是’The clock is BigTallBen’。 正式符号是需要的,所以解析器知道你的意思是使用引用’$ size’对’$sizeTall’,如果’{}“不在那里。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[springSecurity快速指南]]></title>
      <url>%2F2016%2F11%2F02%2FspringSecurity%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Spring Security Security是什么?Security配置方式 application using Java-based Spring Boot application Xml-based configuration Spring MVC application security使用版本：4.1.3.RELEASE引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; XML方式新建配置文件security.xmlweb.xml设置引入配置文件123456&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:security.xml &lt;/param-value&gt;&lt;/context-param&gt; 配置过滤器12345678&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; security.xml配置引入name space123456&lt;b:beans xmlns=&quot;http://www.springframework.org/schema/security&quot; xmlns:b=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt;&lt;/b:beans&gt; NameSpace 可划分为以下几块: Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。 业务对象或者方法的安全：控制方法访问权限的。 AuthenticationManager：处理来自于框架其他部分的认证请求。 AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。 AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。 UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。 元素http 元素用于定义 Web 相关权限控制123&lt;http&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&apos;USER&apos;)&quot;/&gt;&lt;/http&gt; intercept-url配置指定拦截的 url通过 pattern 指定当前 intercept-url 定义应当作用于哪些 url1&lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&apos;USER&apos;)&quot;/&gt; 指定访问权限通过 access 属性来指定 intercept-url 对应 URL 访问所应当具有的权限。access 的值是一个字符串，其可以直接是一个权限的定义，也可以是一个表达式。例如: hasRole(‘ROLE_USER’) or hasRole(‘ROLE_ADMIN’) hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)指定访问协议指定 intercept-url 的 requires-channel 属性来指定访问协议。requires-channel 支持三个值：http、https 和 any。any 表示 http 和 https 都可以访问。例如:1&lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; requires-channel=&quot;http&quot;/&gt; 注意:当试图使用 http 请求那些限制了只能通过 https 访问的资源时会自动跳转到对应的 https 通道重新请求。如果所使用的 http 或者 https 协议不是监听在标准的端口上（http 默认是 80，https 默认是 443），则需要我们通过 port-mapping 元素定义好它们的对应关系。1234&lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; requires-channel=&quot;http&quot;/&gt;&lt;port-mappings&gt; &lt;port-mapping http=&quot;8888&quot; https=&quot;9999&quot;/&gt;&lt;/port-mappings&gt; 指定请求方法如果我们要求某些 URL 只能通过 POST 请求，某些 URL 只能通过 GET 请求，可以通过指定 intercept-url 的 method 属性限制当前 intercept-url 适用的请求方式，默认为所有的方式都可以。method 的可选值有 GET、POST、DELETE、PUT、HEAD、OPTIONS 和 TRACE。1&lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; method=&quot;GET&quot;/&gt; 元素认证是由 AuthenticationManager 来管理的，但是真正进行认证的是 AuthenticationManager 中定义的 AuthenticationProvider。AuthenticationManager 中可以定义有多个 AuthenticationProvider。当我们使用 authentication-provider 元素来定义一个 AuthenticationProvider 时，如果没有指定对应关联的 AuthenticationProvider 对象，Spring Security 默认会使用 DaoAuthenticationProvider。DaoAuthenticationProvider 在进行认证的时候需要一个 UserDetailsService 来获取用户的信息 UserDetails，其中包括用户名、密码和所拥有的权限等。所以如果我们需要改变认证的方式，我们可以实现自己的 AuthenticationProvider；如果需要改变认证的用户信息来源，我们可以实现 UserDetailsService。 实现了自己的 AuthenticationProvider 之后，我们可以在配置文件中这样配置来使用我们自己的 AuthenticationProvider。其中 myAuthenticationProvider 就是我们自己的 AuthenticationProvider 实现类对应的 bean。123&lt;authentication-manager&gt; &lt;authentication-provider ref=&quot;myAuthenticationProvider&quot;/&gt;&lt;/authentication-manager&gt; 实现了自己的 UserDetailsService 之后，我们可以在配置文件中这样配置来使用我们自己的 UserDetailsService。其中的 myUserDetailsService 就是我们自己的 UserDetailsService 实现类对应的 bean。123&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;myUserDetailsService&quot;/&gt;&lt;/authentication-manager&gt; 用户信息从数据库获取通常我们的用户信息都不会向第一节示例中那样简单的写在配置文件中，而是从其它存储位置获取，比如数据库。根据之前的介绍我们知道用户信息是通过 UserDetailsService 获取的，要从数据库获取用户信息，我们就需要实现自己的 UserDetailsService。幸运的是像这种常用的方式 Spring Security 已经为我们做了实现了。 使用 jdbc-user-service 获取在 Spring Security 的命名空间中在 authentication-provider 下定义了一个 jdbc-user-service 元素，通过该元素我们可以定义一个从数据库获取 UserDetails 的 UserDetailsService。jdbc-user-service 需要接收一个数据源的引用。12345&lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot;/&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; 上述配置中 dataSource 是对应数据源配置的 bean 引用。 因为默认情况下 jdbc-user-service 将使用 SQL 语句 “select username, password, enabled from users where username = ?” 来获取用户信息；使用 SQL 语句 “select username, authority from authorities where username = ?” 来获取用户对应的权限；使用 SQL 语句 “select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id” 来获取用户所属组的权限。需要注意的是 jdbc-user-service 定义是不支持用户组权限的，所以使用 jdbc-user-service 时用户组相关表也是可以不定义的。如果需要使用用户组权限请使用 JdbcDaoImpl。 当然这只是默认配置及默认的表结构。如果我们的表名或者表结构跟 Spring Security 默认的不一样，我们可以通过以下几个属性来定义我们自己查询用户信息、用户权限和用户组权限的 SQL: users-by-username-query 指定查询用户信息的 SQL authorities-by-username-query 指定查询用户权限的 SQL group-authorities-by-username-query 指定查询用户组权限的 SQL例如:1234567&lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot; users-by-username-query=&quot;select username, password, enabled from account where username = ?&quot; /&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; role-prefix 属性:jdbc-user-service 还有一个属性 role-prefix 可以用来指定角色的前缀。这是什么意思呢？这表示我们从库里面查询出来的权限需要加上什么样的前缀。举个例子，假设我们库里面存放的权限都是 “USER”，而我们指定了某个 URL 的访问权限 access=”ROLEUSER”，显然这是不匹配的，Spring Security 不会给我们放行，通过指定 jdbc-user-service 的 role-prefix=”ROLE\” 之后就会满足了。当 role-prefix 的值为 “none” 时表示没有前缀，当然默认也是没有的。 直接使用 JdbcDaoImplJdbcDaoImpl 是 UserDetailsService 的一个实现。其用法和 jdbc-user-service 类似，只是我们需要把它定义为一个 bean，然后通过 authentication-provider 的 user-service-ref 进行引用。1234567&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot;/&gt;&lt;/authentication-manager&gt;&lt;bean id=&quot;userDetailsService&quot; class=&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; JdbcDaoImpl 同样需要一个 dataSource 的引用。如果就是上面这样配置的话我们数据库表结构也需要是标准的表结构。当然，如果我们的表结构和标准的不一样，可以通过 usersByUsernameQuery、authoritiesByUsernameQuery 和 groupAuthoritiesByUsernameQuery 属性来指定对应的查询 SQL。 JdbcDaoImpl 使用 enableAuthorities 和 enableGroups 两个属性来控制权限的启用。默认启用的是 enableAuthorities，即用户权限，而 enableGroups 默认是不启用的。如果需要启用用户组权限，需要指定 enableGroups 属性值为 true。当然这两种权限是可以同时启用的。需要注意的是使用 jdbc-user-service 定义的 UserDetailsService 是不支持用户组权限的，如果需要支持用户组权限的话需要我们使用 JdbcDaoImpl。12345678&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot;/&gt;&lt;/authentication-manager&gt;&lt;bean id=&quot;userDetailsService&quot; class=&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;enableGroups&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt; PasswordEncoder通常我们保存的密码都不会像之前介绍的那样，保存的明文，而是加密之后的结果。为此，我们的 AuthenticationProvider 在做认证时也需要将传递的明文密码使用对应的算法加密后再与保存好的密码做比较。Spring Security 对这方面也有支持。通过在 authentication-provider 下定义一个 password-encoder 我们可以定义当前 AuthenticationProvider 需要在进行认证时需要使用的 password-encoder。password-encoder 是一个 PasswordEncoder 的实例，我们可以直接使用它，如：12345&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot;&gt; &lt;password-encoder hash=&quot;md5&quot;/&gt; &lt;/authentication-provider&gt;&lt;/authentication-manager&gt; 其属性hash表示我们将用来进行加密的哈希算法，系统已经为我们实现的有plaintext、sha、sha-256、md4、md5、{sha}和{ssha}。 认证简介认证过程 用户使用用户名和密码进行登录。 Spring Security 将获取到的用户名和密码封装成一个实现了 Authentication 接口的 UsernamePasswordAuthenticationToken。 将上述产生的 token 对象传递给 AuthenticationManager 进行登录认证。 AuthenticationManager 认证成功后将会返回一个封装了用户权限等信息的 Authentication 对象。 通过调用 SecurityContextHolder.getContext().setAuthentication(…) 将 AuthenticationManager 返回的 Authentication 对象赋予给当前的 SecurityContext。 在认证成功后，用户就可以继续操作去访问其它受保护的资源了，但是在访问的时候将会使用保存在 SecurityContext 中的 Authentication 对象进行相关的权限鉴定。 Web 应用的认证过程如果用户直接访问登录页面，那么认证过程跟上节描述的基本一致，只是在认证完成后将跳转到指定的成功页面，默认是应用的根路径。如果用户直接访问一个受保护的资源，那么认证过程将如下： 引导用户进行登录，通常是重定向到一个基于 form 表单进行登录的页面，具体视配置而定。 用户输入用户名和密码后请求认证，后台还是会像上节描述的那样获取用户名和密码封装成一个 UsernamePasswordAuthenticationToken 对象，然后把它传递给 AuthenticationManager 进行认证。 如果认证失败将继续执行步骤 1，如果认证成功则会保存返回的 Authentication 到 SecurityContext，然后默认会将用户重定向到之前访问的页面。 用户登录认证成功后再次访问之前受保护的资源时就会对用户进行权限鉴定，如不存在对应的访问权限，则会返回 403 错误码。在上述步骤中将有很多不同的类参与，但其中主要的参与者是 ExceptionTranslationFilter。ExceptionTranslationFilterExceptionTranslationFilter 是用来处理来自 AbstractSecurityInterceptor 抛出的 AuthenticationException 和 AccessDeniedException 的。AbstractSecurityInterceptor 是 Spring Security 用于拦截请求进行权限鉴定的，其拥有两个具体的子类，拦截方法调用的 MethodSecurityInterceptor 和拦截 URL 请求的 FilterSecurityInterceptor。当 ExceptionTranslationFilter 捕获到的是 AuthenticationException 时将调用 AuthenticationEntryPoint 引导用户进行登录；如果捕获的是 AccessDeniedException，但是用户还没有通过认证，则调用 AuthenticationEntryPoint 引导用户进行登录认证，否则将返回一个表示不存在对应权限的 403 错误码。在 request 之间共享 SecurityContext既然 SecurityContext 是存放在 ThreadLocal 中的，而且在每次权限鉴定的时候都是从 ThreadLocal 中获取 SecurityContext 中对应的 Authentication 所拥有的权限，并且不同的 request 是不同的线程，为什么每次都可以从 ThreadLocal 中获取到当前用户对应的 SecurityContext 呢？在 Web 应用中这是通过 SecurityContextPersistentFilter 实现的，默认情况下其会在每次请求开始的时候从 session 中获取 SecurityContext，然后把它设置给 SecurityContextHolder，在请求结束后又会将 SecurityContextHolder 所持有的 SecurityContext 保存在 session 中，并且清除 SecurityContextHolder 所持有的 SecurityContext。这样当我们第一次访问系统的时候，SecurityContextHolder 所持有的 SecurityContext 肯定是空的，待我们登录成功后，SecurityContextHolder 所持有的 SecurityContext 就不是空的了，且包含有认证成功的 Authentication 对象，待请求结束后我们就会将 SecurityContext 存在 session 中，等到下次请求的时候就可以从 session 中获取到该 SecurityContext 并把它赋予给 SecurityContextHolder 了，由于 SecurityContextHolder 已经持有认证过的 Authentication 对象了，所以下次访问的时候也就不再需要进行登录认证了。 核心类简介 Authentication Authentication 是一个接口，用来表示用户认证信息的，在用户登录认证之前相关信息会封装为一个 Authentication 具体实现类的对象，在登录认证成功之后又会生成一个信息更全面，包含用户权限等信息的 Authentication 对象，然后把它保存在 SecurityContextHolder 所持有的 SecurityContext 中，供后续的程序进行调用，如访问权限的鉴定等。 SecurityContextHolder SecurityContextHolder 是用来保存 SecurityContext 的。SecurityContext 中含有当前正在访问系统的用户的详细信息。默认情况下，SecurityContextHolder 将使用 ThreadLocal 来保存 SecurityContext，这也就意味着在处于同一线程中的方法中我们可以从 ThreadLocal 中获取到当前的 SecurityContext。因为线程池的原因，如果我们每次在请求完成后都将 ThreadLocal 进行清除的话，那么我们把 SecurityContext 存放在 ThreadLocal 中还是比较安全的。这些工作 Spring Security 已经自动为我们做了，即在每一次 request 结束后都将清除当前线程的 ThreadLocal。 SecurityContextHolder 中定义了一系列的静态方法，而这些静态方法内部逻辑基本上都是通过 SecurityContextHolder 持有的 SecurityContextHolderStrategy 来实现的，如 getContext()、setContext()、clearContext()等。而默认使用的 strategy 就是基于 ThreadLocal 的 ThreadLocalSecurityContextHolderStrategy。另外，Spring Security 还提供了两种类型的 strategy 实现，GlobalSecurityContextHolderStrategy 和 InheritableThreadLocalSecurityContextHolderStrategy，前者表示全局使用同一个 SecurityContext，如 C/S 结构的客户端；后者使用 InheritableThreadLocal 来存放 SecurityContext，即子线程可以使用父线程中存放的变量。 一般而言，我们使用默认的 strategy 就可以了，但是如果要改变默认的 strategy，Spring Security 为我们提供了两种方法，这两种方式都是通过改变 strategyName 来实现的。SecurityContextHolder 中为三种不同类型的 strategy 分别命名为 MODE_THREADLOCAL、MODE_INHERITABLETHREADLOCAL 和 MODE_GLOBAL。第一种方式是通过 SecurityContextHolder 的静态方法 setStrategyName() 来指定需要使用的 strategy；第二种方式是通过系统属性进行指定，其中属性名默认为 “spring.security.strategy”，属性值为对应 strategy 的名称。 Spring Security 使用一个 Authentication 对象来描述当前用户的相关信息。SecurityContextHolder 中持有的是当前用户的 SecurityContext，而 SecurityContext 持有的是代表当前用户相关信息的 Authentication 的引用。这个 Authentication 对象不需要我们自己去创建，在与系统交互的过程中，Spring Security 会自动为我们创建相应的 Authentication 对象，然后赋值给当前的 SecurityContext。但是往往我们需要在程序中获取当前用户的相关信息，比如最常见的是获取当前登录用户的用户名。在程序的任何地方，通过如下方式我们可以获取到当前用户的用户名。 12345678910public String getCurrentUsername() &#123; Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); if (principal instanceof UserDetails) &#123; return ((UserDetails) principal).getUsername(); &#125; if (principal instanceof Principal) &#123; return ((Principal) principal).getName(); &#125; return String.valueOf(principal);&#125; 通过 Authentication.getPrincipal() 可以获取到代表当前用户的信息，这个对象通常是 UserDetails 的实例。获取当前用户的用户名是一种比较常见的需求，关于上述代码其实 Spring Security 在 Authentication 中的实现类中已经为我们做了相关实现，所以获取当前用户的用户名最简单的方式应当如下。 123public String getCurrentUsername() &#123; return SecurityContextHolder.getContext().getAuthentication().getName();&#125; 此外，调用 SecurityContextHolder.getContext() 获取 SecurityContext 时，如果对应的 SecurityContext 不存在，则 Spring Security 将为我们建立一个空的 SecurityContext 并进行返回。 AuthenticationManager 和 AuthenticationProvider AuthenticationManager 是一个用来处理认证（Authentication）请求的接口。在其中只定义了一个方法 authenticate()，该方法只接收一个代表认证请求的 Authentication 对象作为参数，如果认证成功，则会返回一个封装了当前用户权限等信息的 Authentication 对象进行返回。 1Authentication authenticate(Authentication authentication) throws AuthenticationException; 在 Spring Security 中，AuthenticationManager 的默认实现是 ProviderManager，而且它不直接自己处理认证请求，而是委托给其所配置的 AuthenticationProvider 列表，然后会依次使用每一个 AuthenticationProvider 进行认证，如果有一个 AuthenticationProvider 认证后的结果不为 null，则表示该 AuthenticationProvider 已经认证成功，之后的 AuthenticationProvider 将不再继续认证。然后直接以该 AuthenticationProvider 的认证结果作为 ProviderManager 的认证结果。如果所有的 AuthenticationProvider 的认证结果都为 null，则表示认证失败，将抛出一个 ProviderNotFoundException。校验认证请求最常用的方法是根据请求的用户名加载对应的 UserDetails，然后比对 UserDetails 的密码与认证请求的密码是否一致，一致则表示认证通过。Spring Security 内部的 DaoAuthenticationProvider 就是使用的这种方式。其内部使用 UserDetailsService 来负责加载 UserDetails，UserDetailsService 将在下节讲解。在认证成功以后会使用加载的 UserDetails 来封装要返回的 Authentication 对象，加载的 UserDetails 对象是包含用户权限等信息的。认证成功返回的 Authentication 对象将会保存在当前的 SecurityContext 中。 当我们在使用 NameSpace 时， authentication-manager 元素的使用会使 Spring Security 在内部创建一个 ProviderManager，然后可以通过 authentication-provider 元素往其中添加 AuthenticationProvider。当定义 authentication-provider 元素时，如果没有通过 ref 属性指定关联哪个 AuthenticationProvider，Spring Security 默认就会使用 DaoAuthenticationProvider。使用了 NameSpace 后我们就不要再声明 ProviderManager 了。 1234&lt;authentication-manager alias=&quot;authenticationManager&quot;&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot;/&gt;&lt;/authentication-manager&gt; 如果我们没有使用 NameSpace，那么我们就应该在 ApplicationContext 中声明一个 ProviderManager。 认证成功后清除凭证 默认情况下，在认证成功后 ProviderManager 将清除返回的 Authentication 中的凭证信息，如密码。所以如果你在无状态的应用中将返回的 Authentication 信息缓存起来了，那么以后你再利用缓存的信息去认证将会失败，因为它已经不存在密码这样的凭证信息了。所以在使用缓存的时候你应该考虑到这个问题。一种解决办法是设置 ProviderManager 的 eraseCredentialsAfterAuthentication 属性为 false，或者想办法在缓存时将凭证信息一起缓存。 UserDetailsService 通过 Authentication.getPrincipal() 的返回类型是 Object，但很多情况下其返回的其实是一个 UserDetails 的实例。UserDetails 是 Spring Security 中一个核心的接口。其中定义了一些可以获取用户名、密码、权限等与认证相关的信息的方法。Spring Security 内部使用的 UserDetails 实现类大都是内置的 User 类，我们如果要使用 UserDetails 时也可以直接使用该类。在 Spring Security 内部很多地方需要使用用户信息的时候基本上都是使用的 UserDetails，比如在登录认证的时候。登录认证的时候 Spring Security 会通过 UserDetailsService 的 loadUserByUsername() 方法获取对应的 UserDetails 进行认证，认证通过后会将该 UserDetails 赋给认证通过的 Authentication 的 principal，然后再把该 Authentication 存入到 SecurityContext 中。之后如果需要使用用户信息的时候就是通过 SecurityContextHolder 获取存放在 SecurityContext 中的 Authentication 的 principal。 通常我们需要在应用中获取当前用户的其它信息，如 Email、电话等。这时存放在 Authentication 的 principal 中只包含有认证相关信息的 UserDetails 对象可能就不能满足我们的要求了。这时我们可以实现自己的 UserDetails，在该实现类中我们可以定义一些获取用户其它信息的方法，这样将来我们就可以直接从当前 SecurityContext 的 Authentication 的 principal 中获取这些信息了。上文已经提到了 UserDetails 是通过 UserDetailsService 的 loadUserByUsername() 方法进行加载的。UserDetailsService 也是一个接口，我们也需要实现自己的 UserDetailsService 来加载我们自定义的 UserDetails 信息。然后把它指定给 AuthenticationProvider 即可。如下是一个配置 UserDetailsService 的示例。 12345678910&lt;!-- 用于认证的 AuthenticationManager --&gt;&lt;authentication-manager alias=&quot;authenticationManager&quot;&gt; &lt;authentication-provider user-service-ref=&quot;userDetailsService&quot; /&gt;&lt;/authentication-manager&gt;&lt;bean id=&quot;userDetailsService&quot; class=&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 上述代码中我们使用的 JdbcDaoImpl 是 Spring Security 为我们提供的 UserDetailsService 的实现，另外 Spring Security 还为我们提供了 UserDetailsService 另外一个实现，InMemoryDaoImpl。 其作用是从数据库中加载 UserDetails 信息。其中已经定义好了加载相关信息的默认脚本，这些脚本也可以通过 JdbcDaoImpl 的相关属性进行指定。 JdbcDaoImpl JdbcDaoImpl 允许我们从数据库来加载 UserDetails，其底层使用的是 Spring 的 JdbcTemplate 进行操作，所以我们需要给其指定一个数据源。此外，我们需要通过 usersByUsernameQuery 属性指定通过 username 查询用户信息的 SQL 语句；通过 authoritiesByUsernameQuery 属性指定通过 username 查询用户所拥有的权限的 SQL 语句；如果我们通过设置 JdbcDaoImpl 的 enableGroups 为 true 启用了用户组权限的支持，则我们还需要通过 groupAuthoritiesByUsernameQuery 属性指定根据 username 查询用户组权限的 SQL 语句。当这些信息都没有指定时，将使用默认的 SQL 语句，默认的 SQL 语句如下所示。 123select username, password, enabled from users where username=? -- 根据 username 查询用户信息select username, authority from authorities where username=? -- 根据 username 查询用户权限信息select g.id, g.group_name, ga.authority from groups g, groups_members gm, groups_authorities ga where gm.username=? and g.id=ga.group_id and g.id=gm.group_id -- 根据 username 查询用户组权限 使用默认的 SQL 语句进行查询时意味着我们对应的数据库中应该有对应的表和表结构，Spring Security 为我们提供的默认表的创建脚本如下。 12345678910111213141516171819202122232425create table users( username varchar_ignorecase(50) not null primary key, password varchar_ignorecase(50) not null, enabled boolean not null);create table authorities ( username varchar_ignorecase(50) not null, authority varchar_ignorecase(50) not null, constraint fk_authorities_users foreign key(username) references users(username)); create unique index ix_auth_username on authorities (username,authority);create table groups (id bigint generated by default as identity(start with 0) primary key,group_name varchar_ignorecase(50) notnull);create table group_authorities (group_id bigint notnull,authority varchar(50) notnull,constraint fk_group_authorities_group foreign key(group_id) references groups(id));create table group_members (id bigint generated by default as identity(start with 0) primary key,username varchar(50) notnull,group_id bigint notnull,constraint fk_group_members_group foreign key(group_id) references groups(id)); 此外，使用 jdbc-user-service 元素时在底层 Spring Security 默认使用的就是 JdbcDaoImpl。 123456&lt;authentication-manager alias=&quot;authenticationManager&quot;&gt; &lt;authentication-provider&gt; &lt;!-- 基于 Jdbc 的 UserDetailsService 实现，JdbcDaoImpl --&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot;/&gt; &lt;/authentication-provider&gt;&lt;/authentication-manager&gt; InMemoryDaoImpl InMemoryDaoImpl 主要是测试用的，其只是简单的将用户信息保存在内存中。使用 NameSpace 时，使用 user-service 元素 Spring Security 底层使用的 UserDetailsService 就是 InMemoryDaoImpl。此时，我们可以简单的使用 user 元素来定义一个 UserDetails。 123&lt;user-service&gt; &lt;user name=&quot;user&quot; password=&quot;user&quot; authorities=&quot;ROLE_USER&quot;/&gt;&lt;/user-service&gt; 如上配置表示我们定义了一个用户 user，其对应的密码为 user，拥有 ROLE_USER 的权限。此外，user-service 还支持通过 properties 文件来指定用户信息，如： 1&lt;user-service properties=&quot;/WEB-INF/config/users.properties&quot;/&gt; 其中属性文件应遵循如下格式： 1username=password,grantedAuthority[,grantedAuthority][,enabled|disabled] 所以，对应上面的配置文件，我们的 users.properties 文件的内容应该如下所示： 12#username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]user=user,ROLE_USER GrantedAuthority Authentication 的 getAuthorities() 可以返回当前 Authentication 对象拥有的权限，即当前用户拥有的权限。其返回值是一个 GrantedAuthority 类型的数组，每一个 GrantedAuthority 对象代表赋予给当前用户的一种权限。GrantedAuthority 是一个接口，其通常是通过 UserDetailsService 进行加载，然后赋予给 UserDetails 的。 GrantedAuthority 中只定义了一个 getAuthority() 方法，该方法返回一个字符串，表示对应权限的字符串表示，如果对应权限不能用字符串表示，则应当返回 null。 Spring Security 针对 GrantedAuthority 有一个简单实现 SimpleGrantedAuthority。该类只是简单的接收一个表示权限的字符串。Spring Security 内部的所有 AuthenticationProvider 都是使用 SimpleGrantedAuthority 来封装 Authentication 对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyBatis官方文档 -- 入门]]></title>
      <url>%2F2016%2F10%2F17%2FMyBatis%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3--%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[MyBatis官方文档 – 入门 Introduction 简介What is MyBatis? 什么是 MyBatis ？MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records. MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Getting started 入门Installation 安装To use MyBatis you just need to include the mybatis-x.x.x.jar file in the classpath. If you are using Maven just add the following dependency to your pom.xml: 要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于 classpath 中即可。 如果使用 Maven 来构建项目，则需将下面的 dependency 代码置于 pom.xml 文件中：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; Building SqlSessionFactory from XML 从 XML 中构建 SqlSessionFactoryEvery MyBatis application centers around an instance of SqlSessionFactory. A SqlSessionFactory instance can be acquired by using the SqlSessionFactoryBuilder. SqlSessionFactoryBuilder can build a SqlSessionFactory instance from an XML configuration file, or from a custom prepared instance of the Configuration class. 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 Building a SqlSessionFactory instance from an XML file is very simple. It is recommended that you use a classpath resource for this configuration, but you could use any InputStream instance, including one created from a literal file path or a file:// URL. MyBatis includes a utility class, called Resources, that contains a number of methods that make it simpler to load resources from the classpath and other locations. 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。123String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); The configuration XML file contains settings for the core of the MyBatis system, including a DataSource for acquiring database Connection instances, as well as a TransactionManager for determining how transactions should be scoped and controlled. The full details of the XML configuration file can be found later in this document, but here is a simple example: XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务范围和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例：1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; While there is a lot more to the XML configuration file, the above example points out the most critical parts. Notice the XML header, required to validate the XML document. The body of the environment element contains the environment configuration for transaction management and connection pooling. The mappers element contains a list of mappers – the XML files and/or annotated Java interface classes that contain the SQL code and mapping definitions. 当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。 Building SqlSessionFactory without XML 不使用 XML 构建 SqlSessionFactoryIf you prefer to directly build the configuration from Java, rather than XML, or create your own configuration builder, MyBatis provides a complete Configuration class that provides all of the same configuration options as the XML file. 如果你更愿意直接从 Java 程序而不是 XML 文件中创建 configuration，或者创建你自己的 configuration 构建器，MyBatis 也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项。123456DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); Notice in this case the configuration is adding a mapper class. Mapper classes are Java classes that contain SQL Mapping Annotations that avoid the need for XML. However, due to some limitations of Java Annotations and the complexity of some MyBatis mappings, XML mapping is still required for the most advanced mappings (e.g. Nested Join Mapping). For this reason, MyBatis will automatically look for and load a peer XML file if it exists (in this case, BlogMapper.xml would be loaded based on the classpath and name of BlogMapper.class). More on this later. 注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射语句的注解从而避免了 XML 文件的依赖。不过，由于 Java 注解的一些限制加之某些 MyBatis 映射的复杂性，XML 映射对于大多数高级映射（比如：嵌套 Join 映射）来说仍然是必须的。有鉴于此，如果存在一个对等的 XML 配置文件的话，MyBatis 会自动查找并加载它（这种情况下， BlogMapper.xml 将会基于类路径和 BlogMapper.class 的类名被加载进来）。具体细节稍后讨论。 Acquiring a SqlSession from SqlSessionFactory 从 SqlSessionFactory 中获取 SqlSessionNow that you have a SqlSessionFactory, as the name suggests, you can acquire an instance of SqlSession. The SqlSession contains absolutely every method needed to execute SQL commands against the database. You can execute mapped SQL statements directly against the SqlSession instance. For example: 既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：123456SqlSession session = sqlSessionFactory.openSession();try &#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125; finally &#123; session.close();&#125; While this approach works, and is familiar to users of previous versions of MyBatis, there is now a cleaner approach. Using an interface (e.g. BlogMapper.class) that properly describes the parameter and return value for a given statement, you can now execute cleaner and more type safe code, without error prone string literals and casting. 诚然这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉，不过现在有了一种更直白的方式。使用对于给定语句能够合理描述参数和返回值的接口（比如说BlogMapper.class），你现在不但可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。 For example:1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; finally &#123; session.close();&#125; Now let’s explore what exactly is being executed here. 现在我们来探究一下这里到底是怎么执行的。 Exploring Mapped SQL Statements 探究已映射的 SQL 语句At this point you may be wondering what exactly is being executed by the SqlSession or Mapper class. The topic of Mapped SQL Statements is a big one, and that topic will likely dominate the majority of this documentation. But to give you an idea of what exactly is being run, here are a couple of examples. 现在，或许你很想知道 SqlSession 和 Mapper 到底执行了什么操作，而 SQL 语句映射是个相当大的话题，可能会占去文档的大部分篇幅。不过为了让你能够了解个大概，这里会给出几个例子。 In either of the examples above, the statements could have been defined by either XML or Annotations. Let’s take a look at XML first. The full set of features provided by MyBatis can be realized by using the XML based mapping language that has made MyBatis popular over the years. If you’ve used MyBatis before, the concept will be familiar to you, but there have been numerous improvements to the XML mapping documents that will become clear later. Here is an example of an XML based mapped statement that would satisfy the above SqlSession calls. 在上面提到的两个例子中，一个语句应该是通过 XML 定义，而另外一个则是通过注解定义。先看 XML 定义这个，事实上 MyBatis 提供的全部特性可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你以前用过 MyBatis，这个概念应该会比较熟悉。不过 XML 映射文件已经有了很多的改进，随着文档的进行会愈发清晰。这里给出一个基于 XML 映射语句的示例，它应该可以满足上述示例中 SqlSession 的调用。123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; While this looks like a lot of overhead for this simple example, it is actually very light. You can define as many mapped statements in a single mapper XML file as you like, so you get a lot of mileage out of the XML header and doctype declaration. The rest of the file is pretty self explanatory. It defines a name for the mapped statement “selectBlog”, in the namespace “org.mybatis.example.BlogMapper”, which would allow you to call it by specifying the fully qualified name of “org.mybatis.example.BlogMapper.selectBlog”, as we did above in the following example: 对于这个简单的例子来说似乎有点小题大做了，但实际上它是非常轻量级的。在一个 XML 映射文件中，你想定义多少个映射语句都是可以的，这样下来，XML 头部和文档类型声明占去的部分就显得微不足道了。文件的剩余部分具有很好的自解释性。在命名空间“org.mybatis.example.BlogMapper”中定义了一个名为“selectBlog”的映射语句，这样它就允许你使用指定的完全限定名“org.mybatis.example.BlogMapper.selectBlog”来调用映射语句，就像上面的例子中做的那样：1Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101); Notice how similar this is to calling a method on a fully qualified Java class, and there’s a reason for that. This name can be directly mapped to a Mapper class of the same name as the namespace, with a method that matches the name, parameter, and return type as the mapped select statement. This allows you to very simply call the method against the Mapper interface as you saw above, but here it is again in the following example: 你可能注意到这和使用完全限定名调用 Java 对象的方法是相似的，之所以这样做是有原因的。这个命名可以直接映射到在命名空间中同名的 Mapper 类，并在已映射的 select 语句中的名字、参数和返回类型匹配成方法。这样你就可以向上面那样很容易地调用这个对应 Mapper 接口的方法。不过让我们再看一遍下面的例子：12BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101); The second approach has a lot of advantages. First, it doesn’t depend on a string literal, so it’s much safer. Second, if your IDE has code completion, you can leverage that when navigating your mapped SQL statements. 第二种方法有很多优势，首先它不是基于字符串常量的，就会更安全；其次，如果你的 IDE 有代码补全功能，那么你可以在有了已映射 SQL 语句的基础之上利用这个功能。 NOTE A note about namespaces. Namespaces were optional in previous versions of MyBatis, which was confusing and unhelpful. Namespaces are now required and have a purpose beyond simply isolating statements with longer, fully-qualified names. Namespaces enable the interface bindings as you see here, and even if you don’t think you’ll use them today, you should follow these practices laid out here in case you change your mind. Using the namespace once, and putting it in a proper Java package namespace will clean up your code and improve the usability of MyBatis in the long term. Name Resolution: To reduce the amount of typing, MyBatis uses the following name resolution rules for all named configuration elements, including statements, result maps, caches, etc. Fully qualified names (e.g. “com.mypackage.MyMapper.selectAllThings”) are looked up directly and used if found. Short names (e.g. “selectAllThings”) can be used to reference any unambiguous entry. However if there are two or more (e.g. “com.foo.selectAllThings and com.bar.selectAllThings”), then you will receive an error reporting that the short name is ambiguous and therefore must be fully qualified. 提示 命名空间的一点注释 命名空间（Namespaces）在之前版本的 MyBatis 中是可选的，容易引起混淆因此是没有益处的。现在的命名空间则是必须的，目的是希望能比只是简单的使用更长的完全限定名来区分语句更进一步。 命名空间使得你所见到的接口绑定成为可能，尽管你觉得这些东西未必用得上，你还是应该遵循这里的规定以防哪天你改变了主意。出于长远考虑，使用命名空间，并将它置于合适的 Java 包命名空间之下，你将拥有一份更加整洁的代码并提高了 MyBatis 的可用性。 命名解析：为了减少输入量，MyBatis 对所有的命名配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。 完全限定名（比如“com.mypackage.MyMapper.selectAllThings”）将被直接查找并且找到即用。 短名称（比如“selectAllThings”）如果全局唯一也可以作为一个单独的引用。如果不唯一，有两个或两个以上的相同名称（比如“com.foo.selectAllThings ”和“com.bar.selectAllThings”），那么使用时就会收到错误报告说短名称是不唯一的，这种情况下就必须使用完全限定名。 There’s one more trick to Mapper classes like BlogMapper. Their mapped statements don’t need to be mapped with XML at all. Instead they can use Java Annotations. For example, the XML above could be eliminated and replaced with: 对于像 BlogMapper 这样的映射器类（Mapper class）来说，还有另一招来处理。它们的映射的语句可以不需要用 XML 来做，取而代之的是可以使用 Java 注解。比如，上面的 XML 示例可被替换如下：12345package org.mybatis.example;public interface BlogMapper &#123; @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;) Blog selectBlog(int id);&#125; The annotations are a lot cleaner for simple statements, however, Java Annotations are both limited and messier for more complicated statements. Therefore, if you have to do anything complicated, you’re better off with XML mapped statements. 对于简单语句来说，注解使代码显得更加简洁，然而 Java 注解对于稍微复杂的语句就会力不从心并且会显得更加混乱。因此，如果你需要做很复杂的事情，那么最好使用 XML 来映射语句。 It will be up to you and your project team to determine which is right for you, and how important it is to you that your mapped statements be defined in a consistent way. That said, you’re never locked into a single approach. You can very easily migrate Annotation based Mapped Statements to XML and vice versa. 选择何种方式以及映射语句的定义的一致性对你来说有多重要这些完全取决于你和你的团队。换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。 Scope and Lifecycle 范围和生命周期It’s very important to understand the various scopes and lifecycles classes we’ve discussed so far. Using them incorrectly can cause severe concurrency problems. 理解我们目前已经讨论过的不同范围和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。 NOTE Object lifecycle and Dependency Injection Frameworks Dependency Injection frameworks can create thread safe, transactional SqlSessions and mappers and inject them directly into your beans so you can just forget about their lifecycle. You may want to have a look at MyBatis-Spring or MyBatis-Guice sub-projects to know more about using MyBatis with DI frameworks. 提示 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器（mapper）并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。如果对如何通过依赖注入框架来使用 MyBatis 感兴趣可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 SqlSessionFactoryBuilderThis class can be instantiated, used and thrown away. There is no need to keep it around once you’ve created your SqlSessionFactory. Therefore the best scope for instances of SqlSessionFactoryBuilder is method scope (i.e. a local method variable). You can reuse the SqlSessionFactoryBuilder to build multiple SqlSessionFactory instances, but it’s still best not to keep it around to ensure that all of the XML parsing resources are freed up for more important things. 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。 SqlSessionFactoryOnce created, the SqlSessionFactory should exist for the duration of your application execution. There should be little or no reason to ever dispose of it or recreate it. It’s a best practice to not rebuild the SqlSessionFactory multiple times in an application run. Doing so should be considered a “bad smell”. Therefore the best scope of SqlSessionFactory is application scope. This can be achieved a number of ways. The simplest is to use a Singleton pattern or Static Singleton pattern. SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳范围是应用范围。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSessionEach thread should have its own instance of SqlSession. Instances of SqlSession are not to be shared and are not thread safe. Therefore the best scope is request or method scope. Never keep references to a SqlSession instance in a static field or even an instance field of a class. Never keep references to a SqlSession in any sort of managed scope, such as HttpSession of the Servlet framework. If you’re using a web framework of any sort, consider the SqlSession to follow a similar scope to that of an HTTP request. In other words, upon receiving an HTTP request, you can open a SqlSession, then upon returning the response, you can close it. Closing the session is very important. You should always ensure that it’s closed within a finally block. The following is the standard pattern for ensuring that SqlSessions are closed: 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理范围中，比如 Serlvet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的范围中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; Using this pattern consistently throughout your code will ensure that all database resources are properly closed. 在你的所有的代码中一致性地使用这种模式来保证所有数据库资源都能被正确地关闭。 Mapper Instances 映射器实例Mappers are interfaces that you create to bind to your mapped statements. Instances of the mapper interfaces are acquired from the SqlSession. As such, technically the broadest scope of any mapper instance is the same as the SqlSession from which they were requested. However, the best scope for mapper instances is method scope. That is, they should be requested within the method that they are used, and then be discarded. They do not need to be closed explicitly. While it’s not a problem to keep them around throughout a request, similar to the SqlSession, you might find that managing too many resources at this level will quickly get out of hand. Keep it simple, keep Mappers in the method scope. The following example demonstrates this practice. 映射器是创建用来绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，映射器实例的最大范围是和 SqlSession 相同的，因为它们都是从 SqlSession 里被请求的。尽管如此，映射器实例的最佳范围是方法范围。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求范围（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个范围上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法范围（method scope）内。下面的示例就展示了这个实践：1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); // do work&#125; finally &#123; session.close();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim速查卡]]></title>
      <url>%2F2016%2F10%2F15%2Fvim%E9%80%9F%E6%9F%A5%E5%8D%A1%2F</url>
      <content type="text"><![CDATA[vim速查卡这个速查卡来自这里。其用颜色标注了级别： Green = 存活级 Yellow = 感觉良好 Orange/Blue = 高级 Red = 专家级 你还可以下载PDF版的和Excel版的，如果你是色盲的话，还有蓝色版PDF的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>%2F2016%2F10%2F13%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Fork自Github 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 感谢 Markdown 免费编辑器 概述 宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： &amp;copy; Markdown 会保留它不动。而若你写： AT&amp;T Markdown 就会将它转为： AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue 等同于： + Red + Green + Blue 也等同于： - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： &lt;ol&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;McHale&lt;/li&gt; &lt;li&gt;Parish&lt;/li&gt; &lt;/ol&gt; 如果你的列表标记写成： 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt;标签包起来，举例来说： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;Magic&lt;/li&gt; &lt;/ul&gt; 但是这个： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： * This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： &lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt; an example&lt;/a&gt; inline link.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成： &lt;em&gt;single asterisks&lt;/em&gt; &lt;em&gt;single underscores&lt;/em&gt; &lt;strong&gt;double asterisks&lt;/strong&gt; &lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \*this text is surrounded by literal asterisks\* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（` ），例如： Use the `printf()` function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don&apos;t use any `&lt;blink&gt;` tags. 转为： &lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &lt;address@example.com&gt; Markdown 会转成： &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65; &amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111; &amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61; &amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 感谢 感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。 感谢 fenprace，addv。 Markdown 免费编辑器 Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) 高级应用 Sublime Text 2 + MarkdownEditing / 教程 *** 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown快速入门]]></title>
      <url>%2F2016%2F10%2F10%2Fmarkdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Fork自Github 段落、标题、区块代码一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;‘ 角括号。 Markdown 语法: A First Level Header ==================== A Second Level Header --------------------- Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog&apos;s back. ### Header 3 &gt; This is a blockquote. &gt; &gt; This is the second paragraph in the blockquote. &gt; &gt; ## This is an H2 in a blockquote 输出 HTML 为： &lt;h1&gt;A First Level Header&lt;/h1&gt; &lt;h2&gt;A Second Level Header&lt;/h2&gt; &lt;p&gt;Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.&lt;/p&gt; &lt;p&gt;The quick brown fox jumped over the lazy dog&apos;s back.&lt;/p&gt; &lt;h3&gt;Header 3&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;This is a blockquote.&lt;/p&gt; &lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt; &lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt; &lt;/blockquote&gt; 修辞和强调Markdown 使用星号和底线来标记需要强调的区段。 Markdown 语法: Some of these words *are emphasized*. Some of these words _are emphasized also_. Use two asterisks for **strong emphasis**. Or, if you prefer, __use two underscores instead__. 输出 HTML 为: &lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;. Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;. Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt; 列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号： * Candy. * Gum. * Booze. 加号： + Candy. + Gum. + Booze. 和减号 - Candy. - Gum. - Booze. 都会输出 HTML 为： &lt;ul&gt; &lt;li&gt;Candy.&lt;/li&gt; &lt;li&gt;Gum.&lt;/li&gt; &lt;li&gt;Booze.&lt;/li&gt; &lt;/ul&gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记： 1. Red 2. Green 3. Blue 输出 HTML 为： &lt;ol&gt; &lt;li&gt;Red&lt;/li&gt; &lt;li&gt;Green&lt;/li&gt; &lt;li&gt;Blue&lt;/li&gt; &lt;/ol&gt; 如果你在项目之间插入空行，那项目的内容会用 &lt;p&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。 * A list item. With multiple paragraphs. * Another item in the list. 输出 HTML 为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt; &lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 链接Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。 行内形式是直接在后面用括号直接接上链接： This is an [example link](http://example.com/). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 你也可以选择性的加上 title 属性： This is an [example link](http://example.com/ &quot;With a Title&quot;). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容： I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 输出 HTML 为： &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写： I start my morning with a cup of coffee and [The New York Times][NY Times]. [ny times]: http://www.nytimes.com/ 输出 HTML 为： &lt;p&gt;I start my morning with a cup of coffee and &lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt; 图片图片的语法和链接很像。 行内形式（title 是选择性的）： ![alt text](/path/to/img.jpg &quot;Title&quot;) 参考形式： ![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot; 上面两种方法都会输出 HTML 为： &lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码： I strongly recommend against using any `&lt;blink&gt;` tags. I wish SmartyPants used named entities like `&amp;mdash;` instead of decimal-encoded entites like `&amp;#8212;`. 输出 HTML 为： &lt;p&gt;I strongly recommend against using any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; &lt;p&gt;I wish SmartyPants used named entities like &lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encoded entites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt; 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。 Markdown 语法: If you want your page to validate under XHTML 1.0 Strict, you&apos;ve got to put paragraph tags in your blockquotes: &lt;blockquote&gt; &lt;p&gt;For example.&lt;/p&gt; &lt;/blockquote&gt; 输出 HTML 为： &lt;p&gt;If you want your page to validate under XHTML 1.0 Strict, you&apos;ve got to put paragraph tags in your blockquotes:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt; &amp;lt;/blockquote&amp;gt; &lt;/code&gt;&lt;/pre&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简明 Vim 练级攻略(转)]]></title>
      <url>%2F2016%2F10%2F06%2F%E7%AE%80%E6%98%8Evim%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5%2F</url>
      <content type="text"><![CDATA[简明 Vim 练级攻略，转自酷壳 前言你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。 Vim the Six Billion Dollar editor1Better, Stronger, Faster. 学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。 我建议下面这四个步骤： 存活 感觉良好 觉得更好，更强，更快 使用VIM的超能力 当你走完这篇文章，你会成为一个vim的 superstar。 在开始学习以前，我需要给你一些警告： 学习vim在开始时是痛苦的。 需要时间 需要不断地练习，就像你学习一个乐器一样。 不要期望你能在3天内把vim练得比别的编辑器更有效率。 事实上，你需要2周时间的苦练，而不是3天。 第一级 – 存活 安装 vim 启动 vim 什么也别干！请先阅读当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作： 启动Vim后，vim在 Normal 模式下。 让我们进入 Insert 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了） 此时，你可以输入文本了，就像你用“记事本”一样。 如果你想返回 Normal 模式，请按 ESC 键。 现在，你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令，可以让你在 Normal 模式下幸存下来：12345678910i → Insert 模式，按 ESC 回到 Normal 模式.x → 删当前光标所在的一个字符。:wq → 存盘 + 退出 (:w 存盘, :q 退出)dd → 删除当前行，并把删除的行存到剪贴板里p → 粘贴剪贴板推荐:hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。:help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q） 你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。 当是，在你进入第二级时，需要再说一下 Normal 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 Ctrl 键，比如：Ctrl-C。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，在VIM的Normal模式下，所有的键就是功能键了。这个你需要知道。 标记: 下面的文字中，如果是 Ctrl-λ我会写成 &lt;C-λ&gt;. 以 : 开始的命令你需要输入 &lt;enter&gt;回车，例如 — 如果我写成 :q 也就是说你要输入 :q&lt;enter&gt;. 第二级 – 感觉良好上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键） 各种插入模式 a → 在光标后插入 o → 在当前行后插入一个新行 O → 在当前行前插入一个新行 cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 /pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个） 拷贝/粘贴（陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前） P → 粘贴 yy → 拷贝当前行当行于 ddP Undo/Redo u → undo &lt;C-r&gt; → redo 打开/保存/退出/改变文件(Buffer) :e &lt;path/to/file&gt; → 打开一个文件 :w → 存盘 :saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt; :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车) :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件） 花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。 第三级 – 更好，更强，更快先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。 更好下面，让我们看一下vim是怎么重复自己的： . → (小数点) 可以重复上一次的命令 N&lt;command&gt; → 重复某个命令N次下面是一个示例，找开一个文件你可以试试下面的命令：123452dd → 删除2行3p → 粘贴文本3次100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “. → 重复上一个命令—— 100 “desu “.3. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊). 更强你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。 NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行） gg → 到第一行。（陈皓注：相当于1G，或 :1） G → 到最后一行。 按单词移动 w → 到下一个单词的开头。 e → 到下一个单词的结尾。 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量） 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句） 下面，让我来说说最强的光标移动 % : 匹配括号移动，包括 (, {, [. （陈皓注：你需要把光标先移到括号上） *和#: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） 相信我，上面这三个命令对程序员来说是相当强大的。 更快你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干： &lt;start position&gt;&lt;command&gt;&lt;end position&gt; 例如 0y$ 命令意味着: 0 → 先到行头 y → 从这里开始拷贝 $ → 拷贝到本行最后一个字符 你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。 你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。 还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝： d (删除 ) v (可视化的选择) gU (变大写) gu (变小写) 等等（陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等） 第四级 – Vim 超能力你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。 在当前行上移动光标: 0 ^ $ f F t T , ; 0 → 到行头 ^ → 到本行的第一个非blank字符 $ → 到行尾 g_ → 到本行最后一个不是blank字符的位置。 fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。 t, → 到逗号前的第一个字符。逗号可以变成其它字符。 3fa → 在当前行查找第三个出现的a。 F 和 T → 和 f 和 t 一样，只不过是相反方向。 还有一个很有用的命令是 dt” → 删除所有的内容，直到遇到双引号—— “。 区域选择在visual 模式下，这些命令很强大，其命令格式为 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt; action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：”、 ‘、 )、 }、 ]。 假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。 vi” → 会选择 foo. va” → 会选择 “foo”. vi) → 会选择 “foo”. va) → 会选择(“foo”). v2i) → 会选择 map (+) (“foo”) v2a) → 会选择 (map (+) (“foo”)) 块操作: &lt;C-v&gt;块操作，典型的操作： 0 &lt;C-v&gt; &lt;C-d&gt; I– [ESC] 0 → 到行头 &lt;C-v&gt; → 开始块操作 &lt;C-d&gt; → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) I– [ESC] → I是插入，插入“–”，按ESC键来为每一行生效。在Windows下的vim，你需要使用 &lt;C-q&gt; 而不是 &lt;C-v&gt; ，&lt;C-v&gt; 是拷贝剪贴板。 自动提示： &lt;C-n&gt; 和 &lt;C-p&gt;在 Insert 模式下，你可以输入一个词的开头，然后按 &lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了…… 宏录制：qa 操作序列 q, @a, @@ qa 把你的操作记录在寄存器 a。 于是 @a 会replay被录制的宏。 @@ 是一个快捷键用来replay最新录制的宏。 示例:在一个只有一行且这一行只有“1”的文本中，键入如下命令： qaYp&lt;C-a&gt;q→ qa 开始录制 Yp 复制行. &lt;C-a&gt; 增加1. q 停止录制. @a → 在1下面写下 2 @@ → 在2 正面写下3 现在做 100@@ 会创建新的100行，并把数据增加到 103. 可视化选择： v,V,&lt;C-v&gt;前面，我们看到了 &lt;C-v&gt;的示例 （在Windows下应该是&lt;C-q&gt;），我们可以使用 v 和 V。一但被选好了，你可以做下面的事： J → 把所有的行连接起来（变成一行） &lt;或 &gt; → 左右缩进 = → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）在所有被选择的行后加上点东西： &lt;C-v&gt; 选中相关的行 (可使用 j 或 &lt;C-d&gt; 或是 /pattern 或是 % 等……) $ 到行最后 A, 输入字符串，按 ESC。 分屏::split 和 vsplit.下面是主要的命令，你可以使用VIM的帮助 :help split. 你可以参考本站以前的一篇文章VIM分屏。 :split → 创建分屏 (:vsplit创建垂直分屏) &lt;C-w&gt;&lt;dir&gt; : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。 &lt;C-w&gt;_ (或 &lt;C-w&gt;|) : 最大化尺寸 (&lt;C-w&gt;| 垂直分屏) &lt;C-w&gt;+ (或 &lt;C-w&gt;-) : 增加尺寸结束语 上面是作者最常用的90%的命令。 我建议你每天都学1到2个新的命令。 在两到三周后，你会感到vim的强大的。 有时候，学习VIM就像是在死背一些东西。 幸运的是，vim有很多很不错的工具和优秀的文档。 运行vimtutor直到你熟悉了那些基本命令。 其在线帮助文档中你应该要仔细阅读的是 :help usr_02.txt. 你会学习到诸如 !， 目录，寄存器，插件等很多其它的功能。 学习vim就像学弹钢琴一样，一旦学会，受益无穷。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装mongoDB]]></title>
      <url>%2F2016%2F10%2F03%2F%E5%AE%89%E8%A3%85mongoDB%2F</url>
      <content type="text"><![CDATA[安装mongoDB 下载安装包下载 解压 1tar -zxvf mongodb-osx-x86_64-3.2.10.tgz 移动到安装位置 12mkdir -p /usr/local/mongodbsudo mv mongodb-osx-x86_64-3.2.10/ /usr/local/mongobd 添加到环境变量 1export PATH=$PATH:/usr/local/mongodb/mongodb-osx-x86_64-3.2.10/bin 创建data文件夹 1234cd /mkdir -p /data/dbmkdir -p /data/logsudo chown -R lingyv /data 运行 1mongod 进入mongoDB shell 1mongo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java--相对路径]]></title>
      <url>%2F2016%2F10%2F01%2F%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[Java开发中的绝对路径与相对路径 基本概念绝对路径文件或目录在硬盘上真正的路径。例如D:\abc\test.txt 代表了test.txt文件的绝对路径。http://blog.lingyv.org/index.htm也代表了一个URL绝对路径。 相对路径相对与某个基准文件或目录的路径。例如：”./“ 代表当前目录, “../“代表上级目录。 JSP/Servlet中的相对路径服务器端服务器中解析相对地址是相对于web应用的地址，例如web应用为test，那么”/user/login”在浏览器中的地址就是”http://localhost:8080/test/user/login“ 客户端浏览器解析html时，相对地址是相对于服务器根目录的，例如”/user/login”地址是”http://localhost:8080/user/login“ 问题由于浏览器解析html时，相对地址是相对于服务器根目录的，所以如果我们在html文件中使用相对路径(./，../)定位js，css等，当我们通过转发forward访问该文件时，js，css等静态的url就会出错，导致定位不到这些资源。 解决既然我们想要自定义站点，那肯定不能把绝对路径写死，但又不能用相对路径，因为转发时又会出问题。那怎么办呢？写一个可以变化的绝对路径吧，jsp中使用${pageContext.request.contextPath}来获取站点信息，然后写到绝对路径里。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RIME快速指南]]></title>
      <url>%2F2016%2F09%2F20%2FRIME%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[RIME快速指南 數據文件分佈及作用共享資料夾: 【中州韻】 /usr/share/rime-data/ 【小狼毫】 “安裝目錄\data” 【鼠鬚管】 “/Library/Input Methods/Squirrel.app/Contents/SharedSupport/“ 用戶資料夾: 【中州韻】 ~/.config/ibus/rime/ （0.9.1 以下版本爲 ~/.ibus/rime/） 【小狼毫】 “%APPDATA%\Rime” 【鼠鬚管】 ~/Library/Rime/ 共享資料夾包含預設輸入方案的源文件。 這些文件屬於 Rime 所發行軟件的一部份，在訪問權限控制較嚴格的系統上對用戶是只讀的，因此謝絕軟件版本更新以外的任何修改—— 一旦用戶修改這裏的文件，很可能影響後續的軟件升級或在升級時丟失數據。 在「部署 Rime」操作時，將用到這裏的輸入方案源文件、並結合用戶定製的內容來編譯預設輸入方案。 用戶資料夾則包含爲用戶準備的內容，如： 〔全局設定〕 default.yaml 〔發行版設定〕 weasel.yaml 〔預設輸入方案副本〕 &lt;方案標識&gt;.schema.yaml ※〔安裝信息〕 installation.yaml ※〔用戶狀態信息〕 user.yaml 編譯輸入方案所產出的二進制文件： 〔Rime 棱鏡〕 &lt;方案標識&gt;.prism.bin 〔Rime 固態詞典〕 &lt;詞典名&gt;.table.bin 〔Rime 反查詞典〕 &lt;詞典名&gt;.reverse.bin 記錄用戶寫作習慣的文件： ※〔用戶詞典〕 &lt;詞典名&gt;.userdb.kct ※〔用戶詞典快照〕 &lt;詞典名&gt;.userdb.txt、&lt;詞典名&gt;.userdb.kct.snapshot 見於同步文件夾 以及用戶自己設定的： ※〔用戶對全局設定的定製信息〕 default.custom.yaml ※〔用戶對預設輸入方案的定製信息〕 &lt;方案標識&gt;.custom.yaml ※〔用戶自製輸入方案〕及配套的詞典源文件註：以上標有 ※ 號的文件，包含用戶資料，您在清理文件時要注意備份！ 修改配置文件的方式創建一個文件名的主體部份（「.」之前）與要定製的文件相同、次級擴展名（「.yaml」之前）爲 .custom 的定製文檔：123456789patch: &quot;一級設定項/二級設定項/三級設定項&quot;: 新的設定值 &quot;另一個設定項&quot;: 新的設定值 &quot;再一個設定項&quot;: 新的設定值 &quot;含列表的設定項/@n&quot;: 列表第n個元素新的設定值,从零开始计数 &quot;含列表的設定項/@last&quot;: 列表最後一個元素新的設定值 &quot;含列表的設定項/@before 0&quot;: 在列表第一個元素之前插入新的設定值（不建議在補靪中使用） &quot;含列表的設定項/@after last&quot;: 在列表最後一個元素之後插入新的設定值（不建議在補靪中使用） &quot;含列表的設定項/@next&quot;: 在列表最後一個元素之後插入新的設定值（不建議在補靪中使用） 就是這樣：patch 定義了一組「補靪」，以源文件中的設定爲基礎，寫入新的設定項、或以新的設定值取代現有設定項的值。 定制default.yaml文件新建default.custom.yaml文件 定制每页候选数12patch: &quot;menu/page_size&quot;: 9 #候选数 定制方案选单1234567patch: schema_list: # 對於列表類型，現在無有辦法指定如何添加、消除或單一修改某項，於是要在定製檔中將整個列表替換！ - schema: luna_pinyin - schema: cangjie5 - schema: luna_pinyin_fluency - schema: luna_pinyin_simp - schema: my_coolest_ever_schema # 這樣就啓用了未曾有過的高級輸入方案！其實這麼好的方案應該排在最前面哈。 左Shift键输入字符直接切换为英文上屏，输入状态变为英文12345678patch: ascii_composer/good_old_caps_lock: true ascii_composer/switch_key: Caps_Lock: noop Shift_L: commit_code #其中L指Left，左的意思。commit-提交。code－代码。当我们输入一段文字未上屏之前，按此键后字符将被将直接上屏，RIME切换为英文输入状态。再次按此键RIME切换回中文输入状态。 Shift_R: inline_ascii #其中R指Right，右的意思。inline－直接插入。ascii－字符，美国信息交换标准码。这个设置就是RIME的默认设置，在我们输入一段文字未上屏之前，按此键后，不上屏，字符转变为英文输入，按Enter键英文字符上屏，之后默认还是中文输入。 Control_L: clear #其中clear为清除的意思。在你输入一段字符后按此键，字符被清除，同时RIME输入状态切换为英文输入。在按此键，RIME输入切换回中文输入。（与clear类似但不转换输入状态的快捷键是Esc键） Control_R: commit_text #其中text为文本的意思。在你输入一段拼音字符后，按此键，文字上屏，同时RIME切换为英文输入。在按此键，切换回来。 定制weasel.yaml文件创建weasel.custom.yaml文件 定制字体字号123patch: &quot;style/font_face&quot;: &quot;明兰&quot; # 字體名稱，從記事本等處的系統字體對話框裏能看到 &quot;style/font_point&quot;: 14 # 字號，只認數字的，不認「五號」、「小五」這樣的 定制配色方案12345678910111213patch: &quot;style/color_scheme&quot;: starcraft # 這項用於選中下面定義的新方案 &quot;preset_color_schemes/starcraft&quot;: # 在配色方案列表裏加入標識爲 starcraft 的新方案 name: 星際我爭霸／StarCraft author: Contralisk &lt;contralisk@gmail.com&gt;, original artwork by Blizzard Entertainment text_color: 0xccaa88 # 編碼行文字顏色，24位色值，用十六進制書寫方便些，順序是藍綠紅0xBBGGRR candidate_text_color: 0x30bb55 # 候選項文字顏色，當與文字顏色不同時指定 back_color: 0x000000 # 底色 border_color: 0x1010a0 # 邊框顏色，與底色相同則爲無邊框的效果 hilited_text_color: 0xfecb96 # 高亮文字，即與當前高亮候選對應的那部份輸入碼 hilited_back_color: 0x000000 # 設定高亮文字的底色，可起到凸顯高亮部份的作用 hilited_candidate_text_color: 0x60ffa8 # 高亮候選項的文字顏色，要醒目！ hilited_candidate_back_color: 0x000000 # 高亮候選項的底色，若與背景色不同就會顯出光棒 外观设置1234patch: style/horizontal: true # 候選橫排 style/inline_preedit: true # 內嵌編碼（僅支持TSF） style/display_tray_icon: true # 顯示托盤圖標 个人词库配置同步打开用户文件夹中的installation.yaml文件12installation_id: &apos;MacBook&apos;sync_dir: &apos;D:\Dropbox\RimeSync&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git快速指南--分支]]></title>
      <url>%2F2016%2F09%2F20%2Fgit%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-%E5%88%86%E6%94%AF%2F</url>
      <content type="text"><![CDATA[Git快速指南–分支 Git分支新建分支 1git branch test 切换到其他分支 1git checkout test 新建并切换到该分支 1git checkout -b test 删除分支 1git branch -d test 分支的合并 1git merge master //将当前分支与master分支合并 列出当前所有分支 1git branch 查看各个分支最后一个提交对象的信息 1git branch -v 查看哪些分支已被并入当前分支 1git branch --merged 查看尚未合并的工作 1git branch --no-merged 推送本地分支 12//git push (远程仓库名) (分支名)git push origin serverfix 这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍 refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serverfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git快速指南--基础]]></title>
      <url>%2F2016%2F09%2F10%2Fgit%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[Git快速指南–基础 简介直接记录快照，而非差异比较 Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。如图： Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。如图： 这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。 时刻保持数据完整性 在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。 Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是： 124b9da6552252987aa493b52f8696cd6d3b00373 Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。 多数操作仅添加数据 常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。 文件的三种状态 对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。 由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。 每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone –bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。 从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。 所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改某些文件。 对修改后的文件进行快照，然后保存到暂存区域。 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。 所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。 安装在 Linux 上安装 12yum install git-coreapt-get install git 在 Mac 上安装 1brew install git 在 Windows 上安装[下载](https://git-scm.com/download/win) 初次运行 Git 前的配置用户信息 123用户名称和电子邮件地址git config --global user.name &quot;lingyv&quot;git config --global user.email lingyv@gmail.com 文本编辑器 Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置： 1git config --global core.editor emacs 差异分析工具 还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： 1git config --global merge.tool vimdiff 查看配置信息 1git config --list Git基础取得项目的 Git 仓库 在工作目录中初始化新仓库 1git init 从现有仓库克隆 1git clone [url] name 记录每次更新到仓库 检查当前文件状态 1git status 跟踪新文件 1git add README.md 忽略某些文件创建一个名为 .gitignore 的文件，列出要忽略的文件模式 1234567891011# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt 提交更新 1git commit -m &quot;......&quot; 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： 1git commit -a -m &apos;......&apos; 移除文件 从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件 1git rm README.md 把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录: 1git rm --cached README.md 递归删除当前目录及其子目录中所有 ~ 结尾的文件 1git rm \*~ 移动文件 不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么。要在 Git 中对文件改名，可以这么做： 1git mv README.txt README 其实，运行 git mv 就相当于运行了下面三条命令： 123mv README.txt READMEgit rm README.txtgit add README 查看提交历史 1git log 常用的选项及其释义: 12345678910选项 说明-p 按补丁格式显示每个更新之间的差异。--stat 显示每次更新的文件修改统计信息。--shortstat 只显示 --stat 中最后的行数修改添加移除统计。--name-only 仅在提交信息后显示已修改的文件清单。--name-status 显示新增、修改、删除的文件清单。--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。--graph 显示 ASCII 图形表示的分支合并历史。--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 常用的格式占位符写法及其代表的意义 12345678910111213141516选项 说明%H 提交对象（commit）的完整哈希字串%h 提交对象的简短哈希字串%T 树对象（tree）的完整哈希字串%t 树对象的简短哈希字串%P 父对象（parent）的完整哈希字串%p 父对象的简短哈希字串%an 作者（author）的名字%ae 作者的电子邮件地址%ad 作者修订日期（可以用 -date= 选项定制格式）%ar 作者修订日期，按多久以前的方式显示%cn 提交者(committer)的名字%ce 提交者的电子邮件地址%cd 提交日期%cr 提交日期，按多久以前的方式显示%s 提交说明 例如: 1234567891011git log --pretty=format:&quot;%h %s&quot; --graph* 2d3acf9 ignore errors from SIGCHLD on trap* 5e3ee11 Merge branch &apos;master&apos; of git://github.com/dustin/grit|\| * 420eac9 Added a method for getting the current branch.* | 30e367c timeout code and tests* | 5a09431 add timeout protection to grit* | e1193f8 support for heads with slashes in them|/* d6016bc require time for xmlschema* 11d191e Merge branch &apos;defunkt&apos; into local 撤消操作 任何时候，你都有可能需要撤消刚才所做的某些操作。接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。 修改最后一次提交 1git commit --amend 此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。 启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。 取消已经暂存的文件 1git reset HEAD &lt;file&gt;... 取消对文件的修改 1git checkout -- &lt;file&gt;... 这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用 stashing 和分支来处理，应该会更好些。 记住，任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 –amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。 远程仓库的使用查看当前的远程库 要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。加上 -v 选项（译注：此为 –verbose 的简写，取首字母），显示对应的克隆地址： 1git remote -v 添加远程仓库 1git remote add [shortname] [url] 从远程仓库抓取数据 1git fetch [remote-name] 此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。 1git pull 自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。 推送数据到远程仓库 1git push [remote-name] [branch-name] 查看远程仓库信息 通过命令 git remote show [remote-name] 查看某个远程仓库的详细信息，比如要看所克隆的 origin 仓库，可以运行： 1git remote show origin 远程仓库的删除和重命名 重命名可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行： 1git remote rename pb paul 注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。 删除碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：1git remote rm paul 打标签同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。 列出现有标签 1234git tag用特定的搜索模式列出符合条件的标签git tag -l &apos;v1.4.2.*&apos; 新建标签 轻量级轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。 含附注含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可: 1git tag -a v1.4 -m &apos;my version 1.4&apos; -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。 签署标签如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可： 1git tag -s v1.5 -m &apos;my signed 1.5 tag&apos; 轻量级标签轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可： 1git tag v1.4 验证标签可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证： 1git tag -v v1.4 后期加注标签在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可： 1git tag -a v1.2 9fceb02 分享标签默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可： 1git push origin v1.5 如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux安装JDK]]></title>
      <url>%2F2016%2F09%2F01%2Flinux%E5%AE%89%E8%A3%85JDK%2F</url>
      <content type="text"><![CDATA[linux系统安装JDK 卸载JDK 先查看系统是否已安装JDK，一般情况下linux都默认使用了开源的openJDK。 1java -version 查找名字包含java，jdk的已安装程序 12rpm -qa | grep java rpm -qa | grep jdk 单个卸载程序，使用rpm -e xxx命令 1rpm -e xxx 批量卸载所有名字包含xxx的已安装程序 1rpm -qa | grep xxx | xargs rpm -e --nodeps 安装JDK.rpm后缀格式JDK安装包 安装包添加权限 1chmod 755 jdk-xxx.rpm 使用rpm -ivh xxx命令安装JDK 1rpm -ivh jdk-xxx.rpm 安装.rpm格式后缀的JDK，会自动配置java环境变量，会在/usr/bin生成java、javac等JDK的快捷方式图标,这些图标会链接指向到/usr/java/jdkxxx中 .tar.gz后缀格式JDK安装包 在/usr目录下新建java文件夹 1mkdir /usr/java 压缩包解压 1tar -zxvf jdk-xxx.gz 设置jdk环境变量 12345678vi /etc/profileexport JAVA_HOME=/usr/java/jdkxxxexport JRE_HOME=$JAVA_HOME/jreexport PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/libsource /etc/profile]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java知识点(转)]]></title>
      <url>%2F2016%2F08%2F27%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[Java知识点，转自Grife JAVA相关 Java GC机制(重要程度:★★★★★) 主要从三个方面回答:GC是针对什么对象进行回收(可达性分析法)，什么时候开始GC(当新生代满了会进行Minor GC，升到老年代的对象大于老年代剩余空间时会进行Major GC)，GC做什么(新生代采用复制算法，老年代采用标记-清除或标记-整理算法)，感觉回答这些就差不多了，也可以补充一下可以调优的参数(-XX:newRatio,-Xms,-Xmx等等)。详细的可以看我另一篇博客Java中的垃圾回收机制。 如何线程安全的使用HashMap(重要程度:★★★★★) 作为Java程序员还是经常和HashMap打交道的，所以HashMap的一些原理还是搞搞清除比较好。这个问题感觉主要就是问HashMap，HashTable，ConcurrentHashMap，sychronizedMap的原理和区别。具体的可以看我另一篇博客如何线程安全的使用HashMap。 HashMap是如何解决冲突的(重要程度:★★★★☆) 其实就是链接法，将索引值相同的元素存放到一个单链表里。但为了解决在频繁冲突时HashMap性能降低的问题，Java 8中做了一个小优化，在冲突的元素个数超过设定的值(默认为8)时，会使用平衡树来替代链表存储冲突的元素。具体的可以看我另一篇博客Java 8中HashMap和LinkedHashMap如何解决冲突。 Java创建对象有哪几种(重要程度:★★★★☆) 这个问题还算好回答，大概有四种—new、工厂模式、反射和克隆，不过这个问题有可能衍生出关于设计模式，反射，深克隆，浅克隆等一系列问题。。。要做好准备~ 参考资料：设计模式Java版、Java反射详解、深克隆与浅克隆的区别 注解(重要程度:★★★☆☆) 如果简历中有提到过曾自定义过注解，还是了解清楚比较好。主要是了解在自定义注解时需要使用的两个主要的元注解@Retention和@Target。@Retention用来声明注解的保留策略，有CLASS，RUNTIME,SOURCE三种，分别表示注解保存在类文件，JVM运行时刻和源代码中。@Target用来声明注解可以被添加到哪些类型的元素上，如类型，方法和域等。 参考资料：Java注解 异常(重要程度:★★★☆☆) 一道笔试题，代码如下，问返回值是什么。1234567891011int ret = 0;try&#123; throw new Exception();&#125;catch(Exception e)&#123; ret = 1; return ret;&#125;finally&#123; ret = 2;&#125; 主要的考点就是catch中的return在finally之后执行 但是会将return的值放到一个地方存起来，所以finally中的ret=2会执行，但返回值是1。 参考资料：深入理解Java异常处理机制,Java异常处理 悲观锁和乐观锁区别，乐观锁适用于什么情况(重要程度:★★★★☆) 悲观锁，就是总觉得有刁民想害朕，每次访问数据的时候都觉得会有别人修改它，所以每次拿数据时都会上锁，确保在自己使用的过程中不会被他人访问。乐观锁就是很单纯，心态好，所以每次拿数据的时候都不会上锁，只是在更新数据的时候去判断该数据是否被别人修改过。大多数的关系数据库写入操作都是基于悲观锁，缺点在于如果持有锁的客户端运行的很慢，那么等待解锁的客户端被阻塞的时间就越长。Redis的事务是基于乐观锁的机制，不会在执行WATCH命令时对数据进行加锁，只是会在数据已经被其他客户端抢先修改了的情况下，通知执行WATCH命令的客户端。乐观锁适用于读多写少的情况，因为在写操作比较频繁的时候，会不断地retry，从而降低性能。 参考资料：关于悲观锁和乐观锁的区别,乐观锁和悲观锁 单例模式找错误(重要程度:★★★★☆) 错误是没有将构造函数私有化，单例还是比较简单的，把它的饿汉式和懒汉式的两种实现方式看明白了就可以了。单例模式 Spring相关关于Spring的问题主要就是围绕着Ioc和AOP，它们真是Spring的核心啊。 Spring Bean的生命周期(重要程度:★★★★★) 就不写我那么low的回答了，直接看参考资料吧。 参考资料：Spring Bean的生命周期,Top 10 Spring Interview Questions Answers J2EE Spring中用到的设计模式(重要程度:★★★★★) 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例 只知道这四个。。。。参考资料:Design Patterns Used in Java Spring Framework 讲一讲Spring IoC和AOP(重要程度:★★★★★) IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。 AOP的应用场景(重要程度:★★★★☆) 权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。 Spring中编码统一要如何做(重要程度:★★★☆☆) 配置一个拦截器就行了12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 数据库相关 Mysql索引的内部结构(重要程度:★★★★☆) B+树，三层，真实的数据存储在叶子节点 参考资料:MySQL索引原理及慢查询优化 如果一个SQL执行时间比较长怎么办(重要程度:★★★★☆) 可以利用pt-query-digest等工具分析慢查询日志，也可以用explain查看SQL的执行计划。具体可看我的另一篇博客MySQL调优 如果一张表中有上千万条数据应该怎么做分页(重要程度:★★★☆☆) 肯定不能直接limit,offset，主要就是要想办法避免在数据量大时扫描过多的记录。具体可看我的另一篇博客【译】优化MySQL中的分页 什么样的列适合加索引，如果一个列的值只有1和2，那么它适合加索引么(重要程度:★★★☆☆) 在where从句，group by从句，order by从句，on从句中出现的列 索引的字段越小越好 在建立联合索引时，离散度大的列放大联合索引的前面 只有1和2不适合建索引 算法相关 判断一个数字是否为快乐数字(重要程度:★☆☆☆☆) leetcode第202题 给定一个乱序数组和一个目标数字 找到和为这个数字的两个数字 时间复杂度是多少(重要程度:★☆☆☆☆) leetcode第一题 如何判断一个链表有没有环(重要程度:★☆☆☆☆) 用快慢指针 删除字符串中的空格 只留一个(重要程度:★☆☆☆☆) 这个比较简单。。。。 二叉树层序遍历(重要程度:★★☆☆☆) 利用队列就可以了 地铁票价是如何计算的(重要程度:★★☆☆☆) 不知道正确答案，感觉是图的最短路径算法相关的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HotSpot虚拟机之定位对象]]></title>
      <url>%2F2016%2F08%2F23%2FHotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9A%E4%BD%8D%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记。HotSpot虚拟机定位对象过程。建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作栈上的具体对象。reference类型规定了一个指向对象的引用，这个对象引用有两种实现方式–”使用句柄”和”直接指针”。 使用句柄，Java堆中划分出一块内存来作为句柄池。reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。如图： 使用直接指针，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。如图： 各自优势： 句柄访问：reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时)时只会改变句柄中的实例数据指针，而reference本身不需要修改。 直接指针：速度更快，节省了一次指针定位的时间开销。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HotSpot虚拟机之创建对象]]></title>
      <url>%2F2016%2F08%2F20%2FHotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记。HotSpot虚拟机创建对象过程。 虚拟机遇到一条new指令时，首先将去检查这个指令的参数能否在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先执行相应的类的加载过程。 接下来虚拟机将为新生对象分配内存，对象所需内存在类加载完成后便可完全确定，为对象分配内存空间的过程等同于把一块确定大小的内存从Java堆中划分出来。分配方式有”指针碰撞”和”空闲列表”两种。 虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。这一步操作保证过了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM之内存]]></title>
      <url>%2F2016%2F08%2F15%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%2F</url>
      <content type="text"><![CDATA[《深入理解Java虚拟机：JVM高级特性与最佳实践》读书笔记。Java虚拟机在执行Java程序时，会把它管理的内存划分为不同的数据区域，根据&lt;Java虚拟机规范》的规定，Java虚拟机管理的内存包括一下几个运行时数据区域： 各内存的作用： 程序计数器 程序计数器是一块比较小的内存，可以看作是当前线程所执行字节码的行号指示器。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现，在任何一个确定的时刻，一个处理器(多核处理器是一个内核)都只会执行一条线程中的指令。所以，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器。因此，这块内存是线程私有的。 如果线程正在执行的是Native方法，这个计数器的值则为空。 Java虚拟机栈 Java虚拟机栈是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息。 每个方法从调用至执行完成的过程，对应于一个栈桢在虚拟机栈中入栈到出栈的过程。 其中，局部变量表存放了编译期可知的各种基本数据类型、对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址)。 局部变量表所需要的内存在编译期间完成分配,在运行方法期间不改变局部变量表的大小。 本地方法栈 本地方法栈的作用与虚拟机栈非常相似。 他们的区别是虚拟机栈为虚拟机执行Java方法(字节码)服务，本地方法栈为虚拟机所使用到的Native方法服务。 Java堆 Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。 Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存(Java虚拟机规范:所有的对象实例以及数组都要在堆上分配)。 Java堆是垃圾收集器管理的主要区域，因此也称作”GC堆”(Garbage Collected Heap)。 Java堆可已处于物理上不连续的内存空间中，只有逻辑上连续即可。可通过(-Xmx和-Xms控制大小)。 方法区 方法区是线程共享的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但他却又一个别名–Non-Heap(非堆),以和Java堆区分开。运行时常量池是方法区的一部分，用于存放各种字面量和符号引用。 异常信息： 程序计数器：此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域 Java虚拟机栈： 如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常 如果虚拟机栈扩展时无法申请到足够的内存，抛出OutOfMemoryError异常 本地方法栈： 如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常 如果虚拟机栈扩展时无法申请到足够的内存，抛出OutOfMemoryError异常 Java堆： 如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OutOfMemoryError异常 出现Java堆内存溢出时，异常堆栈信息”java.lang.OutOfMemoryError”会跟着进一步提示”Java heap space”。 当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim懒人福音--spf13-vim]]></title>
      <url>%2F2016%2F08%2F12%2Fspf13-vim%2F</url>
      <content type="text"><![CDATA[是不是羡慕编辑器之神–vim，却又讨厌各种繁琐的配置文件？现在好了，有了spf-13，我们不用配置各种繁琐的配置文件了。废话少说，下面来说具体怎么做： 首先，确认Git 1.7+ 和 Vim 7.3+Linux, * nix, Mac OSX系统,执行以下命令安装spf13-vim： 1curl https://j.mp/spf13-vim3 -L &gt; spf13-vim.sh &amp;&amp; sh spf13-vim.sh 安装好就可以使用了。不过，一般我们需要做一些个性化的定制。 更换主题：新建一个~/.vimrc.local文件。 123colorscheme ir_black#把ir_black换成你想要换的主题#例如ir_black、molokai、peaksea 选择加载的插件：新建~/.vimrc.before.local文件： 1let g:spf13_bundle_groups=[&apos;general&apos;,&apos;writing&apos;,&apos;programming&apos;,&apos;youcompleteme&apos;,&apos;go&apos;,&apos;javascript&apos;,&apos;html&apos;] 其中“[]”里面的可以去~/.vimrc.bundles文件里面Bundles一栏去找你需要加载的组： 添加自己的组件：新建文件~/.vimrc.bundles.local，新增你需要增加的组件：1Bundle \&apos;spf13/vim-colors\&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2的世界]]></title>
      <url>%2F2016%2F08%2F09%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
      <content type="text"><![CDATA[二进制，顾名思义，就是逢二进一的数字系统。逢二进一，也就是说，只会出现0和1两种数字。这应该是最简单的数字系统了吧。你也许听别人提过，电脑那家伙笨的很，只知道0和1。哈哈，现在的绝大多数计算机的确是基于二进制运行的。说到这，你不是不很自豪呢？我比计算机可要知道的太多了，现在，就让我们走进2的世界吧。《道德经》有云：道生一，一生二，二生三，三生万物。现在看来功能强大无比的计算机，竟是建立在一串串不起眼的0、1上，让人不得不相信纷繁复杂的世界背后，一定蕴藏着一条简洁到极致的真理。这时候聪明的你肯定会犯嘀咕了，既然计算机只认识0和1，那负数怎么表示呢？是吧，没有“-”号，怎么表示负数呢？当然也是用0或1来表示了。这里说两个新概念，比特(bit)和字节(byte)。计算机中，一位数字称为1个比特，8位数字称为1个字节。为什么要引入字节的概念呢？这是因为1个比特只能表示两种不同的事物，而1个字节有8个比特，可以表示2^8(256)种不同的事物。那为什么一个字节是8个比特而不是9个、10个呢？实际上，字节这个概念最早是IBM提出来的，而IBM使用字节的一个原因则是它们易于以BCD这种格式保存(参见《编码的奥秘》)。既然采用一个字节进行运算，那我们完全可以约定，这8个比特的其中一位，用来标识正负。而其中的一种约定就是，最高位的比特用来标识正负号，0代表正数，1代表负数。好了，现在能表示正负数了。既然数都可以表示了，那就该做运算了。现在，我们实现一个8位加法机，实现7位的加减法。1个字节能表示的数的范围是-128~127。 一. 先来做加法运算吧： 一：0000 00010000 0011———·0000 0100这个很简单，一瞅就能2看出来结果是“0000 0100”。 二0100 00000100 0000———·1000 0000咦，不对呀。两个正数相加，结果怎么是个负数？ 三1010 00011100 0010———·0110 0011这下两个负数相加，结果怎么是正数了？这就是溢出的问题了。两个正数相加得到负数，称为正溢出。两个负数相加得到正数，称为负溢出。 加法还简单，减法怎么做呢？减法就是加上一个负数。前面说了，负数就是最高位为1的数。实际上，负数在计算机内部是采用2的补码形式存储的。2的补码是什么呢？它的转换步骤如下：比如2的2进制是 0000 0010。现在看如何存储-2 逐位取反。0000 0010 –&gt; 1111 1101 加11111 11010000 0001———·1111 1110 所以，-2在计算机中存储的是1111 1110，而不是1000 0010。为什么采用2的补码呢？先看我们最习惯的10进制看吧，24 - 16 = 8，这是两位数的减法，两位数中，最大的数是99，那么，用99减去被减数肯定就不需要借位了是吧，于是24 - 16 = 8 –&gt; 24+(99-16) + 1 - 100 = 8。 接下来我们看下 4 - 2：4是0000 0100，-2是1111 11100000 01001111 1110———·0000 0010这里生了什么呢？0000 0100 + (1111 1111 - 0000 0010) + 1 - 1 0000 0000。是不是跟10进制里面的一样？取反就是拿8位数里最大的那个数–&gt;1111 1111减去当前数。最后要减去1 0000 0000，因为我们只有8位，这里溢出的1就自动舍弃了。 那如果是2 - 4呢？2是0000 0010，-4呢？0000 0100–&gt;1111 1011–&gt;1111 11000000 00101111 1100———·1111 11101111 1110是多少呢？我们以前说过是-2。结果也是对的。 -2-2呢？1111 11101111 1110———·1111 1100结果也是对的。都是一个道理。 好了，现在我们有1个字节，可以表示256种不同的事物，我们可以给符号以及字母编码来表示文本，这就是ASCII码了。最后，提一下16进制。为什么提16进制呢？因为2^4=16。4个比特的数字对应一个16进制的数字，一个字节就可以用两个16进制数字来表示，这样读起来比8个01数字串简单多了。下面是二进制、十进制、十六进制对照表： 二进制 十进制 十六进制 二进制 十进制 十六进制 0000 0 0 1000 8 8 0001 1 1 1001 9 9 0010 2 2 1010 10 A 0011 3 3 1011 11 B 0100 4 4 1100 12 C 0101 5 5 1101 13 D 0110 6 6 1110 14 E 0111 7 7 1111 15 F]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[采矿--编码与继电器]]></title>
      <url>%2F2016%2F08%2F08%2F%E9%87%87%E7%9F%BF--%E7%BC%96%E7%A0%81%E4%B8%8E%E7%BB%A7%E7%94%B5%E5%99%A8%2F</url>
      <content type="text"><![CDATA[屠龙的第一步当然是给自己锻造一把绝世好剑，而铸剑的基础则是采矿。那就从采矿开始吧！–题记追本溯源，就要从编码开始说起了。编码，听起来很高深，其实并非如此。编：编造，码：符号。顾名思义，就是给事物编造一个个的符号用来交流喽。学过外语的都知道，对于“狗”这样一个具体的动物，不同的语言有不同的称呼：“狗”、“dog”、“chien”、“собака”……这些都可以称作编码。又例如，马上又要物理考试了，你跟你舍友约好用计算器传递选择题答案，”A”、”B”、”C”、”D”分别对应”1”、”2”、”3”、”4”。然后……愉快的60分飘过。这也是一种编码，只要你和你的小伙伴能理解就成。通信，也是为了交流。在没有电报以前，想要交流，也就是通信，怎么办呢？吼呗！距离太远，吼的听不到怎么办？跑过去吼呗！要是你没空，就雇个人跑过去吼呗，就是那么简单。直到电报的横空出世！人们发现可以用电线代替人跑腿了。不过那个时候电话还没有发明出来，你要是对着电话扯开嗓子吼，吼破喉咙它也不懂你要干嘛。那电报是怎么做的呢？这涉及到电磁现象了，不过既然做了程序猿，高中物理肯定还是懂的嘛，还不至于全还给老师吧。就是这样，一个按键和一个发声装置就组成了最简单的电报系统。当电报机的键按下时,发生器的电磁铁将可动棒拖下发出“滴”的声音;当键放开时,棒弹回初始位置,发出“嗒”的声音。快速的“嘀嗒”为点,慢速的则为划。物理装置就这样了，那我们怎么将语言翻译成点划，然后再由点划翻译回去呢？这时候，就是编码大展伸手的时候了，摩尔斯电码粉墨登场：好了，对着这张表。就可以愉快的收发电报了。但是，还有个最大的问题，就是长距离导线的电阻问题。导线越长，电阻越大，电压不变的情况下电流也就越小。小到一定程度，电报系统就不能用了。一个明显的解决办法是使用转发(中继)系统,也称继电器系统。如图继电器中，输入电流激发电磁铁,电磁铁吸引一根有弹性的金属条作为开关从而输出电流。继电器是一种卓越的设备。它是一个开关,但并不是由人工而是借助于电流进行开关操作的。如果你有耐心，利用它可以装配出一台计算机中的大部分部件。嗯！的确如此，有时间的话，我决定在“我的世界”里实现一个8位CPU的计算机。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新入坑的程序猿们，一起去屠龙吧！]]></title>
      <url>%2F2016%2F08%2F07%2F%E6%96%B0%E5%85%A5%E5%9D%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%BB%AC%EF%BC%8C%E4%B8%80%E8%B5%B7%E5%8E%BB%E5%B1%A0%E9%BE%99%E5%90%A7%2F</url>
      <content type="text"><![CDATA[我做的是JAVA编程，从大三开始决定入编程的坑开始，一瘸一拐的在编程世界跋涉也快一年半了。话说，自从半年前开始JAVA WEB编程，特别是一个月前毕业进入公司到现在，经常会在敲代码的时候，好似一个没诵读过《圣经》的传教士到处散播福音一般，心里一阵阵的发虚。为什么呢，因为我本科学的并不是计算机相关专业，没有用心的系统学过计算机底层的基础知识，底层知识不熟练，就会在编程的时候有种被架空的感觉，那种感觉，就好像刚摇摇晃晃学会骑自行车，就要骑上摩托飞奔。这种不能随心所欲控制的感觉，别提多难受了。既然如此，那就恶补基础呗。毕竟，磨砺好手中的利剑，才能开心屠龙嘛！先来看一个知乎问题,里面萧井陌大神的推荐：1234567列举几个我认为比较重要的根基并附入门书编程语言，《程序设计语言-实践之路》《concepts of programming languages》计算机通用知识，《csapp》算法、数据结构，《算法导论》程序设计、结构，没有书推荐软件工程，这个词大家理解不同，我以为，《人月》《代码大全》《the pragmatic programmer》《sicp》、讲测试讲重构的都是软件工程，其实上面设计模式也是软件工程，哈哈这些书，初时读来感觉全无作用，而且要读多次才能体会其中意味，所以叫它根基也是十分合适，你根基越深才能爬得越高嘛。 有大神指导，路就好走多了嘛，那我就从计算机系统原理开撸吧：准备看的书：《编码的奥秘》、《深入理解计算机系统》视频(准备看网易云课堂的几门课)：计算机组成原理之机器、计算机组成原理之数字、计算机组成原理之CPU、计算机系统结构 (一) 基本概念及指令集、计算机系统结构 (二) 计算机主要系统构成、计算机系统结构 (三) CPU及其结构分析接下来就是：数据结构、算法、操作系统、计算机网络、数据库、编译原理。就这样吧，感觉又挖了好大一个坑……恩！计划再好，不执行也是白搭。借用《海贼王》中路飞的一句话：“我是要成为海贼王的男人!”。来吧，一起去计算机的世界屠龙吧……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven项目创建缓慢解决方法]]></title>
      <url>%2F2016%2F07%2F20%2Fmaven%E9%A1%B9%E7%9B%AE%E7%BC%93%E6%85%A2%2F</url>
      <content type="text"><![CDATA[解决国内网络环境下，根据archetype创建Maven项目异常缓慢的问题。 原因根据archetype创建Maven项目，执行mvn archetype:generate命令时，需要指定一个archetype-catalog.xml文件。可通过该命令的-DarchetypeCatalog参数指定maven-archetype-plugin读取archetype-catalog.xml文件的位置。此参数的可选值: internal –&gt; maven-archetype-plugin内置 local –&gt; 本地，位于~/.m2/archetype-catalog.xml remote –&gt; 指向Maven中央仓库的Catalog: http://repo1.maven.org/maven2/archetype-catalog.xml file:// http://由于该参数默认为remote，从中央仓库下载archetype-catalog.xml文件。而国内访问中央仓库速度非常慢，所以导致创建过程异常缓慢。 命令行中解决方案创建时命令行中指定-DarchetypeCatalog=internal1mvn archetype:generate -DarchetypeCatalog=internal IDEA解决方案临时创建Maven项目时指定该参数 一劳永逸 点击项目默认设置 进入Maven – Runner设置窗口，指定VM Options:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC基础]]></title>
      <url>%2F2016%2F05%2F21%2FJDBC%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[掌握数据库开发是java工程师的基本要求，而JDBC是数据库开发的基础，通过JDBC可以实现Java程序对后端数据库的访问。虽然现在大多使用MyBatis，但明白JDBC的工作流程，对初学者来说还是非常必要的，学会之后能够更快速的上手MyBatis。下面我就介绍一下JDBC的基础知识。注意：学习JDBC需要有Java基础以及数据库基础。 总的来说，使用JDBC的流程大概分为：12345装载驱动程序建立与数据库的连接执行SQL语句获取执行结果清理资源 接下来逐步详细说明： 装载驱动程序说到装载驱动程序，就不得不说JDBC中的Driver类、DriverManager类。Driver类是一个接口，定义了各个驱动程序都必须实现的功能，是驱动程序的抽象。而DriverManager类是Driver类的管理类。 想要装载驱动程序，我们就要用Class.forName(DriverName)向DriverManager注册驱动程序。DriverName就是响应数据库驱动的名称。推荐用maven管理驱动程序，免去到官网下载的麻烦。例如加载mysql驱动：1Class.forName（“com.mysql.jdbc.Driver&quot;); 建立与数据库的连接想要建立与数据库的连接，就要通过DriverManager类中的getConnection()方法调用驱动程序。 getConnection()方法返回的是一个JDBC Connection对象。Connection对象其实代表的是Java应用程序对后端数据库的一条物理链接。基于这条链接，我们可以执行SQL语句。Connection对象常用的方法就是createStatement()方法，这个方法用来创建Statement对象。 调用getConnection()方法需要传入三个参数，分别是URL、UserName、PassWord。注意：使用getConnection()可能会抛出异常，所以这里要捕获异常。 例如：1Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/数据库名&quot;,&quot;root&quot;,&quot;root&quot;); URL为相应数据库的地址，包含协议、子协议、子名称三部分，其中自名称又包括主机、端口、数据库名等。例如：“jdbc:mysql://127.0.0.1:3306/数据库名”。UserName则是你部署相应数据库时设置的用户名，一般都是“root”。PassWord就是你部署相应数据库时设置的密码。 执行SQL语句要执行SQL语句，首先要用Connection连接创建Statement对象。Statement对象，说到底就是一个SQL容器，这个容器可以承载一些SQL语句。 然后调用executeQuery()方法或execute()方法执行SQL语句。其中，executeQuery()方法可执行查询操作，execute()方法更新、添加、删除等操作。执行后返回int值或ResultSet对象。ResultSet是数据库结果集的数据表。 例如：12Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery(&quot;select name from user&quot;); 获取执行结果若返回的是ResultSet对象，则要用循环取出ResultSet对象中的数据。因为ResultSet对象具有指向其当前数据行的指针。最初，指针被置于第一行之前。next方法可以将指针移动到下一行；使用该方法是会true或false(若没有下一行则返回false)，所以可以在while循环中使用它迭代结果集。(ResultSet对象的其他常用方法自行搜索其他资料，这里就不赘述了。) 例如：123while(rs.next())&#123; System.out.println(rs.getString(&quot;name&quot;));&#125; 清理资源在finally{ }方法中清理资源。例如：123456789101112131415finally&#123; try&#123; if(rs != null) rs.close(); if(stmt != null) stmt.close(); if(conn != null) conn.close(); &#125; catch(SQLException)&#123; //ignore &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet原理 三：Servlet体系结构以及工作原理]]></title>
      <url>%2F2016%2F05%2F08%2FServlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%863%2F</url>
      <content type="text"><![CDATA[注：在网上看到一篇文章–《Servlet工作原理》,整理并做了一些笔记 1. Servlet 体系结构我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。 我们应该很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？ 仔细查看 ServletConfig 接口中声明的方法就会发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能会在 Servlet 运行时被用到。 那么 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。 ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类，所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。 同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。 通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。 Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示： 2. Servlet 如何工作我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。 当用户从浏览器向服务器发起一个请求，通常会包含如下信息：http://hostname: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？ Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 : 12345678910111213public void init() &#123; findDefaultHost(); Engine engine = (Engine) connector.getService().getContainer(); engine.addContainerListener(this); Container[] conHosts = engine.findChildren(); for (Container conHost : conHosts) &#123; Host host = (Host) conHost; if (!LifecycleState.NEW.equals(host.getState())) &#123; host.addLifecycleListener(this); registerHost(host); &#125; &#125; &#125; 这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。 接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。 Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。 当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet原理 二：Web应用与创建Servlet实例]]></title>
      <url>%2F2016%2F05%2F08%2FServlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862%2F</url>
      <content type="text"><![CDATA[注：在网上看到一篇文章–《Servlet工作原理》,整理并做了一些笔记 1. Web 应用的初始化工作Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。Tomcat 首先会找 globalWebXml ，这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。然后会找 hostWebXml ，这个文件可能会在 System.getProperty(“catalina.base”)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。解析 Servlet 时会将 Servlet 包装成 Context 容器中的 StandardWrapper，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象？这是因为StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。 2. 创建 Servlet 实例前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。 创建 Servlet 对象 如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。 创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。 创建 Servlet 对象的相关类结构图如下： 初始化 Servlet 初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。 如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。这样 Servlet 对象就初始化完成了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet原理 一：Servlet容器]]></title>
      <url>%2F2016%2F05%2F07%2FServlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%861%2F</url>
      <content type="text"><![CDATA[注：在网上看到一篇文章–《Servlet工作原理》,整理并做了一些笔记 了解 Servlet 容器首先，要从servlet 容器开始。servlet容器，故名思议，就是装载和管理Servlet的服务端程序。借用一个前辈的解释：Servlet与Servlet容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。下图是Tomcat容器模型：可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程， Context 容器如何运行将直接影响 Servlet 的工作方式。 Servlet 容器启动过程Tomcat7 支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，还可以通过这个对象来增加和修改 Tomcat 的配置参数。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。 12345678910# 创建一个 Tomcat 实例Tomcat tomcat = getTomcatInstance();File appDir = new File(getBuildDirectory(), &quot;webapps/examples&quot;);# 新增一个 Web 应用tomcat.addWebapp(null, &quot;/examples&quot;, appDir.getAbsolutePath());# 启动 Tomcattomcat.start();# 调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。ByteChunk res = getUrl(&quot;http://localhost:&quot; + getPort() + &quot;/examples/servlets/servlet/HelloWorldExample&quot;); assertTrue(res.toString().indexOf(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;) &gt; 0); 一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器(StandardContext是Context的标准实现)，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作。最后将这个 Context 容器加到父容器 Host 中。 接下去将会调用 Tomcat 的 start 方法启动 Tomcat，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener）。 当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用 addWebapp 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。 ContextConfig 的 init 方法将会主要完成以下工作：12345创建用于解析 xml 配置文件的 contextDigester 对象读取默认 context.xml 配置文件，如果存在解析它读取默认 Host 配置文件，如果存在解析它读取默认 Context 自身的配置文件，如果存在解析它设置 Context 的 DocBase ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：12345678创建读取资源文件的对象创建 ClassLoader 对象设置应用的工作目录启动相关的辅助类如：logger、realm、resources 等修改启动状态，通知感兴趣的观察者（Web 应用的配置）子容器的初始化获取 ServletContext 并设置必要的参数初始化“load on startup”的 Servlet]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shell的唯一选择--zsh]]></title>
      <url>%2F2016%2F05%2F06%2Fzshshell%2F</url>
      <content type="text"><![CDATA[有些同学可能对Shell不太熟悉。借用池建强的一个解释:简单的说，Shell是Linux/Unix的一个外壳。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。Linux/Unix提供了很多种Shell，输入以下的命令查看有哪些Shell:1cat /etc/shells Linux的默认 Shell 都是 bash，既然如此，那我今天为什么要说zsh呢？因为zsh搭配上”oh my zsh”真的好用到爆啊！”oh my zsh”的Github网址点我点我！。那么如何安装、配置和使用 zsh(我用的是Ubuntu) 安装zsh1sudo apt-get install zsh 安装oh my zsh1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 配置zshzsh的配置在当前用户目录的.zshrc里。oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。 换主题打开～/.zshrc。oh my zsh提供了数十种主题，相关文件在~/.oh-my-zsh/themes下，你可以随意选择，我采用的是ys主题。在～/.zshrc文件中找到1ZSH_THEME="ys" 更改成你想要的主题就好了。 插件oh my zsh里提供了非常多的插件，相关文件在~/.oh-my-zsh/plugins文件夹下，默认有100多种，我们可以根据自己的实际需要加载特定的插件。插件也是在～/.zshrc里配置，找到plugins关键字，你就可以加载自己的插件了，系统默认加载 git ，你可以在后面追加内容。1plugins=(git autojump mvn last-working-dir) 下面简单介绍一下我用的这几个插件: git:当你处于git的目录下时，Shell 会明确显示 git和 branch，如图所示，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh autojumpautojump可以说是zsh必备插件，有点双剑合璧的意思。安装了autojump之后，zsh会自动记录你访问过的目录，通过j+目录就可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过～/workspace目录，输入j wor即可正确跳转，如图。j –stat 可以看你的历史路径库。 last-working-dirlast-working-dir 插件，可以记录上一次退出Shell时的所在路径，并且在下一次启动Shell时自动恢复到退出时所在的路径。这一切不需要进行任何操作，全部都是自动完成的。 命令纠错如图，输入1sudp apt-get install nyae会提示zsh: correct ‘sudp’ to ‘sudo’ [nyae]?接下来直接按y/n就行了。真是太贴心了有木有那如何开启nyae提示呢？打开～/.zshrc，找到配置项更改为“true”即可12# Uncomment the following line to enable command auto-correction. ENABLE_CORRECTION="true" 指定zsh为默认Shell输入命令1chsh -s /bin/zsh zsh操作 输入 grep 然后用上下箭头可以翻阅你执行过的所有 grep 命令 tab补全:路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。 目录浏览和跳转:输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转 在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，不再需要输入 cd 命令了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ubuntu15.4安装mac主题]]></title>
      <url>%2F2016%2F05%2F05%2FUbuntu15.4%E5%AE%89%E8%A3%85mac%E4%B8%BB%E9%A2%98%2F</url>
      <content type="text"><![CDATA[mac用习惯了，换Ubuntu以后，觉得还是mac的图标主题好看。于是动手把Ubuntu的图标字体换成了mac的样式。教程如下: 安装Unity Tweak Tool个性化调节工具 1sudo apt-get install unity-tweak-tool 安装主题和鼠标光标 1234sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install mbuntu-y-ithemes-v5sudo apt-get install mbuntu-y-icons-v5 在Unity Tweak Tool选择 效果 docky与docky主题如果喜欢dock，可用下面命令安装。我不喜欢，就没装1234sudo apt-get install dockysudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install mbuntu-y-docky-skins-v5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器神器--Vimium]]></title>
      <url>%2F2016%2F05%2F05%2Fvimium%2F</url>
      <content type="text"><![CDATA[自从学会了正确的坐姿,坐在电脑一整天腰也不酸了、背也不痛了，精神倍棒吃嘛嘛香但奈何使用鼠标久了,手腕、肩膀依旧疼痛。偶尔逛知乎，看到有人推荐chrome浏览器的vimium插件（火狐浏览器是vimperator），安装了使用了几天，真不愧是浏览器神器，好用到想哭，而且非常容易上手。下面让我们来认识一下它吧: vimium简介Vimium 这个名字其实是 Vim 和 Chromium 的合体。很多人可能不知道 Vim，Vim 其实是 Linux 等平台上的一款文本编辑器，熟练的运用它可以彻底脱离鼠标，通过一系列快捷键，来操作写代码。而 Vimium 则继承了 Vim 中的常用操作，让你在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。想像一下，你再也不需要移动鼠标去打开一个链接，手指不用离开键盘，这一切将会是多么的幸福。 vimium安装chrome网上商店链接:点我点我！ vimium快捷键安装好vimium，按Shift+/可查看帮助如下下面是我整理的常用方法的思维导图:（注意大小写） 常用操作 页面滚动浏览任何一个页面时，不管你想向上滚动，向下滚动，到页面最底部……都只用按一两个键就可以搞定: j:向下滚动一点 k:向上滚动一点 gg:到页面最底部 G:到页面最底部(大写，即shift+g) d:向下翻一屏 u:向上翻一屏- 打开页面- 复制链接打开在网页上看到一段不可点的链接文字。以前是要复制–&gt;新建标签页–&gt;粘贴–&gt;回车,这才能打开。现在呢？你只需要:复制链接–&gt;直接按「p」或「P」就可以打开。小写的 p 是在当前标签页打开，大写的 P 是在新建标签页打开。- 从收藏夹、历史记录打开:如果之前看过的网页，现在还想再看一遍，直接按下o或O，输入对应的关键字后，会搜索历史记录和收藏夹，如果你输的是一个网址，回车就能直接打开。小写的o是在当前标签页打开，大写的O是在新标签页打开。如图:- 打开当前页面的任意一个链接:按一下f，当前页面上所有可点击的链接，都会生成一个对应的快捷键分派给这些链接。例如我想点击“我的收藏”，只需要输入“SM”(按住shift，再按s、m键)，就打开了“我的收藏”页面。- 切换标签页 显示当前所有标签页:浏览网页时，经常会打开好几个网页，按一下大写的T，就可以显示当前打开的所有标签页 切换到上个标签页:按大写的J 切换到下个标签页:按大写的K- 当前页面操作 后退:大写的H键 前进;大写的L键 关闭当前页面:小写的x 恢复刚刚关闭的页面:大写的X 查看网页源代码:g+s键 刷新页面:小写的r键 总结以上就是vimium的日常操作方法了。熟练掌握它，妈妈再也不用担心我的手腕、肩膀痛了……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo建立个人博客]]></title>
      <url>%2F2016%2F04%2F29%2F%E4%BD%BF%E7%94%A8Hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[个人博客是程序员的名片之一,今天,我们来看怎么使用Hexo快速建立个人博客. 一.完工效果http://www.lingyv.cn/ 这是本人建立好的个人网站.有以下特点: 使用个人申请的特色域名 代码托管在github和coding上 二.需要使用的工具 Hexo (Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。) github链接 hexo帮助文档 主题icarus(更多主题) github coding(国内coding访问速度更快) 三.开始1. github pages, coding pages github创建个人站点设置站点主题进入资源-setting选择主题并发布,我的已经设置过一次了.所以会跟你的有所不同 coding pagescoding创建项目设置pages2. 安装Hexo博客框架 安装git 1$ sudo apt-get install git 安装Node.js 12$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh$ nvm install 4 安装Hexo1$ npm install -g hexo-cli 新建blogs文件夹,克隆项目 1git clone git@github.com:lingyv/lingyv.github.io.git 执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件 123$ hexo init lingyv.github.io$ cd lingyv.github.io$ npm install 新建出的各种文件信息查看帮助文档 4. 配置Hexo查看配置文档我的配置文件信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: 漫步太虚subtitle: lingyvdescription: codingauthor: lingyvlanguage: zh-CNtimezone:avatar: /images/touxiang.png# URL 网址## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.lingyv.cnroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 目录source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类&amp;标签default_category: uncategorizedcategory_map:tag_map:# Archivesarchive: 1category: 1tag: 1# Date / Time format 日期格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: github: git@github.com:lingyv/lingyv.github.io.git coding: git@git.coding.net:lingyv/lingyv.git branch: master 5. 配置主题Hexo主题很多,查看主题 下载icarus主题到本地1$ git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus 主题参考文档 启用主题打开 站点配置文件,找到 theme字段，并将其值更改为icarus. 配置主题配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869menu: 首页: . 归档: archives# Categories: categories# 标签: tagcloud 关于: /about# Customizecustomize: logo: enabled: true width: 40 height: 40 url: images/logo.png profile: enabled: true # Whether to show profile bar avatar: css/images/touxiang.png gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: 凌宇 author_title: Java &amp; Python location: Shanghai, China follow: https://github.com/lingyv highlight: monokai sidebar: right # sidebar position, options: left, right thumbnail: true # enable posts thumbnail, options: true, false favicon: # path to favicon social_links: github: https://github.com/lingyv weibo: http://weibo.com/5051531692/profile?topnav=1&amp;wvr=6&amp;is_all=1 linkedin: http://cn.linkedin.com/in/lingyv# twitter: /# facebook: /# dribbble: /# rss: /# Widgets 小工具widgets: - recent_posts - category - archive - tag - tagcloud - links# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: true # you need to disable other search engines to use Baidu search, options: true, false# Commentcomment:# disqus: hexo-theme-icarus # enter disqus shortname here #使用多说评论 duoshuo: lingyv# youyan: # enter youyan uid here# Shareshare: default # options: jiathis, bdshare, addtoany, default# Pluginsplugins: fancybox: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics google_site_verification: # enter Google site verification code baidu_analytics: # enter Baidu Analytics hash key# Miscellaneousmiscellaneous: open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: links:# Hexo: http://hexo.io 6. 购买域名去万网或相关域名购买网站,挑选一个自己喜欢的域名吧 7. 域名解析 8. Hexo使用指南操作指令参考文档12345hexo n "博客"== hexo new "博客"#新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 9. hexo d以后,刷新网站就可以看到部署好的效果了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Http请求与响应]]></title>
      <url>%2F2016%2F04%2F29%2F%E6%B5%85%E8%B0%88Http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
      <content type="text"><![CDATA[我是一个服务器，名字是www.lingyv.cn，门牌号是121.42.155.28，每天得工作就是跟各种浏览器打交道。他们总来我这要求取信息、存信息、删信息。可惜我才疏学浅，只稍微学过HTTP协议，所以看得懂用HTTP规定格式发过来的请求信，当然，回复他的时候也是用HTTP规范写回信。我家有一个看门的人（服务器进程），每当有浏览器想找我时，他就会过来通知我。 这不，说着说着他就进来了。 “报~~~有浏览器找您。” “好，跟他连线。” OK，TCP连接已建立…… 哒哒哒………打印机将请求报文打印了出来。 我拿过来看了看。 只见第一行写着。 “GET /student/composition/index.html HTTP/1.1” “恩，这是用1.1版本HTTP规范写的。原来是找我要student文件夹里composition文件夹中的index.html文件啊。”我在心里默念。 转眼扫到第二行：“Host：www.lingyv.cn ”恩，是找我的没错。接着往下看第三行：“Connerction：keep-alive”噢，他跟我说给他发完index.html后不要关闭跟他的连接 接着看第四、第五行： “Accept:text/html” “Accept-Language:zh-CN” 这是在告诉我他能接收哪些类型的信息以及他能接收的语言啊。然后看最后一行： “User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36” 噢~~~这是在跟我表明自己的身份啊。 看完请求报文。我已经明白了这位浏览器客户的需求。赶紧找到index.html文件，给这位浏览器客户回信（响应报文）。 首先表明我使用的规范以及他的请求是成功的。 “HTTP/1.1 200 OK” 然后表明我接受获取他获取文件的请求 “Accept-Ranges: bytes” 接着告诉他我给他文件的类型 “Content-Type:text/html; charset=UTF-8“ 写上日期时间： “Date:Wed, 13 Apr 2016 13:17:32 GMT“告诉他我的个人信息： “Server：Apache/2.0.61 (Unix)” 告诉他内容的长度： “Content-Length:1350” …… 把这些声明（响应头）写完了。接下来空一行把他想要的文件内容copy进去（响应体）。 好了，所有东西写完，我就把信（响应报文）给这位浏览器客户发了过去，让他得到自己想要的文件信息。]]></content>
    </entry>

    
  
  
</search>
